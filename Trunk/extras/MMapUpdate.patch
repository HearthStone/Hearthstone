Index: extras/mMap Builder/src/MapBuilder.cpp
===================================================================
--- extras/mMap Builder/src/MapBuilder.cpp	(revision 1490)
+++ extras/mMap Builder/src/MapBuilder.cpp	(working copy)
@@ -201,7 +201,7 @@
             return;
         }
 
-        buildTile(mapID, tileX, tileY, navMesh);
+        buildTile(mapID, tileX, tileY, navMesh, 0);
         freeNavMesh(navMesh);
     }
 
@@ -211,8 +211,8 @@
         printf("Building map %03u:\n", mapID);
 
         set<uint32>* tiles = getTileList(mapID);
-        
-        // make sure we process maps which don't have tiles
+
+		// make sure we process maps which don't have tiles
         if (!tiles->size())
         {
             // convert coord bounds to grid bounds
@@ -237,6 +237,7 @@
             return;
         }
 
+		uint32 TileCount = 0;
         // now start building mmtiles for each tile
         printf("We have %u tiles.                          \n", (unsigned int)tiles->size());
         for (set<uint32>::iterator it = tiles->begin(); it != tiles->end(); ++it)
@@ -249,7 +250,7 @@
             if (shouldSkipTile(mapID, tileX, tileY))
                 continue;
 
-            buildTile(mapID, tileX, tileY, navMesh);
+            buildTile(mapID, tileX, tileY, navMesh, TileCount++);
         }
 
         freeNavMesh(navMesh);
@@ -258,9 +259,9 @@
     }
 
     /**************************************************************************/
-    void MapBuilder::buildTile(uint32 mapID, uint32 tileX, uint32 tileY, dtNavMesh* navMesh)
+    void MapBuilder::buildTile(uint32 mapID, uint32 tileX, uint32 tileY, dtNavMesh* navMesh, uint32 index)
     {
-        printf("Building map %03u, tile [%02u,%02u]\n", mapID, tileX, tileY);
+        printf("Building map %03u[%02u,%02u] #:%04u     \r", mapID, tileX, tileY, index);
 
         MeshData meshData;
 
@@ -293,7 +294,7 @@
         m_terrainBuilder->loadOffMeshConnections(mapID, tileX, tileY, meshData, m_offMeshFilePath);
 
         // build navmesh tile
-        buildMoveMapTile(mapID, tileX, tileY, meshData, bmin, bmax, navMesh);
+        buildMoveMapTile(mapID, tileX, tileY, meshData, bmin, bmax, navMesh, index);
     }
 
     /**************************************************************************/
@@ -375,12 +376,12 @@
     /**************************************************************************/
     void MapBuilder::buildMoveMapTile(uint32 mapID, uint32 tileX, uint32 tileY,
                                       MeshData &meshData, float bmin[3], float bmax[3],
-                                      dtNavMesh* navMesh)
+                                      dtNavMesh* navMesh, uint32 index)
     {
         // console output
         char tileString[10];
         sprintf(tileString, "[%02i,%02i]: ", tileX, tileY);
-        printf("%s Building movemap tiles...                        \r", tileString);
+        printf("%s Building movemap tiles... #:%04u                 \r", tileString, index);
 
         IntermediateValues iv;
 
@@ -462,7 +463,7 @@
                 tile.solid = mallocHeightfield();
                 if (!tile.solid || !rcCreateHeightfield(m_rcContext, *tile.solid, tileCfg.width, tileCfg.height, tileCfg.bmin, tileCfg.bmax, tileCfg.cs, tileCfg.ch))
                 {
-                    printf("%sFailed building heightfield!            \n", tileString);
+                    printf("%sFailed building heightfield! #:%04u     \n", tileString, index);
                     continue;
                 }
 
@@ -483,33 +484,33 @@
                 tile.chf = mallocCompactHeightfield();
                 if (!tile.chf || !rcBuildCompactHeightfield(m_rcContext, tileCfg.walkableHeight, tileCfg.walkableClimb, *tile.solid, *tile.chf))
                 {
-                    printf("%sFailed compacting heightfield!            \n", tileString);
+                    printf("%sFailed compacting heightfield! #:%04u     \n", tileString, index);
                     continue;
                 }
 
                 // build polymesh intermediates
                 if (!rcErodeWalkableArea(m_rcContext, config.walkableRadius, *tile.chf))
                 {
-                    printf("%sFailed eroding area!                    \n", tileString);
+                    printf("%sFailed eroding area! #:%04u             \n", tileString, index);
                     continue;
                 }
 
                 if (!rcBuildDistanceField(m_rcContext, *tile.chf))
                 {
-                    printf("%sFailed building distance field!         \n", tileString);
+                    printf("%sFailed building distance field! #:%04u  \n", tileString, index);
                     continue;
                 }
 
                 if (!rcBuildRegions(m_rcContext, *tile.chf, tileCfg.borderSize, tileCfg.minRegionArea, tileCfg.mergeRegionArea))
                 {
-                    printf("%sFailed building regions!                \n", tileString);
+                    printf("%sFailed building regions! #:%04u         \n", tileString, index);
                     continue;
                 }
 
                 tile.cset = mallocContourSet();
                 if (!tile.cset || !rcBuildContours(m_rcContext, *tile.chf, tileCfg.maxSimplificationError, tileCfg.maxEdgeLen, *tile.cset))
                 {
-                    printf("%sFailed building contours!               \n", tileString);
+                    printf("%sFailed building contours! #:%04u        \n", tileString, index);
                     continue;
                 }
 
@@ -517,14 +518,14 @@
                 tile.pmesh = mallocPolyMesh();
                 if (!tile.pmesh || !rcBuildPolyMesh(m_rcContext, *tile.cset, tileCfg.maxVertsPerPoly, *tile.pmesh))
                 {
-                    printf("%sFailed building polymesh!               \n", tileString);
+                    printf("%sFailed building polymesh! #:%04u        \n", tileString, index);
                     continue;
                 }
 
                 tile.dmesh = mallocPolyMeshDetail();
                 if (!tile.dmesh || !rcBuildPolyMeshDetail(m_rcContext, *tile.pmesh, *tile.chf, tileCfg.detailSampleDist, tileCfg    .detailSampleMaxError, *tile.dmesh))
                 {
-                    printf("%sFailed building polymesh detail!        \n", tileString);
+					printf("%sFailed building polymesh detail! #:%04u \n", tileString, index);
                     continue;
                 }
 
@@ -544,14 +545,14 @@
         rcPolyMesh** pmmerge = new rcPolyMesh*[TILES_PER_MAP * TILES_PER_MAP];
         if (!pmmerge)
         {
-            printf("%s alloc pmmerge FIALED!          \r", tileString);
+            printf("%s alloc pmmerge FAILED! #:%04u   \r", tileString, index);
             return;
         }
 
         rcPolyMeshDetail** dmmerge = new rcPolyMeshDetail*[TILES_PER_MAP * TILES_PER_MAP];
         if (!dmmerge)
         {
-            printf("%s alloc dmmerge FIALED!          \r", tileString);
+            printf("%s alloc dmmerge FAILED! #:%04u   \r", tileString, index);
             return;
         }
 
@@ -573,7 +574,7 @@
         iv.polyMesh = mallocPolyMesh();
         if (!iv.polyMesh)
         {
-            printf("%s alloc iv.polyMesh FIALED!          \r", tileString);
+            printf("%s alloc iv.polyMesh FAILED! #:%04u   \r", tileString, index);
             return;
         }
         rcMergePolyMeshes(m_rcContext, pmmerge, nmerge, *iv.polyMesh);
@@ -581,7 +582,7 @@
         iv.polyMeshDetail = mallocPolyMeshDetail();
         if (!iv.polyMeshDetail)
         {
-            printf("%s alloc m_dmesh FIALED!          \r", tileString);
+            printf("%s alloc m_dmesh FAILED! #:%04u   \r", tileString, index);
             return;
         }
         rcMergePolyMeshDetails(m_rcContext, dmmerge, nmerge, *iv.polyMeshDetail);
@@ -609,19 +610,26 @@
         // setup mesh parameters
         dtNavMeshCreateParams params;
         memset(&params, 0, sizeof(params));
+
+		/// Initialize our vertices
         params.verts = iv.polyMesh->verts;
         params.vertCount = iv.polyMesh->nverts;
+
+		/// Initialize our Polygons
         params.polys = iv.polyMesh->polys;
         params.polyAreas = iv.polyMesh->areas;
         params.polyFlags = iv.polyMesh->flags;
         params.polyCount = iv.polyMesh->npolys;
         params.nvp = iv.polyMesh->nvp;
+
+		/// Initialize our detail :D
         params.detailMeshes = iv.polyMeshDetail->meshes;
         params.detailVerts = iv.polyMeshDetail->verts;
         params.detailVertsCount = iv.polyMeshDetail->nverts;
         params.detailTris = iv.polyMeshDetail->tris;
         params.detailTriCount = iv.polyMeshDetail->ntris;
 
+		/// Offmesh connections
         params.offMeshConVerts = meshData.offMeshConnections.getCArray();
         params.offMeshConCount = meshData.offMeshConnections.size()/6;
         params.offMeshConRad = meshData.offMeshConnectionRads.getCArray();
@@ -629,16 +637,19 @@
         params.offMeshConAreas = meshData.offMeshConnectionsAreas.getCArray();
         params.offMeshConFlags = meshData.offMeshConnectionsFlags.getCArray();
 
+		/// Bah
+        params.tileX = (((bmin[0] + bmax[0]) / 2) - navMesh->getParams()->orig[0]) / GRID_SIZE; // X
+        params.tileY = (((bmin[2] + bmax[2]) / 2) - navMesh->getParams()->orig[2]) / GRID_SIZE; // Y
+        params.tileLayer = (((bmin[1] + bmax[1]) / 2) - navMesh->getParams()->orig[1]) / GRID_SIZE; // Z
+        rcVcopy(params.bmin, bmin);
+        rcVcopy(params.bmax, bmax);
+
         params.walkableHeight = BASE_UNIT_DIM*config.walkableHeight;    // agent height
         params.walkableRadius = BASE_UNIT_DIM*config.walkableRadius;    // agent radius
         params.walkableClimb = BASE_UNIT_DIM*config.walkableClimb;      // keep less that walkableHeight (aka agent height)!
-        params.tileX = (((bmin[0] + bmax[0]) / 2) - navMesh->getParams()->orig[0]) / GRID_SIZE;
-        params.tileY = (((bmin[2] + bmax[2]) / 2) - navMesh->getParams()->orig[2]) / GRID_SIZE;
-        rcVcopy(params.bmin, bmin);
-        rcVcopy(params.bmax, bmax);
         params.cs = config.cs;
         params.ch = config.ch;
-        params.tileSize = VERTEX_PER_MAP;
+        params.buildBvTree = true; // TODO
 
         // will hold final navmesh
         unsigned char* navData = NULL;
@@ -650,12 +661,12 @@
             // so we have a clear error message
             if (params.nvp > DT_VERTS_PER_POLYGON)
             {
-                printf("%s Invalid verts-per-polygon value!        \n", tileString);
+                printf("%s Invalid verts-per-polygon value! #:%04u \n", tileString, index);
                 continue;
             }
             if (params.vertCount >= 0xffff)
             {
-                printf("%s Too many vertices!                      \n", tileString);
+                printf("%s Too many vertices! #:%04u               \n", tileString, index);
                 continue;
             }
             if (!params.vertCount || !params.verts)
@@ -673,30 +684,30 @@
                 // we have flat tiles with no actual geometry - don't build those, its useless
                 // keep in mind that we do output those into debug info
                 // drop tiles with only exact count - some tiles may have geometry while having less tiles
-                printf("%s No polygons to build on tile!              \n", tileString);
+                printf("%s No polygons to build on tile! #:%04u       \n", tileString, index);
                 continue;
             }
             if (!params.detailMeshes || !params.detailVerts || !params.detailTris)
             {
-                printf("%s No detail mesh to build tile!           \n", tileString);
+                printf("%s No detail mesh to build tile! #:%04u    \n", tileString, index);
                 continue;
             }
 
-            printf("%s Building navmesh tile...                \r", tileString);
+            printf("%s Building navmesh tile... #:%04u         \r", tileString, index);
             if (!dtCreateNavMeshData(&params, &navData, &navDataSize))
             {
-                printf("%s Failed building navmesh tile!           \n", tileString);
+                printf("%s Failed building navmesh tile! #:%04u    \n", tileString, index);
                 continue;
             }
 
             dtTileRef tileRef = 0;
-            printf("%s Adding tile to navmesh...                \r", tileString);
+            printf("%s Adding tile to navmesh... #:%04u         \r", tileString, index);
             // DT_TILE_FREE_DATA tells detour to unallocate memory when the tile
             // is removed via removeTile()
             dtStatus dtResult = navMesh->addTile(navData, navDataSize, DT_TILE_FREE_DATA, 0, &tileRef);
             if (!tileRef || dtResult != DT_SUCCESS)
             {
-                printf("%s Failed adding tile to navmesh!(%u)       \n", tileString, (uint)dtResult);
+                printf("%s Failed adding tile to navmesh!(%u) #:%04u\n", tileString, (uint)dtResult, index);
                 continue;
             }
 
@@ -707,13 +718,13 @@
             if (!file)
             {
                 char message[1024];
-                sprintf(message, "Failed to open %s for writing!\n", fileName);
+                sprintf(message, "Failed to open %s for writing! #:%04u\n", fileName, index);
                 perror(message);
                 navMesh->removeTile(tileRef, NULL, NULL);
                 continue;
             }
 
-            printf("%s Writing to file...                      \r", tileString);
+            printf("%s Writing to file... #:%04u               \r", tileString, index);
 
             // write header
             MmapTileHeader header;
Index: extras/mMap Builder/src/MapBuilder.h
===================================================================
--- extras/mMap Builder/src/MapBuilder.h	(revision 1490)
+++ extras/mMap Builder/src/MapBuilder.h	(working copy)
@@ -86,7 +86,7 @@
 
             void buildNavMesh(uint32 mapID, dtNavMesh* &navMesh);
 
-            void buildTile(uint32 mapID, uint32 tileX, uint32 tileY, dtNavMesh* navMesh);
+            void buildTile(uint32 mapID, uint32 tileX, uint32 tileY, dtNavMesh* navMesh, uint32 index);
 
             // move map building
             void buildMoveMapTile(uint32 mapID,
@@ -95,7 +95,8 @@
                                   MeshData &meshData,
                                   float bmin[3],
                                   float bmax[3],
-                                  dtNavMesh* navMesh);
+                                  dtNavMesh* navMesh,
+								  uint32 index);
 
             void getTileBounds(uint32 tileX, uint32 tileY,
                                float* verts, int vertCount,
Index: extras/mMap Builder/src/TerrainBuilder.cpp
===================================================================
--- extras/mMap Builder/src/TerrainBuilder.cpp	(revision 1490)
+++ extras/mMap Builder/src/TerrainBuilder.cpp	(working copy)
@@ -594,7 +594,7 @@
 
                 // transform data
                 float scale = instance.iScale;
-                G3D::Matrix3 rotation = G3D::Matrix3::fromEulerAnglesXYZ(G3D::pi()*instance.iRot.z/-180.f, G3D::pi()*instance.iRot.x/-180.f, G3D::pi()*instance.iRot.y/-180.f);
+                G3D::Matrix3 rotation = G3D::Matrix3::fromEulerAnglesZXY(G3D::pi()*instance.iRot.z/-180.f, G3D::pi()*instance.iRot.x/-180.f, G3D::pi()*instance.iRot.y/-180.f);
                 Vector3 position = instance.iPos;
                 position.x -= 32*GRID_SIZE;
                 position.y -= 32*GRID_SIZE;
Index: extras/mMap Builder/win/VC100/MoveMapGen_VC100.vcxproj
===================================================================
--- extras/mMap Builder/win/VC100/MoveMapGen_VC100.vcxproj	(revision 1490)
+++ extras/mMap Builder/win/VC100/MoveMapGen_VC100.vcxproj	(working copy)
@@ -151,11 +151,11 @@
     <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMeshBuilder.cpp" />
     <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMeshQuery.cpp" />
     <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNode.cpp" />
-    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourObstacleAvoidance.cpp" />
     <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\Recast.cpp" />
     <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastArea.cpp" />
     <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastContour.cpp" />
     <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastFilter.cpp" />
+    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastLayers.cpp" />
     <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastMesh.cpp" />
     <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastMeshDetail.cpp" />
     <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastRasterization.cpp" />
@@ -234,7 +234,7 @@
     <ClInclude Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMeshBuilder.h" />
     <ClInclude Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMeshQuery.h" />
     <ClInclude Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNode.h" />
-    <ClInclude Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourObstacleAvoidance.h" />
+    <ClInclude Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourStatus.h" />
     <ClInclude Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\Recast.h" />
     <ClInclude Include="..\..\src\MangosMap.h" />
     <ClInclude Include="..\..\src\MapBuilder.h" />
Index: extras/mMap Builder/win/VC100/MoveMapGen_VC100.vcxproj.filters
===================================================================
--- extras/mMap Builder/win/VC100/MoveMapGen_VC100.vcxproj.filters	(revision 1490)
+++ extras/mMap Builder/win/VC100/MoveMapGen_VC100.vcxproj.filters	(working copy)
@@ -60,48 +60,6 @@
     <ClCompile Include="..\..\..\..\src\hearthstone-shared\Collision\vmap\WorldModel.cpp">
       <Filter>Collision\vmap</Filter>
     </ClCompile>
-    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourCommon.cpp">
-      <Filter>Pathfinding\Detour</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMesh.cpp">
-      <Filter>Pathfinding\Detour</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMeshBuilder.cpp">
-      <Filter>Pathfinding\Detour</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMeshQuery.cpp">
-      <Filter>Pathfinding\Detour</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNode.cpp">
-      <Filter>Pathfinding\Detour</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourObstacleAvoidance.cpp">
-      <Filter>Pathfinding\Detour</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\Recast.cpp">
-      <Filter>Pathfinding\Recast</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastArea.cpp">
-      <Filter>Pathfinding\Recast</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastContour.cpp">
-      <Filter>Pathfinding\Recast</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastFilter.cpp">
-      <Filter>Pathfinding\Recast</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastMesh.cpp">
-      <Filter>Pathfinding\Recast</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastMeshDetail.cpp">
-      <Filter>Pathfinding\Recast</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastRasterization.cpp">
-      <Filter>Pathfinding\Recast</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastRegion.cpp">
-      <Filter>Pathfinding\Recast</Filter>
-    </ClCompile>
     <ClCompile Include="..\..\..\..\src\hearthstone-shared\Collision\g3dlite\Vector4int8.cpp">
       <Filter>Collision\G3D</Filter>
     </ClCompile>
@@ -207,6 +165,48 @@
     <ClCompile Include="..\..\..\..\src\hearthstone-shared\Collision\g3dlite\AABox.cpp">
       <Filter>Collision\G3D</Filter>
     </ClCompile>
+    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourCommon.cpp">
+      <Filter>Pathfinding\Detour</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMesh.cpp">
+      <Filter>Pathfinding\Detour</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMeshBuilder.cpp">
+      <Filter>Pathfinding\Detour</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMeshQuery.cpp">
+      <Filter>Pathfinding\Detour</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNode.cpp">
+      <Filter>Pathfinding\Detour</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\Recast.cpp">
+      <Filter>Pathfinding\Recast</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastArea.cpp">
+      <Filter>Pathfinding\Recast</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastContour.cpp">
+      <Filter>Pathfinding\Recast</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastFilter.cpp">
+      <Filter>Pathfinding\Recast</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastLayers.cpp">
+      <Filter>Pathfinding\Recast</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastMesh.cpp">
+      <Filter>Pathfinding\Recast</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastMeshDetail.cpp">
+      <Filter>Pathfinding\Recast</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastRasterization.cpp">
+      <Filter>Pathfinding\Recast</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastRegion.cpp">
+      <Filter>Pathfinding\Recast</Filter>
+    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="..\..\src\MMapCommon.h">
@@ -251,27 +251,6 @@
     <ClInclude Include="..\..\..\..\src\hearthstone-shared\Collision\vmap\WorldModel.h">
       <Filter>Collision\vmap</Filter>
     </ClInclude>
-    <ClInclude Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourCommon.h">
-      <Filter>Pathfinding\Detour</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMesh.h">
-      <Filter>Pathfinding\Detour</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMeshBuilder.h">
-      <Filter>Pathfinding\Detour</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMeshQuery.h">
-      <Filter>Pathfinding\Detour</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNode.h">
-      <Filter>Pathfinding\Detour</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourObstacleAvoidance.h">
-      <Filter>Pathfinding\Detour</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\Recast.h">
-      <Filter>Pathfinding\Recast</Filter>
-    </ClInclude>
     <ClInclude Include="..\..\..\..\src\hearthstone-shared\Collision\g3dlite\vectorMath.h">
       <Filter>Collision\G3D</Filter>
     </ClInclude>
@@ -431,5 +410,26 @@
     <ClInclude Include="..\..\..\..\src\hearthstone-shared\Collision\g3dlite\AABox.h">
       <Filter>Collision\G3D</Filter>
     </ClInclude>
+    <ClInclude Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourCommon.h">
+      <Filter>Pathfinding\Detour</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMesh.h">
+      <Filter>Pathfinding\Detour</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMeshBuilder.h">
+      <Filter>Pathfinding\Detour</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMeshQuery.h">
+      <Filter>Pathfinding\Detour</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNode.h">
+      <Filter>Pathfinding\Detour</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourStatus.h">
+      <Filter>Pathfinding\Detour</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\Recast.h">
+      <Filter>Pathfinding\Recast</Filter>
+    </ClInclude>
   </ItemGroup>
 </Project>
\ No newline at end of file
Index: src/hearthstone-shared/Network/ListenSocket.h
===================================================================
--- src/hearthstone-shared/Network/ListenSocket.h	(revision 1490)
+++ src/hearthstone-shared/Network/ListenSocket.h	(working copy)
@@ -161,10 +161,9 @@
 	void OnAccept(void * pointer)
 	{
 		int fd = *(int*)pointer;
-
-		/* no idea if this will work on x64 :P */
+		char* cpointer = ((char*)pointer);
 #ifndef X64
-		sockaddr_in * addr = (sockaddr_in*)&((char*)pointer)[42];
+		sockaddr_in * addr = (sockaddr_in*)&cpointer[42];
 #else
 		// Crow: This will work for x64, at least with what I've tested.
 		// Unsure about external IPs, as when scanning data, I saw the IP appear twice, once at 4, and once at somewhere around 12
Index: src/hearthstone-shared/Pathfinding/Detour/DetourCommon.cpp
===================================================================
--- src/hearthstone-shared/Pathfinding/Detour/DetourCommon.cpp	(revision 1490)
+++ src/hearthstone-shared/Pathfinding/Detour/DetourCommon.cpp	(working copy)
@@ -42,7 +42,7 @@
 		dtVcopy(closest, a);
 		return;
 	}
-	
+
 	// Check if P in vertex region outside B
 	float bp[3];
 	dtVsub(bp, p, b);
@@ -54,7 +54,7 @@
 		dtVcopy(closest, b);
 		return;
 	}
-	
+
 	// Check if P in edge region of AB, if so return projection of P onto AB
 	float vc = d1*d4 - d3*d2;
 	if (vc <= 0.0f && d1 >= 0.0f && d3 <= 0.0f)
@@ -66,7 +66,7 @@
 		closest[2] = a[2] + v * ab[2];
 		return;
 	}
-	
+
 	// Check if P in vertex region outside C
 	float cp[3];
 	dtVsub(cp, p, c);
@@ -78,7 +78,7 @@
 		dtVcopy(closest, c);
 		return;
 	}
-	
+
 	// Check if P in edge region of AC, if so return projection of P onto AC
 	float vb = d5*d2 - d1*d6;
 	if (vb <= 0.0f && d2 >= 0.0f && d6 <= 0.0f)
@@ -90,7 +90,7 @@
 		closest[2] = a[2] + w * ac[2];
 		return;
 	}
-	
+
 	// Check if P in edge region of BC, if so return projection of P onto BC
 	float va = d3*d6 - d5*d4;
 	if (va <= 0.0f && (d4 - d3) >= 0.0f && (d5 - d6) >= 0.0f)
@@ -102,7 +102,7 @@
 		closest[2] = b[2] + w * (c[2] - b[2]);
 		return;
 	}
-	
+
 	// P inside face region. Compute Q through its barycentric coordinates (u,v,w)
 	float denom = 1.0f / (va + vb + vc);
 	float v = vb * denom;
@@ -118,15 +118,15 @@
 							  int& segMin, int& segMax)
 {
 	static const float EPS = 0.00000001f;
-	
+
 	tmin = 0;
 	tmax = 1;
 	segMin = -1;
 	segMax = -1;
-	
+
 	float dir[3];
 	dtVsub(dir, p1, p0);
-	
+
 	for (int i = 0, j = nverts-1; i < nverts; j=i++)
 	{
 		float edge[3], diff[3];
@@ -168,7 +168,7 @@
 			}
 		}
 	}
-	
+
 	return true;
 }
 
@@ -212,13 +212,13 @@
 	dtVsub(v0, c,a);
 	dtVsub(v1, b,a);
 	dtVsub(v2, p,a);
-	
+
 	const float dot00 = dtVdot2D(v0, v0);
 	const float dot01 = dtVdot2D(v0, v1);
 	const float dot02 = dtVdot2D(v0, v2);
 	const float dot11 = dtVdot2D(v1, v1);
 	const float dot12 = dtVdot2D(v1, v2);
-	
+
 	// Compute barycentric coordinates
 	const float invDenom = 1.0f / (dot00 * dot11 - dot01 * dot01);
 	const float u = (dot11 * dot02 - dot01 * dot12) * invDenom;
@@ -227,17 +227,20 @@
 	// The (sloppy) epsilon is needed to allow to get height of points which
 	// are interpolated along the edges of the triangles.
 	static const float EPS = 1e-4f;
-	
+
 	// If point lies inside the triangle, return interpolated ycoord.
 	if (u >= -EPS && v >= -EPS && (u+v) <= 1+EPS)
 	{
 		h = a[1] + v0[1]*u + v1[1]*v;
 		return true;
 	}
-	
+
 	return false;
 }
 
+/// @par
+///
+/// All points are projected onto the xz-plane, so the y-values are ignored.
 bool dtPointInPolygon(const float* pt, const float* verts, const int nverts)
 {
 	// TODO: Replace pnpoly with triArea2D tests?
@@ -291,11 +294,14 @@
 	return ((amin+eps) > bmax || (amax-eps) < bmin) ? false : true;
 }
 
+/// @par
+///
+/// All vertices are projected onto the xz-plane, so the y-values are ignored.
 bool dtOverlapPolyPoly2D(const float* polya, const int npolya,
 						 const float* polyb, const int npolyb)
 {
 	const float eps = 1e-4f;
-	
+
 	for (int i = 0, j = npolya-1; i < npolya; j=i++)
 	{
 		const float* va = &polya[j*3];
Index: src/hearthstone-shared/Pathfinding/Detour/DetourCommon.h
===================================================================
--- src/hearthstone-shared/Pathfinding/Detour/DetourCommon.h	(revision 1490)
+++ src/hearthstone-shared/Pathfinding/Detour/DetourCommon.h	(working copy)
@@ -19,27 +19,91 @@
 #ifndef DETOURCOMMON_H
 #define DETOURCOMMON_H
 
+#if defined(SHARED_LIB_BUILDER) || defined(_GAME)
+#define PRINTF printf
+#endif
+
+/**
+@defgroup detour Detour
+
+Members in this module are used to create, manipulate, and query navigation
+meshes.
+
+@note This is a summary list of members.  Use the index or search
+feature to find minor members.
+*/
+
+/// @name General helper functions
+/// @{
+
+/// Swaps the values of the two parameters.
+///  @param[in,out]	a	Value A
+///  @param[in,out]	b	Value B
 template<class T> inline void dtSwap(T& a, T& b) { T t = a; a = b; b = t; }
+
+/// Returns the minimum of two values.
+///  @param[in]		a	Value A
+///  @param[in]		b	Value B
+///  @return The minimum of the two values.
 template<class T> inline T dtMin(T a, T b) { return a < b ? a : b; }
+
+/// Returns the maximum of two values.
+///  @param[in]		a	Value A
+///  @param[in]		b	Value B
+///  @return The maximum of the two values.
 template<class T> inline T dtMax(T a, T b) { return a > b ? a : b; }
+
+/// Returns the absolute value.
+///  @param[in]		a	The value.
+///  @return The absolute value of the specified value.
 template<class T> inline T dtAbs(T a) { return a < 0 ? -a : a; }
+
+/// Returns the square of the value.
+///  @param[in]		a	The value.
+///  @return The square of the value.
 template<class T> inline T dtSqr(T a) { return a*a; }
+
+/// Clamps the value to the specified range.
+///  @param[in]		v	The value to clamp.
+///  @param[in]		mn	The minimum permitted return value.
+///  @param[in]		mx	The maximum permitted return value.
+///  @return The value, clamped to the specified range.
 template<class T> inline T dtClamp(T v, T mn, T mx) { return v < mn ? mn : (v > mx ? mx : v); }
 
+/// Returns the square root of the value.
+///  @param[in]		x	The value.
+///  @return The square root of the vlaue.
 float dtSqrt(float x);
 
+/// @}
+/// @name Vector helper functions.
+/// @{
+
+/// Derives the cross product of two vectors. (@p v1 x @p v2)
+///  @param[out]	dest	The cross product. [(x, y, z)]
+///  @param[in]		v1		A Vector [(x, y, z)]
+///  @param[in]		v2		A vector [(x, y, z)]
 inline void dtVcross(float* dest, const float* v1, const float* v2)
 {
 	dest[0] = v1[1]*v2[2] - v1[2]*v2[1];
 	dest[1] = v1[2]*v2[0] - v1[0]*v2[2];
-	dest[2] = v1[0]*v2[1] - v1[1]*v2[0]; 
+	dest[2] = v1[0]*v2[1] - v1[1]*v2[0];
 }
 
+/// Derives the dot product of two vectors. (@p v1 . @p v2)
+///  @param[in]		v1	A Vector [(x, y, z)]
+///  @param[in]		v2	A vector [(x, y, z)]
+/// @return The dot product.
 inline float dtVdot(const float* v1, const float* v2)
 {
 	return v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];
 }
 
+/// Performs a scaled vector addition. (@p v1 + (@p v2 * @p s))
+///  @param[out]	dest	The result vector. [(x, y, z)]
+///  @param[in]		v1		The base vector. [(x, y, z)]
+///  @param[in]		v2		The vector to scale and add to @p v1. [(x, y, z)]
+///  @param[in]		s		The amount to scale @p v2 by before adding to @p v1.
 inline void dtVmad(float* dest, const float* v1, const float* v2, const float s)
 {
 	dest[0] = v1[0]+v2[0]*s;
@@ -47,6 +111,11 @@
 	dest[2] = v1[2]+v2[2]*s;
 }
 
+/// Performs a linear interpolation between two vectors. (@p v1 toward @p v2)
+///  @param[out]	dest	The result vector. [(x, y, x)]
+///  @param[in]		v1		The starting vector.
+///  @param[in]		v2		The destination vector.
+///	 @param[in]		t		The interpolation factor. [Limits: 0 <= value <= 1.0]
 inline void dtVlerp(float* dest, const float* v1, const float* v2, const float t)
 {
 	dest[0] = v1[0]+(v2[0]-v1[0])*t;
@@ -54,6 +123,10 @@
 	dest[2] = v1[2]+(v2[2]-v1[2])*t;
 }
 
+/// Performs a vector addition. (@p v1 + @p v2)
+///  @param[out]	dest	The result vector. [(x, y, z)]
+///  @param[in]		v1		The base vector. [(x, y, z)]
+///  @param[in]		v2		The vector to add to @p v1. [(x, y, z)]
 inline void dtVadd(float* dest, const float* v1, const float* v2)
 {
 	dest[0] = v1[0]+v2[0];
@@ -61,6 +134,10 @@
 	dest[2] = v1[2]+v2[2];
 }
 
+/// Performs a vector subtraction. (@p v1 - @p v2)
+///  @param[out]	dest	The result vector. [(x, y, z)]
+///  @param[in]		v1		The base vector. [(x, y, z)]
+///  @param[in]		v2		The vector to subtract from @p v1. [(x, y, z)]
 inline void dtVsub(float* dest, const float* v1, const float* v2)
 {
 	dest[0] = v1[0]-v2[0];
@@ -68,6 +145,10 @@
 	dest[2] = v1[2]-v2[2];
 }
 
+/// Scales the vector by the specified value. (@p v * @p t)
+///  @param[out]	dest	The result vector. [(x, y, z)]
+///  @param[in]		v		The vector to scale. [(x, y, z)]
+///  @param[in]		t		The scaling factor.
 inline void dtVscale(float* dest, const float* v, const float t)
 {
 	dest[0] = v[0]*t;
@@ -75,6 +156,9 @@
 	dest[2] = v[2]*t;
 }
 
+/// Selects the minimum value of each element from the specified vectors.
+///  @param[in,out]	mn	A vector.  (Will be updated with the result.) [(x, y, z)]
+///  @param[in]	v	A vector. [(x, y, z)]
 inline void dtVmin(float* mn, const float* v)
 {
 	mn[0] = dtMin(mn[0], v[0]);
@@ -82,6 +166,9 @@
 	mn[2] = dtMin(mn[2], v[2]);
 }
 
+/// Selects the maximum value of each element from the specified vectors.
+///  @param[in,out]	mx	A vector.  (Will be updated with the result.) [(x, y, z)]
+///  @param[in]		v	A vector. [(x, y, z)]
 inline void dtVmax(float* mx, const float* v)
 {
 	mx[0] = dtMax(mx[0], v[0]);
@@ -89,11 +176,19 @@
 	mx[2] = dtMax(mx[2], v[2]);
 }
 
+/// Sets the vector elements to the specified values.
+///  @param[out]	dest	The result vector. [(x, y, z)]
+///  @param[in]		x		The x-value of the vector.
+///  @param[in]		y		The y-value of the vector.
+///  @param[in]		z		The z-value of the vector.
 inline void dtVset(float* dest, const float x, const float y, const float z)
 {
 	dest[0] = x; dest[1] = y; dest[2] = z;
 }
 
+/// Performs a vector copy.
+///  @param[out]	dest	The result. [(x, y, z)]
+///  @param[in]		a		The vector to copy. [(x, y, z)]
 inline void dtVcopy(float* dest, const float* a)
 {
 	dest[0] = a[0];
@@ -101,16 +196,26 @@
 	dest[2] = a[2];
 }
 
+/// Derives the scalar length of the vector.
+///  @param[in]		v The vector. [(x, y, z)]
+/// @return The scalar length of the vector.
 inline float dtVlen(const float* v)
 {
 	return dtSqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
 }
 
+/// Derives the square of the scalar length of the vector. (len * len)
+///  @param[in]		v The vector. [(x, y, z)]
+/// @return The square of the scalar length of the vector.
 inline float dtVlenSqr(const float* v)
 {
 	return v[0]*v[0] + v[1]*v[1] + v[2]*v[2];
 }
 
+/// Returns the distance between two points.
+///  @param[in]		v1	A point. [(x, y, z)]
+///  @param[in]		v2	A point. [(x, y, z)]
+/// @return The distance between the two points.
 inline float dtVdist(const float* v1, const float* v2)
 {
 	const float dx = v2[0] - v1[0];
@@ -119,6 +224,10 @@
 	return dtSqrt(dx*dx + dy*dy + dz*dz);
 }
 
+/// Returns the square of the distance between two points.
+///  @param[in]		v1	A point. [(x, y, z)]
+///  @param[in]		v2	A point. [(x, y, z)]
+/// @return The square of the distance between the two points.
 inline float dtVdistSqr(const float* v1, const float* v2)
 {
 	const float dx = v2[0] - v1[0];
@@ -127,6 +236,12 @@
 	return dx*dx + dy*dy + dz*dz;
 }
 
+/// Derives the distance between the specified points on the xz-plane.
+///  @param[in]		v1	A point. [(x, y, z)]
+///  @param[in]		v2	A point. [(x, y, z)]
+/// @return The distance between the point on the xz-plane.
+///
+/// The vectors are projected onto the xz-plane, so the y-values are ignored.
 inline float dtVdist2D(const float* v1, const float* v2)
 {
 	const float dx = v2[0] - v1[0];
@@ -134,6 +249,10 @@
 	return dtSqrt(dx*dx + dz*dz);
 }
 
+/// Derives the square of the distance between the specified points on the xz-plane.
+///  @param[in]		v1	A point. [(x, y, z)]
+///  @param[in]		v2	A point. [(x, y, z)]
+/// @return The square of the distance between the point on the xz-plane.
 inline float dtVdist2DSqr(const float* v1, const float* v2)
 {
 	const float dx = v2[0] - v1[0];
@@ -141,6 +260,8 @@
 	return dx*dx + dz*dz;
 }
 
+/// Normalizes the vector.
+///  @param[in,out]	v	The vector to normalize. [(x, y, z)]
 inline void dtVnormalize(float* v)
 {
 	float d = 1.0f / dtSqrt(dtSqr(v[0]) + dtSqr(v[1]) + dtSqr(v[2]));
@@ -149,6 +270,13 @@
 	v[2] *= d;
 }
 
+/// Performs a 'sloppy' colocation check of the specified points.
+///  @param[in]		p0	A point. [(x, y, z)]
+///  @param[in]		p1	A point. [(x, y, z)]
+/// @return True if the points are considered to be at the same location.
+///
+/// Basically, this function will return true if the specified points are
+/// close enough to eachother to be considered colocated.
 inline bool dtVequal(const float* p0, const float* p1)
 {
 	static const float thr = dtSqr(1.0f/16384.0f);
@@ -156,44 +284,37 @@
 	return d < thr;
 }
 
-inline unsigned int dtNextPow2(unsigned int v)
-{
-	v--;
-	v |= v >> 1;
-	v |= v >> 2;
-	v |= v >> 4;
-	v |= v >> 8;
-	v |= v >> 16;
-	v++;
-	return v;
-}
-
-inline unsigned int dtIlog2(unsigned int v)
-{
-	unsigned int r;
-	unsigned int shift;
-	r = (v > 0xffff) << 4; v >>= r;
-	shift = (v > 0xff) << 3; v >>= shift; r |= shift;
-	shift = (v > 0xf) << 2; v >>= shift; r |= shift;
-	shift = (v > 0x3) << 1; v >>= shift; r |= shift;
-	r |= (v >> 1);
-	return r;
-}
-
-inline int dtAlign4(int x) { return (x+3) & ~3; }
-
-inline int dtOppositeTile(int side) { return (side+4) & 0x7; }
-
+/// Derives the dot product of two vectors on the xz-plane. (@p u . @p v)
+///  @param[in]		u		A vector [(x, y, z)]
+///  @param[in]		v		A vector [(x, y, z)]
+/// @return The dot product on the xz-plane.
+///
+/// The vectors are projected onto the xz-plane, so the y-values are ignored.
 inline float dtVdot2D(const float* u, const float* v)
 {
 	return u[0]*v[0] + u[2]*v[2];
 }
 
+/// Derives the xz-plane 2D perp product of the two vectors. (uz*vx - ux*vz)
+///  @param[in]		u		The LHV vector [(x, y, z)]
+///  @param[in]		v		The RHV vector [(x, y, z)]
+/// @return The dot product on the xz-plane.
+///
+/// The vectors are projected onto the xz-plane, so the y-values are ignored.
 inline float dtVperp2D(const float* u, const float* v)
 {
 	return u[2]*v[0] - u[0]*v[2];
 }
 
+/// @}
+/// @name Computational geometry helper functions.
+/// @{
+
+/// Derives the signed xz-plane area of the triangle ABC, or the relationship of line AB to point C.
+///  @param[in]		a		Vertex A. [(x, y, z)]
+///  @param[in]		b		Vertex B. [(x, y, z)]
+///  @param[in]		c		Vertex C. [(x, y, z)]
+/// @return The signed xz-plane area of the triangle.
 inline float dtTriArea2D(const float* a, const float* b, const float* c)
 {
 	const float abx = b[0] - a[0];
@@ -203,6 +324,13 @@
 	return acx*abz - abx*acz;
 }
 
+/// Determines if two axis-aligned bounding boxes overlap.
+///  @param[in]		amin	Minimum bounds of box A. [(x, y, z)]
+///  @param[in]		amax	Maximum bounds of box A. [(x, y, z)]
+///  @param[in]		bmin	Minimum bounds of box B. [(x, y, z)]
+///  @param[in]		bmax	Maximum bounds of box B. [(x, y, z)]
+/// @return True if the two AABB's overlap.
+/// @see dtOverlapBounds
 inline bool dtOverlapQuantBounds(const unsigned short amin[3], const unsigned short amax[3],
 								 const unsigned short bmin[3], const unsigned short bmax[3])
 {
@@ -213,6 +341,13 @@
 	return overlap;
 }
 
+/// Determines if two axis-aligned bounding boxes overlap.
+///  @param[in]		amin	Minimum bounds of box A. [(x, y, z)]
+///  @param[in]		amax	Maximum bounds of box A. [(x, y, z)]
+///  @param[in]		bmin	Minimum bounds of box B. [(x, y, z)]
+///  @param[in]		bmax	Maximum bounds of box B. [(x, y, z)]
+/// @return True if the two AABB's overlap.
+/// @see dtOverlapQuantBounds
 inline bool dtOverlapBounds(const float* amin, const float* amax,
 							const float* bmin, const float* bmax)
 {
@@ -223,9 +358,21 @@
 	return overlap;
 }
 
+/// Derives the closest point on a triangle from the specified reference point.
+///  @param[out]	closest	The closest point on the triangle.
+///  @param[in]		p		The reference point from which to test. [(x, y, z)]
+///  @param[in]		a		Vertex A of triangle ABC. [(x, y, z)]
+///  @param[in]		b		Vertex B of triangle ABC. [(x, y, z)]
+///  @param[in]		c		Vertex C of triangle ABC. [(x, y, z)]
 void dtClosestPtPointTriangle(float* closest, const float* p,
 							  const float* a, const float* b, const float* c);
 
+/// Derives the y-axis height of the closest point on the triangle from the specified reference point.
+///  @param[in]		p		The reference point from which to test. [(x, y, z)]
+///  @param[in]		a		Vertex A of triangle ABC. [(x, y, z)]
+///  @param[in]		b		Vertex B of triangle ABC. [(x, y, z)]
+///  @param[in]		c		Vertex C of triangle ABC. [(x, y, z)]
+///  @param[out]	h		The resulting height.
 bool dtClosestHeightPointTriangle(const float* p, const float* a, const float* b, const float* c, float& h);
 
 bool dtIntersectSegmentPoly2D(const float* p0, const float* p1,
@@ -233,6 +380,11 @@
 							  float& tmin, float& tmax,
 							  int& segMin, int& segMax);
 
+/// Determines if the specified point is inside the convex polygon on the xz-plane.
+///  @param[in]		pt		The point to check. [(x, y, z)]
+///  @param[in]		verts	The polygon vertices. [(x, y, z) * @p nverts]
+///  @param[in]		nverts	The number of vertices. [Limit: >= 3]
+/// @return True if the point is inside the polygon.
 bool dtPointInPolygon(const float* pt, const float* verts, const int nverts);
 
 bool dtDistancePtPolyEdgesSqr(const float* pt, const float* verts, const int nverts,
@@ -240,9 +392,99 @@
 
 float dtDistancePtSegSqr2D(const float* pt, const float* p, const float* q, float& t);
 
+/// Derives the centroid of a convex polygon.
+///  @param[out]	tc		The centroid of the polgyon. [(x, y, z)]
+///  @param[in]		idx		The polygon indices. [(vertIndex) * @p nidx]
+///  @param[in]		nidx	The number of indices in the polygon. [Limit: >= 3]
+///  @param[in]		verts	The polygon vertices. [(x, y, z) * vertCount]
 void dtCalcPolyCenter(float* tc, const unsigned short* idx, int nidx, const float* verts);
 
+/// Determines if the two convex polygons overlap on the xz-plane.
+///  @param[in]		polya		Polygon A vertices.	[(x, y, z) * @p npolya]
+///  @param[in]		npolya		The number of vertices in polygon A.
+///  @param[in]		polyb		Polygon B vertices.	[(x, y, z) * @p npolyb]
+///  @param[in]		npolyb		The number of vertices in polygon B.
+/// @return True if the two polygons overlap.
 bool dtOverlapPolyPoly2D(const float* polya, const int npolya,
 						 const float* polyb, const int npolyb);
 
+/// @}
+/// @name Miscellanious functions.
+/// @{
+
+inline unsigned int dtNextPow2(unsigned int v)
+{
+	v--;
+	v |= v >> 1;
+	v |= v >> 2;
+	v |= v >> 4;
+	v |= v >> 8;
+	v |= v >> 16;
+	v++;
+	return v;
+}
+
+inline unsigned int dtIlog2(unsigned int v)
+{
+	unsigned int r;
+	unsigned int shift;
+	r = (v > 0xffff) << 4; v >>= r;
+	shift = (v > 0xff) << 3; v >>= shift; r |= shift;
+	shift = (v > 0xf) << 2; v >>= shift; r |= shift;
+	shift = (v > 0x3) << 1; v >>= shift; r |= shift;
+	r |= (v >> 1);
+	return r;
+}
+
+inline int dtAlign4(int x) { return (x+3) & ~3; }
+
+inline int dtOppositeTile(int side) { return (side+4) & 0x7; }
+
+/// @}
+
 #endif // DETOURCOMMON_H
+
+///////////////////////////////////////////////////////////////////////////
+
+// This section contains detailed documentation for members that don't have
+// a source file. It reduces clutter in the main section of the header.
+
+/**
+
+@fn float dtTriArea2D(const float* a, const float* b, const float* c)
+@par
+
+The vertices are projected onto the xz-plane, so the y-values are ignored.
+
+This is a low cost function than can be used for various purposes.  Its main purpose
+is for point/line relationship testing.
+
+In all cases: A value of zero indicates that all vertices are collinear or represent the same point.
+(On the xz-plane.)
+
+When used for point/line relationship tests, AB usually represents a line against which
+the C point is to be tested.  In this case:
+
+A positive value indicates that point C is to the left of line AB, looking from A toward B.<br/>
+A negative value indicates that point C is to the right of lineAB, looking from A toward B.
+
+When used for evaluating a triangle:
+
+The absolute value of the return value is two times the area of the triangle when it is
+projected onto the xz-plane.
+
+A positive return value indicates:
+
+<ul>
+<li>The vertices are wrapped in the normal Detour wrap direction.</li>
+<li>The triangle's 3D face normal is in the general up direction.</li>
+</ul>
+
+A negative return value indicates:
+
+<ul>
+<li>The vertices are reverse wrapped. (Wrapped opposite the normal Detour wrap direction.)</li>
+<li>The triangle's 3D face normal is in the general down direction.</li>
+</ul>
+
+*/
Index: src/hearthstone-shared/Pathfinding/Detour/DetourNavMesh.cpp
===================================================================
--- src/hearthstone-shared/Pathfinding/Detour/DetourNavMesh.cpp	(revision 1490)
+++ src/hearthstone-shared/Pathfinding/Detour/DetourNavMesh.cpp	(working copy)
@@ -21,8 +21,7 @@
 #include "DetourCommon.h"
 #include "../../Common.h"
 
-
-inline bool overlapSlabs(const float* amin, const float* amax,
+bool overlapSlabs(const float* amin, const float* amax,
 						 const float* bmin, const float* bmax,
 						 const float px, const float py)
 {
@@ -33,7 +32,7 @@
 	const float maxx = dtMin(amax[0]-px,bmax[0]-px);
 	if (minx > maxx)
 		return false;
-	
+
 	// Check vertical overlap.
 	const float ad = (amax[1]-amin[1]) / (amax[0]-amin[0]);
 	const float ak = amin[1] - ad*amin[0];
@@ -45,19 +44,28 @@
 	const float bmaxy = bd*maxx + bk;
 	const float dmin = bminy - aminy;
 	const float dmax = bmaxy - amaxy;
-		
+
 	// Crossing segments always overlap.
 	if (dmin*dmax < 0)
 		return true;
-		
+
 	// Check for overlap at endpoints.
 	const float thr = dtSqr(py*2);
 	if (dmin*dmin <= thr || dmax*dmax <= thr)
 		return true;
-		
+
 	return false;
 }
 
+static float getSlabCoord(const float* va, const int side)
+{
+	if (side == 0 || side == 4)
+		return va[0];
+	else if (side == 2 || side == 6)
+		return va[2];
+	return 0;
+}
+
 static void calcSlabEndPoints(const float* va, const float* vb, float* bmin, float* bmax, const int side)
 {
 	if (side == 0 || side == 4)
@@ -96,7 +104,7 @@
 	}
 }
 
-inline int computeTileHash(int x, int y, const int mask)
+int computeTileHash(int x, int y, const int mask)
 {
 	const unsigned int h1 = 0x8da6b343; // Large multiplicative constants;
 	const unsigned int h2 = 0xd8163841; // here arbitrarily chosen primes
@@ -104,7 +112,7 @@
 	return (int)(n & mask);
 }
 
-inline unsigned int allocLink(dtMeshTile* tile)
+unsigned int allocLink(dtMeshTile* tile)
 {
 	if (tile->linksFreeList == DT_NULL_LINK)
 		return DT_NULL_LINK;
@@ -113,7 +121,7 @@
 	return link;
 }
 
-inline void freeLink(dtMeshTile* tile, unsigned int link)
+void freeLink(dtMeshTile* tile, unsigned int link)
 {
 	tile->links[link].next = tile->linksFreeList;
 	tile->linksFreeList = link;
@@ -127,6 +135,10 @@
 	return new(mem) dtNavMesh;
 }
 
+/// @par
+///
+/// This function will only free the memory for tiles with the #DT_TILE_FREE_DATA
+/// flag set.
 void freeNavMesh(dtNavMesh* navmesh)
 {
 	if (!navmesh) return;
@@ -135,6 +147,19 @@
 }
 
 //////////////////////////////////////////////////////////////////////////////////////////
+
+/// @class dtNavMesh
+///
+/// This class is usually used in conjunction with the dtNavMeshQuery class.
+/// 
+/// Technically, all navigation meshes are tiled. A 'solo' mesh is simply a navigation mesh initialized 
+/// to have only a single tile.
+///
+/// This class does not implement any asynchronous methods. So the ::dtStatus result of all methods will 
+/// always contain either a success or failure flag.
+/// 
+/// @see dtNavMeshQuery, dtCreateNavMeshData(), dtNavMeshCreateParams, #mallocNavMesh, #freeNavMesh
+
 dtNavMesh::dtNavMesh() :
 	m_tileWidth(0),
 	m_tileHeight(0),
@@ -167,26 +192,26 @@
 	free(m_posLookup);
 	free(m_tiles);
 }
-		
+
 dtStatus dtNavMesh::init(const dtNavMeshParams* params)
 {
 	memcpy(&m_params, params, sizeof(dtNavMeshParams));
 	dtVcopy(m_orig, params->orig);
 	m_tileWidth = params->tileWidth;
 	m_tileHeight = params->tileHeight;
-	
+
 	// Init tiles
 	m_maxTiles = params->maxTiles;
 	m_tileLutSize = dtNextPow2(params->maxTiles/4);
 	if (!m_tileLutSize) m_tileLutSize = 1;
 	m_tileLutMask = m_tileLutSize-1;
-	
+
 	m_tiles = (dtMeshTile*)malloc(sizeof(dtMeshTile)*m_maxTiles);
 	if (!m_tiles)
-		return DT_FAILURE;
+		return DT_FAILURE | DT_OUT_OF_MEMORY;
 	m_posLookup = (dtMeshTile**)malloc(sizeof(dtMeshTile*)*m_tileLutSize);
 	if (!m_posLookup)
-		return DT_FAILURE;
+		return DT_FAILURE | DT_OUT_OF_MEMORY;
 	memset(m_tiles, 0, sizeof(dtMeshTile)*m_maxTiles);
 	memset(m_posLookup, 0, sizeof(dtMeshTile*)*m_tileLutSize);
 	m_nextFree = 0;
@@ -196,14 +221,19 @@
 		m_tiles[i].next = m_nextFree;
 		m_nextFree = &m_tiles[i];
 	}
-	
+
+	/* Init ID generator values.
+	m_tileBits = dtIlog2(dtNextPow2((unsigned int)params->maxTiles));
+	m_polyBits = dtIlog2(dtNextPow2((unsigned int)params->maxPolys));
+	// Only allow 31 salt bits, since the salt mask is calculated using 32bit uint and it will overflow.
+	m_saltBits = dtMin((unsigned int)31, 32 - m_tileBits - m_polyBits);
+	if (m_saltBits < 10)
+		return DT_FAILURE | DT_INVALID_PARAM;*/
+
 	// Init ID generator values.
-	m_tileBits = STATIC_TILE_BITS;    //dtIlog2(dtNextPow2((unsigned int)params->maxTiles));
-	m_polyBits = STATIC_POLY_BITS;    //dtIlog2(dtNextPow2((unsigned int)params->maxPolys));
-	m_saltBits = STATIC_SALT_BITS;    //sizeof(dtPolyRef)*8 - m_tileBits - m_polyBits;
-	//if (m_saltBits < SALT_MIN_BITS)
-		//return DT_FAILURE;
-	
+	m_tileBits = STATIC_TILE_BITS;
+	m_polyBits = STATIC_POLY_BITS;
+	m_saltBits = STATIC_SALT_BITS;
 	return DT_SUCCESS;
 }
 
@@ -212,9 +242,9 @@
 	// Make sure the data is in right format.
 	dtMeshHeader* header = (dtMeshHeader*)data;
 	if (header->magic != DT_NAVMESH_MAGIC)
-		return DT_FAILURE;
+		return DT_FAILURE | DT_WRONG_MAGIC;
 	if (header->version != DT_NAVMESH_VERSION)
-		return DT_FAILURE;
+		return DT_FAILURE | DT_WRONG_VERSION;
 
 	dtNavMeshParams params;
 	dtVcopy(params.orig, header->bmin);
@@ -222,14 +252,18 @@
 	params.tileHeight = header->bmax[2] - header->bmin[2];
 	params.maxTiles = 1;
 	params.maxPolys = header->polyCount;
-	
-	dtStatus res = init(&params);
-	if (res != DT_SUCCESS)
-		return res;
 
+	dtStatus status = init(&params);
+	if (dtStatusFailed(status))
+		return status;
+
 	return addTile(data, dataSize, flags, 0, 0);
 }
 
+/// @par
+///
+/// @note The parameters are created automatically when the single tile
+/// initialization is performed.
 const dtNavMeshParams* dtNavMesh::getParams() const
 {
 	return &m_params;
@@ -241,17 +275,18 @@
 								   dtPolyRef* con, float* conarea, int maxcon) const
 {
 	if (!tile) return 0;
-	
+
 	float amin[2], amax[2];
 	calcSlabEndPoints(va,vb, amin,amax, side);
+	const float apos = getSlabCoord(va, side);
 
 	// Remove links pointing to 'side' and compact the links array. 
 	float bmin[2], bmax[2];
 	unsigned short m = DT_EXT_LINK | (unsigned short)side;
 	int n = 0;
-	
+
 	dtPolyRef base = getPolyRefBase(tile);
-	
+
 	for (int i = 0; i < tile->header->polyCount; ++i)
 	{
 		dtPoly* poly = &tile->polys[i];
@@ -260,13 +295,20 @@
 		{
 			// Skip edges which do not point to the right side.
 			if (poly->neis[j] != m) continue;
-			// Check if the segments touch.
+
 			const float* vc = &tile->verts[poly->verts[j]*3];
 			const float* vd = &tile->verts[poly->verts[(j+1) % nv]*3];
+			const float bpos = getSlabCoord(vc, side);
+
+			// Segments are not close enough.
+			if (dtAbs(apos-bpos) > 0.01f)
+				continue;
+
+			// Check if the segments touch.
 			calcSlabEndPoints(vc,vd, bmin,bmax, side);
 
 			if (!overlapSlabs(amin,amax, bmin,bmax, 0.01f, tile->header->walkableClimb)) continue;
-			
+
 			// Add return value.
 			if (n < maxcon)
 			{
@@ -281,10 +323,12 @@
 	return n;
 }
 
-void dtNavMesh::unconnectExtLinks(dtMeshTile* tile, int side)
+void dtNavMesh::unconnectExtLinks(dtMeshTile* tile, dtMeshTile* target)
 {
-	if (!tile) return;
+	if (!tile || !target) return;
 
+	const unsigned int targetNum = decodePolyIdTile(getTileRef(target));
+
 	for (int i = 0; i < tile->header->polyCount; ++i)
 	{
 		dtPoly* poly = &tile->polys[i];
@@ -292,7 +336,8 @@
 		unsigned int pj = DT_NULL_LINK;
 		while (j != DT_NULL_LINK)
 		{
-			if (tile->links[j].side == side)
+			if (tile->links[j].side != 0xff &&
+				decodePolyIdTile(tile->links[j].ref) == targetNum)
 			{
 				// Revove link.
 				unsigned int nj = tile->links[j].next;
@@ -316,26 +361,32 @@
 void dtNavMesh::connectExtLinks(dtMeshTile* tile, dtMeshTile* target, int side)
 {
 	if (!tile) return;
-	
+
 	// Connect border links.
 	for (int i = 0; i < tile->header->polyCount; ++i)
 	{
 		dtPoly* poly = &tile->polys[i];
 
 		// Create new links.
-		unsigned short m = DT_EXT_LINK | (unsigned short)side;
+//		unsigned short m = DT_EXT_LINK | (unsigned short)side;
+
 		const int nv = poly->vertCount;
 		for (int j = 0; j < nv; ++j)
 		{
-			// Skip edges which do not point to the right side.
-			if (poly->neis[j] != m) continue;
-			
+			// Skip non-portal edges.
+			if ((poly->neis[j] & DT_EXT_LINK) == 0)
+				continue;
+
+			const int dir = (int)(poly->neis[j] & 0xff);
+			if (side != -1 && dir != side)
+				continue;
+
 			// Create new links
 			const float* va = &tile->verts[poly->verts[j]*3];
 			const float* vb = &tile->verts[poly->verts[(j+1) % nv]*3];
 			dtPolyRef nei[4];
 			float neia[4*2];
-			int nnei = findConnectingPolys(va,vb, target, dtOppositeTile(side), nei,neia,4);
+			int nnei = findConnectingPolys(va,vb, target, dtOppositeTile(dir), nei,neia,4);
 			for (int k = 0; k < nnei; ++k)
 			{
 				unsigned int idx = allocLink(tile);
@@ -344,13 +395,13 @@
 					dtLink* link = &tile->links[idx];
 					link->ref = nei[k];
 					link->edge = (unsigned char)j;
-					link->side = (unsigned char)side;
-					
+					link->side = (unsigned char)dir;
+
 					link->next = poly->firstLink;
 					poly->firstLink = idx;
 
 					// Compress portal limits to a byte value.
-					if (side == 0 || side == 4)
+					if (dir == 0 || dir == 4)
 					{
 						float tmin = (neia[k*2+0]-va[2]) / (vb[2]-va[2]);
 						float tmax = (neia[k*2+1]-va[2]) / (vb[2]-va[2]);
@@ -359,7 +410,7 @@
 						link->bmin = (unsigned char)(dtClamp(tmin, 0.0f, 1.0f)*255.0f);
 						link->bmax = (unsigned char)(dtClamp(tmax, 0.0f, 1.0f)*255.0f);
 					}
-					else if (side == 2 || side == 6)
+					else if (dir == 2 || dir == 6)
 					{
 						float tmin = (neia[k*2+0]-va[0]) / (vb[0]-va[0]);
 						float tmax = (neia[k*2+1]-va[0]) / (vb[0]-va[0]);
@@ -377,21 +428,21 @@
 void dtNavMesh::connectExtOffMeshLinks(dtMeshTile* tile, dtMeshTile* target, int side)
 {
 	if (!tile) return;
-	
+
 	// Connect off-mesh links.
 	// We are interested on links which land from target tile to this tile.
 	const unsigned char oppositeSide = (unsigned char)dtOppositeTile(side);
-	
+
 	for (int i = 0; i < target->header->offMeshConCount; ++i)
 	{
 		dtOffMeshConnection* targetCon = &target->offMeshCons[i];
 		if (targetCon->side != oppositeSide)
 			continue;
-		
+
 		dtPoly* targetPoly = &target->polys[targetCon->poly];
-		
+
 		const float ext[3] = { targetCon->rad, target->header->walkableClimb, targetCon->rad };
-		
+
 		// Find polygon to connect to.
 		const float* p = &targetCon->pos[3];
 		float nearestPt[3];
@@ -403,7 +454,7 @@
 		// Make sure the location is on current mesh.
 		float* v = &target->verts[targetPoly->verts[1]*3];
 		dtVcopy(v, nearestPt);
-				
+
 		// Link off-mesh connection to target poly.
 		unsigned int idx = allocLink(target);
 		if (idx != DT_NULL_LINK)
@@ -417,7 +468,7 @@
 			link->next = targetPoly->firstLink;
 			targetPoly->firstLink = idx;
 		}
-		
+
 		// Link target poly to off-mesh connection.
 		if (targetCon->flags & DT_OFFMESH_CON_BIDIR)
 		{
@@ -453,7 +504,7 @@
 
 		if (poly->getType() == DT_POLYTYPE_OFFMESH_CONNECTION)
 			continue;
-			
+
 		// Build edge links backwards so that the links will be
 		// in the linked list from lowest index to highest.
 		for (int j = poly->vertCount-1; j >= 0; --j)
@@ -473,24 +524,24 @@
 				link->next = poly->firstLink;
 				poly->firstLink = idx;
 			}
-		}			
+		}
 	}
 }
 
 void dtNavMesh::connectIntOffMeshLinks(dtMeshTile* tile)
 {
 	if (!tile) return;
-	
+
 	dtPolyRef base = getPolyRefBase(tile);
-	
+
 	// Find Off-mesh connection end points.
 	for (int i = 0; i < tile->header->offMeshConCount; ++i)
 	{
 		dtOffMeshConnection* con = &tile->offMeshCons[i];
 		dtPoly* poly = &tile->polys[con->poly];
-	
+
 		const float ext[3] = { con->rad, tile->header->walkableClimb, con->rad };
-		
+
 		for (int j = 0; j < 2; ++j)
 		{
 			unsigned char side = j == 0 ? 0xff : con->side;
@@ -543,19 +594,20 @@
 						landPoly->firstLink = idx;
 					}
 				}
-				
+
 			}
 		}
 	}
 }
 
-dtStatus dtNavMesh::closestPointOnPolyInTile(const dtMeshTile* tile, unsigned int ip, const float* pos, float* closest)
+void dtNavMesh::closestPointOnPolyInTile(const dtMeshTile* tile, unsigned int ip,
+										 const float* pos, float* closest) const
 {
 	const dtPoly* poly = &tile->polys[ip];
-	
+
 	float closestDistSqr = FLT_MAX;
 	const dtPolyDetail* pd = &tile->detailMeshes[ip];
-	
+
 	for (int j = 0; j < pd->triCount; ++j)
 	{
 		const unsigned char* t = &tile->detailTris[(pd->triBase+j)*4];
@@ -576,20 +628,20 @@
 			closestDistSqr = d;
 		}
 	}
-	
-	return DT_SUCCESS;
 }
 
-dtPolyRef dtNavMesh::findNearestPolyInTile(const dtMeshTile* tile, const float* center, const float* extents, float* nearestPt)
+dtPolyRef dtNavMesh::findNearestPolyInTile(const dtMeshTile* tile,
+										   const float* center, const float* extents,
+										   float* nearestPt) const
 {
 	float bmin[3], bmax[3];
 	dtVsub(bmin, center, extents);
 	dtVadd(bmax, center, extents);
-	
+
 	// Get nearby polygons from proximity grid.
 	dtPolyRef polys[128];
 	int polyCount = queryPolygonsInTile(tile, bmin, bmax, polys, 128);
-	
+
 	// Find nearest polygon amongst the nearby polygons.
 	dtPolyRef nearest = 0;
 	float nearestDistanceSqr = FLT_MAX;
@@ -597,8 +649,7 @@
 	{
 		dtPolyRef ref = polys[i];
 		float closestPtPoly[3];
-		if (closestPointOnPolyInTile(tile, decodePolyIdPoly(ref), center, closestPtPoly) != DT_SUCCESS)
-			continue;
+		closestPointOnPolyInTile(tile, decodePolyIdPoly(ref), center, closestPtPoly);
 		float d = dtVdistSqr(center, closestPtPoly);
 		if (d < nearestDistanceSqr)
 		{
@@ -608,11 +659,12 @@
 			nearest = ref;
 		}
 	}
-	
+
 	return nearest;
 }
 
-int dtNavMesh::queryPolygonsInTile(const dtMeshTile* tile, const float* qmin, const float* qmax, dtPolyRef* polys, const int maxPolys)
+int dtNavMesh::queryPolygonsInTile(const dtMeshTile* tile, const float* qmin, const float* qmax,
+								   dtPolyRef* polys, const int maxPolys) const
 {
 	if (tile->bvTree)
 	{
@@ -621,7 +673,7 @@
 		const float* tbmin = tile->header->bmin;
 		const float* tbmax = tile->header->bmax;
 		const float qfac = tile->header->bvQuantFactor;
-		
+
 		// Calculate quantized box
 		unsigned short bmin[3], bmax[3];
 		// dtClamp query box to world box.
@@ -638,7 +690,7 @@
 		bmax[0] = (unsigned short)(qfac * maxx + 1) | 1;
 		bmax[1] = (unsigned short)(qfac * maxy + 1) | 1;
 		bmax[2] = (unsigned short)(qfac * maxz + 1) | 1;
-		
+
 		// Traverse tree
 		dtPolyRef base = getPolyRefBase(tile);
 		int n = 0;
@@ -646,13 +698,13 @@
 		{
 			const bool overlap = dtOverlapQuantBounds(bmin, bmax, node->bmin, node->bmax);
 			const bool isLeafNode = node->i >= 0;
-			
+
 			if (isLeafNode && overlap)
 			{
 				if (n < maxPolys)
 					polys[n++] = base | (dtPolyRef)node->i;
 			}
-			
+
 			if (overlap || isLeafNode)
 				node++;
 			else
@@ -661,7 +713,7 @@
 				node += escapeIndex;
 			}
 		}
-		
+
 		return n;
 	}
 	else
@@ -692,19 +744,30 @@
 	}
 }
 
+/// @par
+///
+/// The add operation will fail if the data is in the wrong format, the allocated tile
+/// space is full, or there is a tile already at the specified reference.
+///
+/// The lastRef parameter is used to restore a tile with the same tile
+/// reference it had previously used.  In this case the #dtPolyRef's for the
+/// tile will be restored to the same values they were before the tile was 
+/// removed.
+///
+/// @see dtCreateNavMeshData, #removeTile
 dtStatus dtNavMesh::addTile(unsigned char* data, int dataSize, int flags,
 							dtTileRef lastRef, dtTileRef* result)
 {
 	// Make sure the data is in right format.
 	dtMeshHeader* header = (dtMeshHeader*)data;
 	if (header->magic != DT_NAVMESH_MAGIC)
-		return DT_FAILURE_DATA_MAGIC;
+		return DT_FAILURE | DT_WRONG_MAGIC;
 	if (header->version != DT_NAVMESH_VERSION)
-		return DT_FAILURE_DATA_VERSION;
+		return DT_FAILURE | DT_WRONG_VERSION;
 
 	// Make sure the location is free.
-	if (getTileAt(header->x, header->y))
-		return DT_IN_PROGRESS;
+	if((*result) = getTileRefAt(header->x, header->y, header->layer))
+		return DT_FAILURE | DT_IN_PROGRESS;
 
 	// Allocate a tile.
 	dtMeshTile* tile = 0;
@@ -722,7 +785,7 @@
 		// Try to relocate the tile to specific index with same salt.
 		int tileIndex = (int)decodePolyIdTile((dtPolyRef)lastRef);
 		if (tileIndex >= m_maxTiles)
-			return DT_FAILURE_OUT_OF_MEMORY;
+			return DT_FAILURE | DT_OUT_OF_MEMORY;
 		// Try to find the specific tile id from the free list.
 		dtMeshTile* target = &m_tiles[tileIndex];
 		dtMeshTile* prev = 0;
@@ -734,7 +797,7 @@
 		}
 		// Could not find the correct location.
 		if (tile != target)
-			return DT_FAILURE_OUT_OF_MEMORY;
+			return DT_FAILURE | DT_OUT_OF_MEMORY;
 		// Remove from freelist
 		if (!prev)
 			m_nextFree = tile->next;
@@ -747,7 +810,7 @@
 
 	// Make sure we could allocate a tile.
 	if (!tile)
-		return DT_FAILURE_OUT_OF_MEMORY;
+		return DT_FAILURE | DT_OUT_OF_MEMORY;
 
 	// Insert tile into the position lut.
 	int h = computeTileHash(header->x, header->y, m_tileLutMask);
@@ -764,7 +827,7 @@
 	const int detailTrisSize = dtAlign4(sizeof(unsigned char)*4*header->detailTriCount);
 	const int bvtreeSize = dtAlign4(sizeof(dtBVNode)*header->bvNodeCount);
 	const int offMeshLinksSize = dtAlign4(sizeof(dtOffMeshConnection)*header->offMeshConCount);
-	
+
 	unsigned char* d = data + headerSize;
 	tile->verts = (float*)d; d += vertsSize;
 	tile->polys = (dtPoly*)d; d += polysSize;
@@ -775,6 +838,10 @@
 	tile->bvTree = (dtBVNode*)d; d += bvtreeSize;
 	tile->offMeshCons = (dtOffMeshConnection*)d; d += offMeshLinksSize;
 
+	// If there are no items in the bvtree, reset the tree pointer.
+	if (!bvtreeSize)
+		tile->bvTree = 0;
+
 	// Build links freelist
 	tile->linksFreeList = 0;
 	tile->links[header->maxLinkCount-1].next = DT_NULL_LINK;
@@ -790,74 +857,140 @@
 	connectIntLinks(tile);
 	connectIntOffMeshLinks(tile);
 
-	// Create connections connections.
+	// Create connections with neighbour tiles.
+	dtMeshTile* neis[MAX_NEIS];
+	int nneis;
+
+	// Connect with layers in current tile.
+	nneis = getTilesAt(header->x, header->y, neis, MAX_NEIS);
+	for (int j = 0; j < nneis; ++j)
+	{
+		if (neis[j] == tile) continue;
+		connectExtLinks(tile, neis[j], -1);
+		connectExtLinks(neis[j], tile, -1);
+		connectExtOffMeshLinks(tile, neis[j], -1);
+		connectExtOffMeshLinks(neis[j], tile, -1);
+	}
+
+	// Connect with neighbour tiles.
 	for (int i = 0; i < 8; ++i)
 	{
-		dtMeshTile* nei = getNeighbourTileAt(header->x, header->y, i);
-		if (nei)
+		nneis = getNeighbourTilesAt(header->x, header->y, i, neis, MAX_NEIS);
+		for (int j = 0; j < nneis; ++j)
 		{
-			connectExtLinks(tile, nei, i);
-			connectExtLinks(nei, tile, dtOppositeTile(i));
-			connectExtOffMeshLinks(tile, nei, i);
-			connectExtOffMeshLinks(nei, tile, dtOppositeTile(i));
+			connectExtLinks(tile, neis[j], i);
+			connectExtLinks(neis[j], tile, dtOppositeTile(i));
+			connectExtOffMeshLinks(tile, neis[j], i);
+			connectExtOffMeshLinks(neis[j], tile, dtOppositeTile(i));
 		}
 	}
 
-	if(result)
+	if (result)
 		*result = getTileRef(tile);
 
 	return DT_SUCCESS;
 }
 
-const dtMeshTile* dtNavMesh::getTileAt(int x, int y) const
+const dtMeshTile* dtNavMesh::getTileAt(const int x, const int y, const int layer) const
 {
 	// Find tile based on hash.
 	int h = computeTileHash(x,y,m_tileLutMask);
 	dtMeshTile* tile = m_posLookup[h];
 	while (tile)
 	{
-		if (tile->header && tile->header->x == x && tile->header->y == y)
+		if (tile->header &&
+			tile->header->x == x &&
+			tile->header->y == y &&
+			tile->header->layer == layer)
+		{
 			return tile;
+		}
 		tile = tile->next;
 	}
 	return 0;
 }
 
-dtMeshTile* dtNavMesh::getNeighbourTileAt(int x, int y, int side) const
+int dtNavMesh::getNeighbourTilesAt(const int x, const int y, const int side, dtMeshTile** tiles, const int maxTiles) const
 {
+	int nx = x, ny = y;
 	switch (side)
 	{
-		case 0: x++; break;
-		case 1: x++; y++; break;
-		case 2: y++; break;
-		case 3: x--; y++; break;
-		case 4: x--; break;
-		case 5: x--; y--; break;
-		case 6: y--; break;
-		case 7: x++; y--; break;
+		case 0: nx++; break;
+		case 1: nx++; ny++; break;
+		case 2: ny++; break;
+		case 3: nx--; ny++; break;
+		case 4: nx--; break;
+		case 5: nx--; ny--; break;
+		case 6: ny--; break;
+		case 7: nx++; ny--; break;
 	};
 
+	return getTilesAt(nx, ny, tiles, maxTiles);
+}
+
+int dtNavMesh::getTilesAt(const int x, const int y, dtMeshTile** tiles, const int maxTiles) const
+{
+	int n = 0;
+
 	// Find tile based on hash.
 	int h = computeTileHash(x,y,m_tileLutMask);
 	dtMeshTile* tile = m_posLookup[h];
 	while (tile)
 	{
-		if (tile->header && tile->header->x == x && tile->header->y == y)
-			return tile;
+		if (tile->header &&
+			tile->header->x == x &&
+			tile->header->y == y)
+		{
+			if (n < maxTiles)
+				tiles[n++] = tile;
+		}
 		tile = tile->next;
 	}
-	return 0;
+
+	return n;
 }
 
-dtTileRef dtNavMesh::getTileRefAt(int x, int y) const
+/// @par
+///
+/// This function will not fail if the tiles array is too small to hold the
+/// entire result set.  It will simply fill the array to capacity.
+int dtNavMesh::getTilesAt(const int x, const int y, dtMeshTile const** tiles, const int maxTiles) const
 {
+	int n = 0;
+
 	// Find tile based on hash.
 	int h = computeTileHash(x,y,m_tileLutMask);
 	dtMeshTile* tile = m_posLookup[h];
 	while (tile)
 	{
-		if (tile->header && tile->header->x == x && tile->header->y == y)
+		if (tile->header &&
+			tile->header->x == x &&
+			tile->header->y == y)
+		{
+			if (n < maxTiles)
+				tiles[n++] = tile;
+		}
+		tile = tile->next;
+	}
+
+	return n;
+}
+
+
+dtTileRef dtNavMesh::getTileRefAt(const int x, const int y, const int layer) const
+{
+	// Find tile based on hash.
+	int h = computeTileHash(x,y,m_tileLutMask);
+	dtMeshTile* tile = m_posLookup[h];
+	while (tile)
+	{
+		if (tile->header &&
+			tile->header->x == x &&
+			tile->header->y == y &&
+			tile->header->layer == layer)
+		{
 			return getTileRef(tile);
+		}
 		tile = tile->next;
 	}
 	return 0;
@@ -900,16 +1033,22 @@
 
 dtStatus dtNavMesh::getTileAndPolyByRef(const dtPolyRef ref, const dtMeshTile** tile, const dtPoly** poly) const
 {
+	if (!ref) return DT_FAILURE;
 	unsigned int salt, it, ip;
 	decodePolyId(ref, salt, it, ip);
-	if (it >= (unsigned int)m_maxTiles) return DT_FAILURE;
-	if (m_tiles[it].salt != salt || m_tiles[it].header == 0) return DT_FAILURE;
-	if (ip >= (unsigned int)m_tiles[it].header->polyCount) return DT_FAILURE;
+	if (it >= (unsigned int)m_maxTiles) return DT_FAILURE | DT_INVALID_PARAM;
+	if (m_tiles[it].salt != salt || m_tiles[it].header == 0) return DT_FAILURE | DT_INVALID_PARAM;
+	if (ip >= (unsigned int)m_tiles[it].header->polyCount) return DT_FAILURE | DT_INVALID_PARAM;
 	*tile = &m_tiles[it];
 	*poly = &m_tiles[it].polys[ip];
 	return DT_SUCCESS;
 }
 
+/// @par
+///
+/// @warning Only use this function if it is known that the provided polygon
+/// reference is valid. This function is faster than #getTileAndPolyByRef, but
+/// it does not validate the reference.
 void dtNavMesh::getTileAndPolyByRefUnsafe(const dtPolyRef ref, const dtMeshTile** tile, const dtPoly** poly) const
 {
 	unsigned int salt, it, ip;
@@ -920,6 +1059,7 @@
 
 bool dtNavMesh::isValidPolyRef(dtPolyRef ref) const
 {
+	if (!ref) return false;
 	unsigned int salt, it, ip;
 	decodePolyId(ref, salt, it, ip);
 	if (it >= (unsigned int)m_maxTiles) return false;
@@ -928,18 +1068,25 @@
 	return true;
 }
 
+/// @par
+///
+/// This function returns the data for the tile so that, if desired,
+/// it can be added back to the navigation mesh at a later point.
+///
+/// @see #addTile
 dtStatus dtNavMesh::removeTile(dtTileRef ref, unsigned char** data, int* dataSize)
 {
 	if (!ref)
-		return DT_FAILURE;
+		return DT_FAILURE | DT_INVALID_PARAM;
+
 	unsigned int tileIndex = decodePolyIdTile((dtPolyRef)ref);
 	unsigned int tileSalt = decodePolyIdSalt((dtPolyRef)ref);
 	if ((int)tileIndex >= m_maxTiles)
-		return DT_FAILURE;
+		return DT_FAILURE | DT_INVALID_PARAM;
 
 	dtMeshTile* tile = &m_tiles[tileIndex];
 	if (tile->salt != tileSalt)
-		return DT_FAILURE;
+		return DT_FAILURE | DT_INVALID_PARAM;
 
 	// Remove tile from hash lookup.
 	int h = computeTileHash(tile->header->x,tile->header->y,m_tileLutMask);
@@ -958,16 +1105,28 @@
 		prev = cur;
 		cur = cur->next;
 	}
-	
-	// Remove connections to neighbour tiles.
+
+	//// Remove connections to neighbour tiles.
+	// Create connections with neighbour tiles.
+	dtMeshTile* neis[MAX_NEIS];
+	int nneis;
+
+	// Connect with layers in current tile.
+	nneis = getTilesAt(tile->header->x, tile->header->y, neis, MAX_NEIS);
+	for (int j = 0; j < nneis; ++j)
+	{
+		if (neis[j] == tile) continue;
+		unconnectExtLinks(neis[j], tile);
+	}
+
+	// Connect with neighbour tiles.
 	for (int i = 0; i < 8; ++i)
 	{
-		dtMeshTile* nei = getNeighbourTileAt(tile->header->x,tile->header->y,i);
-		if (!nei) continue;
-		unconnectExtLinks(nei, dtOppositeTile(i));
+		nneis = getNeighbourTilesAt(tile->header->x, tile->header->y, i, neis, MAX_NEIS);
+		for (int j = 0; j < nneis; ++j)
+			unconnectExtLinks(neis[j], tile);
 	}
-	
-	
+
 	// Reset tile.
 	if (tile->flags & DT_TILE_FREE_DATA)
 	{
@@ -1010,12 +1169,25 @@
 
 dtTileRef dtNavMesh::getTileRef(const dtMeshTile* tile) const
 {
-	if (!tile)
-		return 0;
+	if (!tile) return 0;
 	const unsigned int it = tile - m_tiles;
 	return (dtTileRef)encodePolyId(tile->salt, it, 0);
 }
 
+/// @par
+///
+/// Example use case:
+/// @code
+///
+/// const dtPolyRef base = navmesh->getPolyRefBase(tile);
+/// for (int i = 0; i < tile->header->polyCount; ++i)
+/// {
+///     const dtPoly* p = &tile->polys[i];
+///     const dtPolyRef ref = base | (dtPolyRef)i;
+///     
+///     // Use the reference to access the polygon data.
+/// }
+/// @endcode
 dtPolyRef dtNavMesh::getPolyRefBase(const dtMeshTile* tile) const
 {
 	if (!tile) return 0;
@@ -1036,6 +1208,7 @@
 	unsigned char area;							// Area ID of the polygon.
 };
 
+///  @see #storeTileState
 int dtNavMesh::getTileStateSize(const dtMeshTile* tile) const
 {
 	if (!tile) return 0;
@@ -1044,21 +1217,26 @@
 	return headerSize + polyStateSize;
 }
 
+/// @par
+///
+/// Tile state includes non-structural data such as polygon flags, area ids, etc.
+/// @note The state data is only valid until the tile reference changes.
+/// @see #getTileStateSize, #restoreTileState
 dtStatus dtNavMesh::storeTileState(const dtMeshTile* tile, unsigned char* data, const int maxDataSize) const
 {
 	// Make sure there is enough space to store the state.
 	const int sizeReq = getTileStateSize(tile);
 	if (maxDataSize < sizeReq)
-		return DT_FAILURE;
-		
+		return DT_FAILURE | DT_BUFFER_TOO_SMALL;
+
 	dtTileState* tileState = (dtTileState*)data; data += dtAlign4(sizeof(dtTileState));
 	dtPolyState* polyStates = (dtPolyState*)data; data += dtAlign4(sizeof(dtPolyState) * tile->header->polyCount);
-	
+
 	// Store tile state.
 	tileState->magic = DT_NAVMESH_STATE_MAGIC;
 	tileState->version = DT_NAVMESH_STATE_VERSION;
 	tileState->ref = getTileRef(tile);
-	
+
 	// Store per poly state.
 	for (int i = 0; i < tile->header->polyCount; ++i)
 	{
@@ -1067,28 +1245,33 @@
 		s->flags = p->flags;
 		s->area = p->getArea();
 	}
-	
+
 	return DT_SUCCESS;
 }
 
+/// @par
+///
+/// Tile state includes non-structural data such as polygon flags, area ids, etc.
+/// @note This function does not impact the tile's #dtTileRef and #dtPolyRef's.
+/// @see #storeTileState
 dtStatus dtNavMesh::restoreTileState(dtMeshTile* tile, const unsigned char* data, const int maxDataSize)
 {
 	// Make sure there is enough space to store the state.
 	const int sizeReq = getTileStateSize(tile);
 	if (maxDataSize < sizeReq)
-		return DT_FAILURE;
-	
+		return DT_FAILURE | DT_INVALID_PARAM;
+
 	const dtTileState* tileState = (const dtTileState*)data; data += dtAlign4(sizeof(dtTileState));
 	const dtPolyState* polyStates = (const dtPolyState*)data; data += dtAlign4(sizeof(dtPolyState) * tile->header->polyCount);
-	
+
 	// Check that the restore is possible.
 	if (tileState->magic != DT_NAVMESH_STATE_MAGIC)
-		return DT_FAILURE_DATA_MAGIC;
+		return DT_FAILURE | DT_WRONG_MAGIC;
 	if (tileState->version != DT_NAVMESH_STATE_VERSION)
-		return DT_FAILURE_DATA_VERSION;
+		return DT_FAILURE | DT_WRONG_VERSION;
 	if (tileState->ref != getTileRef(tile))
-		return DT_FAILURE;
-	
+		return DT_FAILURE | DT_INVALID_PARAM;
+
 	// Restore per poly state.
 	for (int i = 0; i < tile->header->polyCount; ++i)
 	{
@@ -1097,21 +1280,30 @@
 		p->flags = s->flags;
 		p->setArea(s->area);
 	}
-	
+
 	return DT_SUCCESS;
 }
 
-// Returns start and end location of an off-mesh link polygon.
+/// @par
+///
+/// Off-mesh connections are stored in the navigation mesh as special 2-vertex 
+/// polygons with a single edge. At least one of the vertices is expected to be 
+/// inside a normal polygon. So an off-mesh connection is "entered" from a 
+/// normal polygon at one of its endpoints. This is the polygon identified by 
+/// the prevRef parameter.
 dtStatus dtNavMesh::getOffMeshConnectionPolyEndPoints(dtPolyRef prevRef, dtPolyRef polyRef, float* startPos, float* endPos) const
 {
 	unsigned int salt, it, ip;
 
+	if (!polyRef)
+		return DT_FAILURE;
+
 	// Get current polygon
 	decodePolyId(polyRef, salt, it, ip);
-	if (it >= (unsigned int)m_maxTiles) return DT_FAILURE;
-	if (m_tiles[it].salt != salt || m_tiles[it].header == 0) return DT_FAILURE;
+	if (it >= (unsigned int)m_maxTiles) return DT_FAILURE | DT_INVALID_PARAM;
+	if (m_tiles[it].salt != salt || m_tiles[it].header == 0) return DT_FAILURE | DT_INVALID_PARAM;
 	const dtMeshTile* tile = &m_tiles[it];
-	if (ip >= (unsigned int)tile->header->polyCount) return DT_FAILURE;
+	if (ip >= (unsigned int)tile->header->polyCount) return DT_FAILURE | DT_INVALID_PARAM;
 	const dtPoly* poly = &tile->polys[ip];
 
 	// Make sure that the current poly is indeed off-mesh link.
@@ -1120,7 +1312,7 @@
 
 	// Figure out which way to hand out the vertices.
 	int idx0 = 0, idx1 = 1;
-	
+
 	// Find link that points to first vertex.
 	for (unsigned int i = poly->firstLink; i != DT_NULL_LINK; i = tile->links[i].next)
 	{
@@ -1134,7 +1326,7 @@
 			break;
 		}
 	}
-	
+
 	dtVcopy(startPos, &tile->verts[poly->verts[idx0]*3]);
 	dtVcopy(endPos, &tile->verts[poly->verts[idx1]*3]);
 
@@ -1145,7 +1337,10 @@
 const dtOffMeshConnection* dtNavMesh::getOffMeshConnectionByRef(dtPolyRef ref) const
 {
 	unsigned int salt, it, ip;
-	
+
+	if (!ref)
+		return 0;
+
 	// Get current polygon
 	decodePolyId(ref, salt, it, ip);
 	if (it >= (unsigned int)m_maxTiles) return 0;
@@ -1153,7 +1348,7 @@
 	const dtMeshTile* tile = &m_tiles[it];
 	if (ip >= (unsigned int)tile->header->polyCount) return 0;
 	const dtPoly* poly = &tile->polys[ip];
-	
+
 	// Make sure that the current poly is indeed off-mesh link.
 	if (poly->getType() != DT_POLYTYPE_OFFMESH_CONNECTION)
 		return 0;
@@ -1166,62 +1361,66 @@
 
 dtStatus dtNavMesh::setPolyFlags(dtPolyRef ref, unsigned short flags)
 {
+	if (!ref) return DT_FAILURE;
 	unsigned int salt, it, ip;
 	decodePolyId(ref, salt, it, ip);
-	if (it >= (unsigned int)m_maxTiles) return DT_FAILURE;
-	if (m_tiles[it].salt != salt || m_tiles[it].header == 0) return DT_FAILURE;
+	if (it >= (unsigned int)m_maxTiles) return DT_FAILURE | DT_INVALID_PARAM;
+	if (m_tiles[it].salt != salt || m_tiles[it].header == 0) return DT_FAILURE | DT_INVALID_PARAM;
 	dtMeshTile* tile = &m_tiles[it];
-	if (ip >= (unsigned int)tile->header->polyCount) return DT_FAILURE;
+	if (ip >= (unsigned int)tile->header->polyCount) return DT_FAILURE | DT_INVALID_PARAM;
 	dtPoly* poly = &tile->polys[ip];
-	
+
 	// Change flags.
 	poly->flags = flags;
-	
+
 	return DT_SUCCESS;
 }
 
 dtStatus dtNavMesh::getPolyFlags(dtPolyRef ref, unsigned short* resultFlags) const
 {
+	if (!ref) return DT_FAILURE;
 	unsigned int salt, it, ip;
 	decodePolyId(ref, salt, it, ip);
-	if (it >= (unsigned int)m_maxTiles) return DT_FAILURE;
-	if (m_tiles[it].salt != salt || m_tiles[it].header == 0) return DT_FAILURE;
+	if (it >= (unsigned int)m_maxTiles) return DT_FAILURE | DT_INVALID_PARAM;
+	if (m_tiles[it].salt != salt || m_tiles[it].header == 0) return DT_FAILURE | DT_INVALID_PARAM;
 	const dtMeshTile* tile = &m_tiles[it];
-	if (ip >= (unsigned int)tile->header->polyCount) return DT_FAILURE;
+	if (ip >= (unsigned int)tile->header->polyCount) return DT_FAILURE | DT_INVALID_PARAM;
 	const dtPoly* poly = &tile->polys[ip];
 
 	*resultFlags = poly->flags;
-	
+
 	return DT_SUCCESS;
 }
 
 dtStatus dtNavMesh::setPolyArea(dtPolyRef ref, unsigned char area)
 {
+	if (!ref) return DT_FAILURE;
 	unsigned int salt, it, ip;
 	decodePolyId(ref, salt, it, ip);
-	if (it >= (unsigned int)m_maxTiles) return DT_FAILURE;
-	if (m_tiles[it].salt != salt || m_tiles[it].header == 0) return DT_FAILURE;
+	if (it >= (unsigned int)m_maxTiles) return DT_FAILURE | DT_INVALID_PARAM;
+	if (m_tiles[it].salt != salt || m_tiles[it].header == 0) return DT_FAILURE | DT_INVALID_PARAM;
 	dtMeshTile* tile = &m_tiles[it];
-	if (ip >= (unsigned int)tile->header->polyCount) return DT_FAILURE;
+	if (ip >= (unsigned int)tile->header->polyCount) return DT_FAILURE | DT_INVALID_PARAM;
 	dtPoly* poly = &tile->polys[ip];
-	
+
 	poly->setArea(area);
-	
+
 	return DT_SUCCESS;
 }
 
 dtStatus dtNavMesh::getPolyArea(dtPolyRef ref, unsigned char* resultArea) const
 {
+	if (!ref) return DT_FAILURE;
 	unsigned int salt, it, ip;
 	decodePolyId(ref, salt, it, ip);
-	if (it >= (unsigned int)m_maxTiles) return DT_FAILURE;
-	if (m_tiles[it].salt != salt || m_tiles[it].header == 0) return DT_FAILURE;
+	if (it >= (unsigned int)m_maxTiles) return DT_FAILURE | DT_INVALID_PARAM;
+	if (m_tiles[it].salt != salt || m_tiles[it].header == 0) return DT_FAILURE | DT_INVALID_PARAM;
 	const dtMeshTile* tile = &m_tiles[it];
-	if (ip >= (unsigned int)tile->header->polyCount) return DT_FAILURE;
+	if (ip >= (unsigned int)tile->header->polyCount) return DT_FAILURE | DT_INVALID_PARAM;
 	const dtPoly* poly = &tile->polys[ip];
-	
+
 	*resultArea = poly->getArea();
-	
+
 	return DT_SUCCESS;
 }
 
Index: src/hearthstone-shared/Pathfinding/Detour/DetourNavMesh.h
===================================================================
--- src/hearthstone-shared/Pathfinding/Detour/DetourNavMesh.h	(revision 1490)
+++ src/hearthstone-shared/Pathfinding/Detour/DetourNavMesh.h	(working copy)
@@ -20,322 +20,468 @@
 #define DETOURNAVMESH_H
 
 #include "../../Common.h"
+#include "DetourStatus.h"
 
-#ifdef WIN32
-    typedef unsigned __int64   uint64;
-#else
-#include <stdint.h>
-#ifndef uint64_t
-#ifdef __linux__
-#include <linux/types.h>
-#endif
-#endif
-    typedef uint64_t           uint64;
-#endif
-
 // Note: If you want to use 64-bit refs, change the types of both dtPolyRef & dtTileRef.
-// It is also recommended to change dtHashRef() to proper 64-bit hash too.
+// It is also recommended that you change dtHashRef() to a proper 64-bit hash.
 
-// Reference to navigation polygon.
-typedef uint64 dtPolyRef;
+/// A handle to a polygon within a navigation mesh tile.
+/// @ingroup detour
+typedef unsigned int dtPolyRef;
 
-// Reference to navigation mesh tile.
-typedef uint64 dtTileRef;
+/// A handle to a tile within a navigation mesh.
+/// @ingroup detour
+typedef unsigned int dtTileRef;
 
-// Maximum number of vertices per navigation polygon.
+/// The maximum number of vertices per navigation polygon.
+/// @ingroup detour
 static const int DT_VERTS_PER_POLYGON = 6;
 
-static const int DT_NAVMESH_MAGIC = 'D'<<24 | 'N'<<16 | 'A'<<8 | 'V'; //'DNAV';
-static const int DT_NAVMESH_VERSION = 6;
+/// The maximum number of connections with neighboring tiles.
+static const int MAX_NEIS = 32;
 
-static const int DT_NAVMESH_STATE_MAGIC = 'D'<<24 | 'N'<<16 | 'M'<<8 | 'S'; //'DNMS';
+/// @{
+/// @name Tile Serialization Constants
+/// These constants are used to detect whether a navigation tile's data
+/// and state format is compatible with the current build.
+///
+
+/// A magic number used to detect compatibility of navigation tile data.
+static const int DT_NAVMESH_MAGIC = 'D'<<24 | 'N'<<16 | 'A'<<8 | 'V';
+
+/// A version number used to detect compatibility of navigation tile data.
+static const int DT_NAVMESH_VERSION = 7;
+
+/// A magic number used to detect the compatibility of navigation tile states.
+static const int DT_NAVMESH_STATE_MAGIC = 'D'<<24 | 'N'<<16 | 'M'<<8 | 'S';
+
+/// A version number used to detect compatibility of navigation tile states.
 static const int DT_NAVMESH_STATE_VERSION = 1;
 
+/// @}
+
+/// A flag that indicates that an entity links to an external entity.
+/// (E.g. A polygon edge is a portal that links to another polygon.)
 static const unsigned short DT_EXT_LINK = 0x8000;
+
+/// A value that indicates the entity does not link to anything.
 static const unsigned int DT_NULL_LINK = 0xffffffff;
+
+/// A flag that indicates that an off-mesh connection can be traversed in both directions. (Is bi-directional.)
 static const unsigned int DT_OFFMESH_CON_BIDIR = 1;
 
+/// The maximum number of user defined area ids.
+/// @ingroup detour
 static const int DT_MAX_AREAS = 64;
 
+/// Static settings used by generator and tiles.
 static const int STATIC_SALT_BITS = 12;
 static const int STATIC_TILE_BITS = 21;
 static const int STATIC_POLY_BITS = 31;
-// we cannot have over 31 bits for either tile nor poly
-// without changing polyCount to use 64bits too.
+/// we cannot have over 31 bits for either tile nor poly
+/// without changing polyCount to use 64bits too.
 
-// Flags for addTile
+/// Tile flags used for various functions and fields.
+/// For an example, see dtNavMesh::addTile().
 enum dtTileFlags
 {
-	DT_TILE_FREE_DATA = 0x01,					// Navmesh owns the tile memory and should free it.
+	/// The navigation mesh owns the tile memory and is responsible for freeing it.
+	DT_TILE_FREE_DATA = 0x01,
 };
 
-// Flags returned by findStraightPath().
+/// Vertex flags returned by dtNavMeshQuery::findStraightPath.
 enum dtStraightPathFlags
 {
-	DT_STRAIGHTPATH_START = 0x01,				// The vertex is the start position.
-	DT_STRAIGHTPATH_END = 0x02,					// The vertex is the end position.
-	DT_STRAIGHTPATH_OFFMESH_CONNECTION = 0x04,	// The vertex is start of an off-mesh link.
+	DT_STRAIGHTPATH_START = 0x01,				///< The vertex is the start position in the path.
+	DT_STRAIGHTPATH_END = 0x02,					///< The vertex is the end position in the path.
+	DT_STRAIGHTPATH_OFFMESH_CONNECTION = 0x04,	///< The vertex is the start of an off-mesh connection.
 };
 
-// Flags describing polygon properties.
+/// Flags representing the type of a navigation mesh polygon.
 enum dtPolyTypes
 {
-	DT_POLYTYPE_GROUND = 0,						// Regular ground polygons.
-	DT_POLYTYPE_OFFMESH_CONNECTION = 1,			// Off-mesh connections.
+	/// The polygon is a standard convex polygon that is part of the surface of the mesh.
+	DT_POLYTYPE_GROUND = 0,
+	/// The polygon is an off-mesh connection consisting of two vertices.
+	DT_POLYTYPE_OFFMESH_CONNECTION = 1,
 };
 
-enum dtStatus
+
+/// Defines a polyogn within a dtMeshTile object.
+/// @ingroup detour
+struct dtPoly
 {
-	DT_FAILURE = 0,								// Operation failed.
-	DT_FAILURE_DATA_MAGIC,
-	DT_FAILURE_DATA_VERSION,
-	DT_FAILURE_OUT_OF_MEMORY,
-	DT_SUCCESS,									// Operation succeed.
-	DT_IN_PROGRESS,								// Operation still in progress.
-};
+	/// Index to first link in linked list. (Or #DT_NULL_LINK if there is no link.)
+	unsigned int firstLink;
 
+	/// The indices of the polygon's vertices.
+	/// The actual vertices are located in dtMeshTile::verts.
+	unsigned short verts[DT_VERTS_PER_POLYGON];
 
-// Structure describing the navigation polygon data.
-struct dtPoly
-{
-	unsigned int firstLink;						// Index to first link in linked list. 
-	unsigned short verts[DT_VERTS_PER_POLYGON];	// Indices to vertices of the poly.
-	unsigned short neis[DT_VERTS_PER_POLYGON];	// Refs to neighbours of the poly.
-	unsigned short flags;						// Flags (see dtPolyFlags).
-	unsigned char vertCount;					// Number of vertices.
-	unsigned char areaAndtype;					// Bit packed: Area ID of the polygon, and Polygon type, see dtPolyTypes..
+	/// Packed data representing neighbor polygons references and flags for each edge.
+	unsigned short neis[DT_VERTS_PER_POLYGON];
+
+	/// The user defined polygon flags.
+	unsigned short flags;
+
+	/// The number of vertices in the polygon.
+	unsigned char vertCount;
+
+	/// The bit packed area id and polygon type.
+	/// @note Use the structure's set and get methods to acess this value.
+	unsigned char areaAndtype;
+
+	/// Sets the user defined area id. [Limit: < #DT_MAX_AREAS]
 	inline void setArea(unsigned char a) { areaAndtype = (areaAndtype & 0xc0) | (a & 0x3f); }
+
+	/// Sets the polygon type. (See: #dtPolyTypes.)
 	inline void setType(unsigned char t) { areaAndtype = (areaAndtype & 0x3f) | (t << 6); }
+
+	/// Gets the user defined area id.
 	inline unsigned char getArea() const { return areaAndtype & 0x3f; }
+
+	/// Gets the polygon type. (See: #dtPolyTypes)
 	inline unsigned char getType() const { return areaAndtype >> 6; }
 };
 
-// Stucture describing polygon detail triangles.
+/// Defines the location of detail sub-mesh data within a dtMeshTile.
 struct dtPolyDetail
 {
-	unsigned int vertBase;						// Offset to detail vertex array.
-	unsigned int triBase;						// Offset to detail triangle array.
-	unsigned char vertCount;					// Number of vertices in the detail mesh.
-	unsigned char triCount;						// Number of triangles.
+	unsigned int vertBase;			///< The offset of the vertices in the dtMeshTile::detailVerts array.
+	unsigned int triBase;			///< The offset of the triangles in the dtMeshTile::detailTris array.
+	unsigned char vertCount;		///< The number of vertices in the sub-mesh.
+	unsigned char triCount;			///< The number of triangles in the sub-mesh.
 };
 
-// Stucture describing a link to another polygon.
+/// Defines a link between polygons.
+/// @note This structure is rarely if ever used by the end user.
+/// @see dtMeshTile
 struct dtLink
 {
-	dtPolyRef ref;							// Neighbour reference.
-	unsigned int next;						// Index to next link.
-	unsigned char edge;						// Index to polygon edge which owns this link. 
-	unsigned char side;						// If boundary link, defines on which side the link is.
-	unsigned char bmin, bmax;				// If boundary link, defines the sub edge area.
+	dtPolyRef ref;					///< Neighbour reference. (The neighbor that is linked to.)
+	unsigned int next;				///< Index of the next link.
+	unsigned char edge;				///< Index of the polygon edge that owns this link.
+	unsigned char side;				///< If a boundary link, defines on which side the link is.
+	unsigned char bmin;				///< If a boundary link, defines the minimum sub-edge area.
+	unsigned char bmax;				///< If a boundary link, defines the maximum sub-edge area.
 };
 
+/// Bounding volume node.
+/// @note This structure is rarely if ever used by the end user.
+/// @see dtMeshTile
 struct dtBVNode
 {
-	unsigned short bmin[3], bmax[3];		// BVnode bounds
-	int i;									// Index to item or if negative, escape index.
+	unsigned short bmin[3];			///< Minimum bounds of the node's AABB. [(x, y, z)]
+	unsigned short bmax[3];			///< Maximum bounds of the node's AABB. [(x, y, z)]
+	int i;							///< The node's index. (Negative for escape sequence.)
 };
 
+/// Defines an navigation mesh off-mesh connection within a dtMeshTile object.
+/// An off-mesh connection is a user defined traversable connection made up to two vertices.
 struct dtOffMeshConnection
 {
-	float pos[6];							// Both end point locations.
-	float rad;								// Link connection radius.
-	unsigned short poly;					// Poly Id
-	unsigned char flags;					// Link flags
-	unsigned char side;						// End point side.
-	unsigned int userId;					// User ID to identify this connection.
+	/// The endpoints of the connection. [(ax, ay, az, bx, by, bz)]
+	float pos[6];
+
+	/// The radius of the endpoints. [Limit: >= 0]
+	float rad;
+
+	/// The polygon reference of the connection within the tile.
+	unsigned short poly;
+
+	/// Link flags. 
+	/// @note These are not the connection's user defined flags. Those are assigned via the 
+	/// connection's dtPoly definition. These are link flags used for internal purposes.
+	unsigned char flags;
+
+	/// End point side.
+	unsigned char side;
+
+	/// The id of the offmesh connection. (User assigned when the navigation mesh is built.)
+	unsigned int userId;
 };
 
+/// Provides high level information related to a dtMeshTile object.
+/// @ingroup detour
 struct dtMeshHeader
 {
-	int magic;								// Magic number, used to identify the data.
-	int version;							// Data version number.
-	int x, y;								// Location of the time on the grid.
-	unsigned int userId;					// User ID of the tile.
-	int polyCount;							// Number of polygons in the tile.
-	int vertCount;							// Number of vertices in the tile.
-	int maxLinkCount;						// Number of allocated links.
-	int detailMeshCount;					// Number of detail meshes.
-	int detailVertCount;					// Number of detail vertices.
-	int detailTriCount;						// Number of detail triangles.
-	int bvNodeCount;						// Number of BVtree nodes.
-	int offMeshConCount;					// Number of Off-Mesh links.
-	int offMeshBase;						// Index to first polygon which is Off-Mesh link.
-	float walkableHeight;					// Height of the agent.
-	float walkableRadius;					// Radius of the agent
-	float walkableClimb;					// Max climb height of the agent.
-	float bmin[3], bmax[3];					// Bounding box of the tile.
-	float bvQuantFactor;					// BVtree quantization factor (world to bvnode coords)
+	int magic;				///< Tile magic number. (Used to identify the data format.)
+	int version;			///< Tile data format version number.
+	int x;					///< The x-position of the tile within the dtNavMesh tile grid. (x, y, layer)
+	int y;					///< The y-position of the tile within the dtNavMesh tile grid. (x, y, layer)
+	int layer;				///< The layer of the tile within the dtNavMesh tile grid. (x, y, layer)
+	unsigned int userId;	///< The user defined id of the tile.
+	int polyCount;			///< The number of polygons in the tile.
+	int vertCount;			///< The number of vertices in the tile.
+	int maxLinkCount;		///< The number of allocated links.
+	int detailMeshCount;	///< The number of sub-meshes in the detail mesh.
+
+	/// The number of unique vertices in the detail mesh. (In addition to the polygon vertices.)
+	int detailVertCount;
+
+	int detailTriCount;			///< The number of triangles in the detail mesh.
+	int bvNodeCount;			///< The number of bounding volume nodes. (Zero if bounding volumes are disabled.)
+	int offMeshConCount;		///< The number of off-mesh connections.
+	int offMeshBase;			///< The index of the first polygon which is an off-mesh connection.
+	float walkableHeight;		///< The height of the agents using the tile.
+	float walkableRadius;		///< The radius of the agents using the tile.
+	float walkableClimb;		///< The maximum climb height of the agents using the tile.
+	float bmin[3];				///< The minimum bounds of the tile's AABB. [(x, y, z)]
+	float bmax[3];				///< The maximum bounds of the tile's AABB. [(x, y, z)]
+
+	/// The bounding volume quantization factor. 
+	float bvQuantFactor;
 };
 
+/// Defines a navigation mesh tile.
+/// @ingroup detour
 struct dtMeshTile
 {
-	unsigned int salt;						// Counter describing modifications to the tile.
+	unsigned int salt;					///< Counter describing modifications to the tile.
 
-	unsigned int linksFreeList;				// Index to next free link.
-	dtMeshHeader* header;					// Pointer to tile header.
-	dtPoly* polys;							// Pointer to the polygons (will be updated when tile is added).
-	float* verts;							// Pointer to the vertices (will be updated when tile added).
-	dtLink* links;							// Pointer to the links (will be updated when tile added).
-	dtPolyDetail* detailMeshes;				// Pointer to detail meshes (will be updated when tile added).
-	float* detailVerts;						// Pointer to detail vertices (will be updated when tile added).
-	unsigned char* detailTris;				// Pointer to detail triangles (will be updated when tile added).
-	dtBVNode* bvTree;						// Pointer to BVtree nodes (will be updated when tile added).
-	dtOffMeshConnection* offMeshCons;		// Pointer to Off-Mesh links. (will be updated when tile added).
-		
-	unsigned char* data;					// Pointer to tile data.
-	int dataSize;							// Size of the tile data.
-	int flags;								// Tile flags, see dtTileFlags.
-	dtMeshTile* next;						// Next free tile or, next tile in spatial grid.
+	unsigned int linksFreeList;			///< Index to the next free link.
+	dtMeshHeader* header;				///< The tile header.
+	dtPoly* polys;						///< The tile polygons. [Size: dtMeshHeader::polyCount]
+	float* verts;						///< The tile vertices. [Size: dtMeshHeader::vertCount]
+	dtLink* links;						///< The tile links. [Size: dtMeshHeader::maxLinkCount]
+	dtPolyDetail* detailMeshes;			///< The tile's detail sub-meshes. [Size: dtMeshHeader::detailMeshCount]
+
+	/// The detail mesh's unique vertices. [(x, y, z) * dtMeshHeader::detailVertCount]
+	float* detailVerts;
+
+	/// The detail mesh's triangles. [(vertA, vertB, vertC) * dtMeshHeader::detailTriCount]
+	unsigned char* detailTris;
+
+	/// The tile bounding volume nodes. [Size: dtMeshHeader::bvNodeCount]
+	/// (Will be null if bounding volumes are disabled.)
+	dtBVNode* bvTree;
+
+	dtOffMeshConnection* offMeshCons;		///< The tile off-mesh connections. [Size: dtMeshHeader::offMeshConCount]
+
+	unsigned char* data;					///< The tile data. (Not directly accessed under normal situations.)
+	int dataSize;							///< Size of the tile data.
+	int flags;								///< Tile flags. (See: #dtTileFlags)
+	dtMeshTile* next;						///< The next free tile, or the next tile in the spatial grid.
 };
 
+/// Configutration parameters used to define multi-tile navigation meshes.
+/// The values are used to allocate space during the initialization of a navigation mesh.
+/// @see dtNavMesh::init()
+/// @ingroup detour
 struct dtNavMeshParams
 {
-	float orig[3];					// Origin of the nav mesh tile space.
-	float tileWidth, tileHeight;	// Width and height of each tile.
-	int maxTiles;					// Maximum number of tiles the navmesh can contain.
-	int maxPolys;					// Maximum number of polygons each tile can contain.
+	float orig[3];					///< The world space origin of the navigation mesh's tile space. [(x, y, z)]
+	float tileWidth;				///< The width of each tile. (Along the x-axis.)
+	float tileHeight;				///< The height of each tile. (Along the z-axis.)
+	int maxTiles;					///< The maximum number of tiles the navigation mesh can contain.
+	int maxPolys;					///< The maximum number of polygons each tile can contain.
 };
 
-
+/// A navigation mesh based on tiles of convex polygons.
+/// @ingroup detour
 class dtNavMesh
 {
 public:
 	dtNavMesh();
 	~dtNavMesh();
 
-	// Initializes the nav mesh for tiled use.
-	// Params:
-	//  params - (in) navmesh initialization params, see dtNavMeshParams.
-	// Returns: True if succeed, else false.
+	/// @{
+	/// @name Initialization and Tile Management
+
+	/// Initializes the navigation mesh for tiled use.
+	///  @param[in]	params		Initialization parameters.
+	/// @return The status flags for the operation.
 	dtStatus init(const dtNavMeshParams* params);
 
-	// Initializes the nav mesh for single tile use.
-	// Params:
-	//  data - (in) Data of the new tile mesh.
-	//  dataSize - (in) Data size of the new tile mesh.
-	//	flags - (in) Tile flags, see dtTileFlags.
-	// Returns: True if succeed, else false.
+	/// Initializes the navigation mesh for single tile use.
+	///  @param[in]	data		Data of the new tile. (See: #dtCreateNavMeshData)
+	///  @param[in]	dataSize	The data size of the new tile.
+	///  @param[in]	flags		The tile flags. (See: #dtTileFlags)
+	/// @return The status flags for the operation.
+	///  @see dtCreateNavMeshData
 	dtStatus init(unsigned char* data, const int dataSize, const int flags);
-	
-	// Returns pointer to navmesh initialization params.
+
+	/// The navigation mesh initialization params.
 	const dtNavMeshParams* getParams() const;
 
-	// Adds new tile into the navmesh.
-	// The add will fail if the data is in wrong format,
-	// there is not enough tiles left, or if there is a tile already at the location.
-	// Params:
-	//  data - (in) Data of the new tile mesh.
-	//  dataSize - (in) Data size of the new tile mesh.
-	//	flags - (in) Tile flags, see dtTileFlags.
-	//  lastRef - (in,optional) Last tile ref, the tile will be restored so that
-	//            the reference (as well as poly references) will be the same. Default: 0.
-	//  result - (out,optional) tile ref if the tile was succesfully added.
+	/// Adds a tile to the navigation mesh.
+	///  @param[in]		data		Data for the new tile mesh. (See: #dtCreateNavMeshData)
+	///  @param[in]		dataSize	Data size of the new tile mesh.
+	///  @param[in]		flags		Tile flags. (See: #dtTileFlags)
+	///  @param[in]		lastRef		The desired reference for the tile. (When reloading a tile.) [opt] [Default: 0]
+	///  @param[out]	result		The tile reference. (If the tile was succesfully added.) [opt]
+	/// @return The status flags for the operation.
 	dtStatus addTile(unsigned char* data, int dataSize, int flags, dtTileRef lastRef, dtTileRef* result);
 
-	// Removes specified tile.
-	// Params:
-	//  ref - (in) Reference to the tile to remove.
-	//  data - (out) Data associated with deleted tile.
-	//  dataSize - (out) Size of the data associated with deleted tile. 
+	/// Removes the specified tile from the navigation mesh.
+	///  @param[in]		ref			The reference of the tile to remove.
+	///  @param[out]	data		Data associated with deleted tile.
+	///  @param[out]	dataSize	Size of the data associated with deleted tile.
+	/// @return The status flags for the operation.
 	dtStatus removeTile(dtTileRef ref, unsigned char** data, int* dataSize);
 
-	// Calculates tile location based in input world position.
-	// Params:
-	//  pos - (in) world position of the query.
-	//  tx - (out) tile x location.
-	//  ty - (out) tile y location.
+	/// @}
+
+	/// @{
+	/// @name Query Functions
+
+	/// Calculates the tile grid location for the specified world position.
+	///  @param[in]	pos  The world position for the query. [(x, y, z)]
+	///  @param[out]	tx		The tile's x-location. (x, y)
+	///  @param[out]	ty		The tile's y-location. (x, y)
 	void calcTileLoc(const float* pos, int* tx, int* ty) const;
 
-	// Returns pointer to tile at specified location.
-	// Params:
-	//  x,y - (in) Location of the tile to get.
-	// Returns: pointer to tile if tile exists or 0 tile does not exists.
-	const dtMeshTile* getTileAt(int x, int y) const;
+	/// Gets the tile at the specified grid location.
+	///  @param[in]	x		The tile's x-location. (x, y, layer)
+	///  @param[in]	y		The tile's y-location. (x, y, layer)
+	///  @param[in]	layer	The tile's layer. (x, y, layer)
+	/// @return The tile, or null if the tile does not exist.
+	const dtMeshTile* getTileAt(const int x, const int y, const int layer) const;
 
-	// Returns reference to tile at specified location.
-	// Params:
-	//  x,y - (in) Location of the tile to get.
-	// Returns: reference to tile if tile exists or 0 tile does not exists.
-	dtTileRef getTileRefAt(int x, int y) const;
-	
-	// Returns tile references of a tile based on tile pointer.
+	/// Gets all tiles at the specified grid location. (All layers.)
+	///  @param[in]		x			The tile's x-location. (x, y)
+	///  @param[in]		y			The tile's y-location. (x, y)
+	///  @param[out]	tiles		A pointer to an array of tiles that will hold the result.
+	///  @param[in]		maxTiles	The maximum tiles the tiles parameter can hold.
+	/// @return The number of tiles returned in the tiles array.
+	int getTilesAt(const int x, const int y,
+				   dtMeshTile const** tiles, const int maxTiles) const;
+
+	/// Gets the tile reference for the tile at specified grid location.
+	///  @param[in]	x		The tile's x-location. (x, y, layer)
+	///  @param[in]	y		The tile's y-location. (x, y, layer)
+	///  @param[in]	layer	The tile's layer. (x, y, layer)
+	/// @return The tile reference of the tile, or 0 if there is none.
+	dtTileRef getTileRefAt(int x, int y, int layer) const;
+
+	/// Gets the tile reference for the specified tile.
+	///  @param[in]	tile	The tile.
+	/// @return The tile reference of the tile.
 	dtTileRef getTileRef(const dtMeshTile* tile) const;
 
-	// Returns tile based on references.
+	/// Gets the tile for the specified tile reference.
+	///  @param[in]	ref		The tile reference of the tile to retrieve.
+	/// @return The tile for the specified reference, or null if the 
+	///		reference is invalid.
 	const dtMeshTile* getTileByRef(dtTileRef ref) const;
-	
-	// Returns max number of tiles.
+
+	/// The maximum number of tiles supported by the navigation mesh.
+	/// @return The maximum number of tiles supported by the navigation mesh.
 	int getMaxTiles() const;
-	
-	// Returns pointer to tile in the tile array.
-	// Params:
-	//  i - (in) Index to the tile to retrieve, max index is getMaxTiles()-1.
-	// Returns: Pointer to specified tile.
+
+	/// Gets the tile at the specified index.
+	///  @param[in]	i		The tile index. [Limit: 0 >= index < #getMaxTiles()]
+	/// @return The tile at the specified index.
 	const dtMeshTile* getTile(int i) const;
 
-	// Returns pointer to tile and polygon pointed by the polygon reference.
-	// Params:
-	//  ref - (in) reference to a polygon.
-	//  tile - (out) pointer to the tile containing the polygon.
-	//  poly - (out) pointer to the polygon.
+	/// Gets the tile and polygon for the specified polygon reference.
+	///  @param[in]		ref		The reference for the a polygon.
+	///  @param[out]	tile	The tile containing the polygon.
+	///  @param[out]	poly	The polygon.
+	/// @return The status flags for the operation.
 	dtStatus getTileAndPolyByRef(const dtPolyRef ref, const dtMeshTile** tile, const dtPoly** poly) const;
-	
-	// Returns pointer to tile and polygon pointed by the polygon reference.
-	// Note: this function does not check if 'ref' s valid, and is thus faster. Use only with valid refs!
-	// Params:
-	//  ref - (in) reference to a polygon.
-	//  tile - (out) pointer to the tile containing the polygon.
-	//  poly - (out) pointer to the polygon.
+
+	/// Returns the tile and polygon for the specified polygon reference.
+	///  @param[in]		ref		A known valid reference for a polygon.
+	///  @param[out]	tile	The tile containing the polygon.
+	///  @param[out]	poly	The polygon.
 	void getTileAndPolyByRefUnsafe(const dtPolyRef ref, const dtMeshTile** tile, const dtPoly** poly) const;
 
-	// Returns true if polygon reference points to valid data.
+	/// Checks the validity of a polygon reference.
+	///  @param[in]	ref		The polygon reference to check.
+	/// @return True if polygon reference is valid for the navigation mesh.
 	bool isValidPolyRef(dtPolyRef ref) const;
-	
-	// Returns base poly id for specified tile, polygon refs can be deducted from this.
+
+	/// Gets the polygon reference for the tile's base polygon.
+	///  @param[in]	tile		The tile.
+	/// @return The polygon reference for the base polygon in the specified tile.
 	dtPolyRef getPolyRefBase(const dtMeshTile* tile) const;
-	
-	// Returns start and end location of an off-mesh link polygon.
-	// Params:
-	//	prevRef - (in) ref to the polygon before the link (used to select direction).
-	//	polyRef - (in) ref to the off-mesh link polygon.
-	//	startPos[3] - (out) start point of the link.
-	//	endPos[3] - (out) end point of the link.
-	// Returns: true if link is found.
+
+	/// Gets the endpoints for an off-mesh connection, ordered by "direction of travel".
+	///  @param[in]		prevRef		The reference of the polygon before the connection.
+	///  @param[in]		polyRef		The reference of the off-mesh connection polygon.
+	///  @param[out]	startPos	The start position of the off-mesh connection. [(x, y, z)]
+	///  @param[out]	endPos		The end position of the off-mesh connection. [(x, y, z)]
+	/// @return The status flags for the operation.
 	dtStatus getOffMeshConnectionPolyEndPoints(dtPolyRef prevRef, dtPolyRef polyRef, float* startPos, float* endPos) const;
 
-	// Returns pointer to off-mesh connection based on polyref, or null if ref not valid.
+	/// Gets the specified off-mesh connection.
+	///  @param[in]	ref		The polygon reference of the off-mesh connection.
+	/// @return The specified off-mesh connection, or null if the polygon reference is not valid.
 	const dtOffMeshConnection* getOffMeshConnectionByRef(dtPolyRef ref) const;
-	
-	// Sets polygon flags.
+
+	/// @}
+
+	/// @{
+	/// @name State Management
+	/// These functions do not effect #dtTileRef or #dtPolyRef's. 
+
+	/// Sets the user defined flags for the specified polygon.
+	///  @param[in]	ref		The polygon reference.
+	///  @param[in]	flags	The new flags for the polygon.
+	/// @return The status flags for the operation.
 	dtStatus setPolyFlags(dtPolyRef ref, unsigned short flags);
 
-	// Return polygon flags.
+	/// Gets the user defined flags for the specified polygon.
+	///  @param[in]		ref				The polygon reference.
+	///  @param[out]	resultFlags		The polygon flags.
+	/// @return The status flags for the operation.
 	dtStatus getPolyFlags(dtPolyRef ref, unsigned short* resultFlags) const;
 
-	// Set polygon type.
+	/// Sets the user defined area for the specified polygon.
+	///  @param[in]	ref		The polygon reference.
+	///  @param[in]	area	The new area id for the polygon. [Limit: < #DT_MAX_AREAS]
+	/// @return The status flags for the operation.
 	dtStatus setPolyArea(dtPolyRef ref, unsigned char area);
 
-	// Return polygon area type.
+	/// Gets the user defined area for the specified polygon.
+	///  @param[in]		ref			The polygon reference.
+	///  @param[out]	resultArea	The area id for the polygon.
+	/// @return The status flags for the operation.
 	dtStatus getPolyArea(dtPolyRef ref, unsigned char* resultArea) const;
 
+	/// Gets the size of the buffer required by #storeTileState to store the specified tile's state.
+	///  @param[in]	tile	The tile.
+	/// @return The size of the buffer required to store the state.
+	int getTileStateSize(const dtMeshTile* tile) const;
 
-	// Returns number of bytes required to store tile state.
-	int getTileStateSize(const dtMeshTile* tile) const;
-	
-	// Stores tile state to buffer.
+	/// Stores the non-structural state of the tile in the specified buffer. (Flags, area ids, etc.)
+	///  @param[in]		tile			The tile.
+	///  @param[out]	data			The buffer to store the tile's state in.
+	///  @param[in]		maxDataSize		The size of the data buffer. [Limit: >= #getTileStateSize]
+	/// @return The status flags for the operation.
 	dtStatus storeTileState(const dtMeshTile* tile, unsigned char* data, const int maxDataSize) const;
-	
-	// Restores tile state.
+
+	/// Restores the state of the tile.
+	///  @param[in]	tile			The tile.
+	///  @param[in]	data			The new state. (Obtained from #storeTileState.)
+	///  @param[in]	maxDataSize		The size of the state within the data buffer.
+	/// @return The status flags for the operation.
 	dtStatus restoreTileState(dtMeshTile* tile, const unsigned char* data, const int maxDataSize);
-	
 
-	// Encodes a tile id.
+	/// @}
+
+	/// @{
+	/// @name Encoding and Decoding
+	/// These functions are generally meant for internal use only.
+
+	/// Derives a standard polygon reference.
+	///  @note This function is generally meant for internal use only.
+	///  @param[in]	salt	The tile's salt value.
+	///  @param[in]	it		The index of the tile.
+	///  @param[in]	ip		The index of the polygon within the tile.
 	inline dtPolyRef encodePolyId(unsigned int salt, unsigned int it, unsigned int ip) const
 	{
 		return ((dtPolyRef)salt << (m_polyBits+m_tileBits)) | ((dtPolyRef)it << m_polyBits) | (dtPolyRef)ip;
 	}
-	
-	// Decodes a tile id.
+
+	/// Decodes a standard polygon reference.
+	///  @note This function is generally meant for internal use only.
+	///  @param[in]	ref   The polygon reference to decode.
+	///  @param[out]	salt	The tile's salt value.
+	///  @param[out]	it		The index of the tile.
+	///  @param[out]	ip		The index of the polygon within the tile.
+	///  @see #encodePolyId
 	inline void decodePolyId(dtPolyRef ref, unsigned int& salt, unsigned int& it, unsigned int& ip) const
 	{
 		const dtPolyRef saltMask = ((dtPolyRef)1<<m_saltBits)-1;
@@ -346,81 +492,201 @@
 		ip = (unsigned int)(ref & polyMask);
 	}
 
-	// Decodes a tile salt.
+	/// Extracts a tile's salt value from the specified polygon reference.
+	///  @note This function is generally meant for internal use only.
+	///  @param[in]	ref		The polygon reference.
+	///  @see #encodePolyId
 	inline unsigned int decodePolyIdSalt(dtPolyRef ref) const
 	{
 		const dtPolyRef saltMask = ((dtPolyRef)1<<m_saltBits)-1;
 		return (unsigned int)((ref >> (m_polyBits+m_tileBits)) & saltMask);
 	}
-	
-	// Decodes a tile id.
+
+	/// Extracts the tile's index from the specified polygon reference.
+	///  @note This function is generally meant for internal use only.
+	///  @param[in]	ref		The polygon reference.
+	///  @see #encodePolyId
 	inline unsigned int decodePolyIdTile(dtPolyRef ref) const
 	{
 		const dtPolyRef tileMask = ((dtPolyRef)1<<m_tileBits)-1;
 		return (unsigned int)((ref >> m_polyBits) & tileMask);
 	}
-	
-	// Decodes a poly id.
+
+	/// Extracts the polygon's index (within its tile) from the specified polygon reference.
+	///  @note This function is generally meant for internal use only.
+	///  @param[in]	ref		The polygon reference.
+	///  @see #encodePolyId
 	inline unsigned int decodePolyIdPoly(dtPolyRef ref) const
 	{
 		const dtPolyRef polyMask = ((dtPolyRef)1<<m_polyBits)-1;
 		return (unsigned int)(ref & polyMask);
 	}
-	
+
+	/// @}
+
 private:
 
-	// Returns pointer to tile in the tile array.
+	/// Returns pointer to tile in the tile array.
 	dtMeshTile* getTile(int i);
 
-	// Returns neighbour tile based on side. 
-	dtMeshTile* getNeighbourTileAt(int x, int y, int side) const;
-	// Returns all polygons in neighbour tile based on portal defined by the segment.
+	/// Returns neighbour tile based on side.
+	int getTilesAt(const int x, const int y,
+				   dtMeshTile** tiles, const int maxTiles) const;
+
+	/// Returns neighbour tile based on side.
+	int getNeighbourTilesAt(const int x, const int y, const int side,
+							dtMeshTile** tiles, const int maxTiles) const;
+
+	/// Returns all polygons in neighbour tile based on portal defined by the segment.
 	int findConnectingPolys(const float* va, const float* vb,
 							const dtMeshTile* tile, int side,
 							dtPolyRef* con, float* conarea, int maxcon) const;
-	
-	// Builds internal polygons links for a tile.
+
+	/// Builds internal polygons links for a tile.
 	void connectIntLinks(dtMeshTile* tile);
-	// Builds internal polygons links for a tile.
+	/// Builds internal polygons links for a tile.
 	void connectIntOffMeshLinks(dtMeshTile* tile);
 
-	// Builds external polygon links for a tile.
+	/// Builds external polygon links for a tile.
 	void connectExtLinks(dtMeshTile* tile, dtMeshTile* target, int side);
-	// Builds external polygon links for a tile.
+	/// Builds external polygon links for a tile.
 	void connectExtOffMeshLinks(dtMeshTile* tile, dtMeshTile* target, int side);
-	
-	// Removes external links at specified side.
-	void unconnectExtLinks(dtMeshTile* tile, int side);
-	
-	// TODO: These methods are duplicates from dtNavMeshQuery, but are needed for off-mesh connection finding.
 
-	// Queries polygons within a tile.
-	int queryPolygonsInTile(const dtMeshTile* tile, const float* qmin, const float* qmax, dtPolyRef* polys, const int maxPolys);
+	/// Removes external links at specified side.
+	void unconnectExtLinks(dtMeshTile* tile, dtMeshTile* target);
 
-	// Find nearest polygon within a tile.
-	dtPolyRef findNearestPolyInTile(const dtMeshTile* tile, const float* center, const float* extents, float* nearestPt);
 
-	// Returns closest point on polygon.
-	dtStatus closestPointOnPolyInTile(const dtMeshTile* tile, unsigned int ip, const float* pos, float* closest);
+	// TODO: These methods are duplicates from dtNavMeshQuery, but are needed for off-mesh connection finding.
 
-	dtNavMeshParams m_params;			// Current initialization params. TODO: do not store this info twice.
-	float m_orig[3];					// Origin of the tile (0,0)
-	float m_tileWidth, m_tileHeight;	// Dimensions of each tile.
-	int m_maxTiles;						// Max number of tiles.
-	int m_tileLutSize;					// Tile hash lookup size (must be pot).
-	int m_tileLutMask;					// Tile hash lookup mask.
+	/// Queries polygons within a tile.
+	int queryPolygonsInTile(const dtMeshTile* tile, const float* qmin, const float* qmax,
+							dtPolyRef* polys, const int maxPolys) const;
+	/// Find nearest polygon within a tile.
+	dtPolyRef findNearestPolyInTile(const dtMeshTile* tile, const float* center,
+									const float* extents, float* nearestPt) const;
+	/// Returns closest point on polygon.
+	void closestPointOnPolyInTile(const dtMeshTile* tile, unsigned int ip,
+								  const float* pos, float* closest) const;
 
-	dtMeshTile** m_posLookup;			// Tile hash lookup.
-	dtMeshTile* m_nextFree;				// Freelist of tiles.
-	dtMeshTile* m_tiles;				// List of tiles.
+	dtNavMeshParams m_params;			///< Current initialization params. TODO: do not store this info twice.
+	float m_orig[3];					///< Origin of the tile (0,0)
+	float m_tileWidth, m_tileHeight;	///< Dimensions of each tile.
+	int m_maxTiles;						///< Max number of tiles.
+	int m_tileLutSize;					///< Tile hash lookup size (must be pot).
+	int m_tileLutMask;					///< Tile hash lookup mask.
 
-	unsigned int m_saltBits;			// Number of salt bits in the tile ID.
-	unsigned int m_tileBits;			// Number of tile bits in the tile ID.
-	unsigned int m_polyBits;			// Number of poly bits in the tile ID.
+	dtMeshTile** m_posLookup;			///< Tile hash lookup.
+	dtMeshTile* m_nextFree;				///< Freelist of tiles.
+	dtMeshTile* m_tiles;				///< List of tiles.
+
+	unsigned int m_saltBits;			///< Number of salt bits in the tile ID.
+	unsigned int m_tileBits;			///< Number of tile bits in the tile ID.
+	unsigned int m_polyBits;			///< Number of poly bits in the tile ID.
 };
 
-// Helper function to allocate navmesh class using Detour allocator.
+/// Allocates a navigation mesh object using the Detour allocator.
+/// @return A navigation mesh that is ready for initialization, or null on failure.
+///  @ingroup detour
 dtNavMesh* mallocNavMesh();
+
+/// Frees the specified navigation mesh object using the Detour allocator.
+///  @param[in]	navmesh		A navigation mesh allocated using #mallocNavMesh
+///  @ingroup detour
 void freeNavMesh(dtNavMesh* navmesh);
 
 #endif // DETOURNAVMESH_H
+
+///////////////////////////////////////////////////////////////////////////
+
+// This section contains detailed documentation for members that don't have
+// a source file. It reduces clutter in the main section of the header.
+
+/**
+
+@typedef dtPolyRef
+@par
+
+Polygon references are subject to the same invalidate/preserve/restore 
+rules that apply to #dtTileRef's.  If the #dtTileRef for the polygon's
+tile changes, the polygon reference becomes invalid.
+
+Changing a polygon's flags, area id, etc. does not impact its polygon
+reference.
+
+@typedef dtTileRef
+@par
+
+The following changes will invalidate a tile reference:
+
+- The referenced tile has been removed from the navigation mesh.
+- The navigation mesh has been initialized using a different set
+  of #dtNavMeshParams.
+
+A tile reference is preserved/restored if the tile is added to a navigation 
+mesh initialized with the original #dtNavMeshParams and is added at the
+original reference location. (E.g. The lastRef parameter is used with
+dtNavMesh::addTile.)
+
+Basically, if the storage structure of a tile changes, its associated
+tile reference changes.
+
+
+@var unsigned short dtPoly::neis[DT_VERTS_PER_POLYGON]
+@par
+
+Each entry represents data for the edge starting at the vertex of the same index. 
+E.g. The entry at index n represents the edge data for vertex[n] to vertex[n+1].
+
+A value of zero indicates the edge has no polygon connection. (It makes up the 
+border of the navigation mesh.)
+
+The information can be extracted as follows: 
+@code 
+neighborRef = neis[n] & 0xff; // Get the neighbor polygon reference.
+
+if (neis[n] & #DT_EX_LINK)
+{
+    // The edge is an external (portal) edge.
+}
+@endcode
+
+@var float dtMeshHeader::bvQuantFactor
+@par
+
+This value is used for converting between world and bounding volume coordinates.
+For example:
+@code
+const float cs = 1.0f / tile->header->bvQuantFactor;
+const dtBVNode* n = &tile->bvTree[i];
+if (n->i >= 0)
+{
+    // This is a leaf node.
+    float worldMinX = tile->header->bmin[0] + n->bmin[0]*cs;
+    float worldMinY = tile->header->bmin[0] + n->bmin[1]*cs;
+    // Etc...
+}
+@endcode
+
+@struct dtMeshTile
+@par
+
+Tiles generally only exist within the context of a dtNavMesh object.
+
+Some tile content is optional.  For example, a tile may not contain any
+off-mesh connections.  In this case the associated pointer will be null.
+
+If a detail mesh exists it will share vertices with the base polygon mesh.  
+Only the vertices unique to the detail mesh will be stored in #detailVerts.
+
+@warning Tiles returned by a dtNavMesh object are not guarenteed to be populated.
+For example: The tile at a location might not have been loaded yet, or may have been removed.
+In this case, pointers will be null.  So if in doubt, check the polygon count in the 
+tile's header to determine if a tile has polygons defined.
+
+@var float dtOffMeshConnection::pos[6]
+@par
+
+For a properly built navigation mesh, vertex A will always be within the bounds of the mesh. 
+Vertex B is not required to be within the bounds of the mesh.
+
+*/
Index: src/hearthstone-shared/Pathfinding/Detour/DetourNavMeshBuilder.cpp
===================================================================
--- src/hearthstone-shared/Pathfinding/Detour/DetourNavMeshBuilder.cpp	(revision 1490)
+++ src/hearthstone-shared/Pathfinding/Detour/DetourNavMeshBuilder.cpp	(working copy)
@@ -70,18 +70,18 @@
 	bmin[0] = items[imin].bmin[0];
 	bmin[1] = items[imin].bmin[1];
 	bmin[2] = items[imin].bmin[2];
-	
+
 	bmax[0] = items[imin].bmax[0];
 	bmax[1] = items[imin].bmax[1];
 	bmax[2] = items[imin].bmax[2];
-	
+
 	for (int i = imin+1; i < imax; ++i)
 	{
 		const BVItem& it = items[i];
 		if (it.bmin[0] < bmin[0]) bmin[0] = it.bmin[0];
 		if (it.bmin[1] < bmin[1]) bmin[1] = it.bmin[1];
 		if (it.bmin[2] < bmin[2]) bmin[2] = it.bmin[2];
-		
+
 		if (it.bmax[0] > bmax[0]) bmax[0] = it.bmax[0];
 		if (it.bmax[1] > bmax[1]) bmax[1] = it.bmax[1];
 		if (it.bmax[2] > bmax[2]) bmax[2] = it.bmax[2];
@@ -109,31 +109,31 @@
 {
 	int inum = imax - imin;
 	int icur = curNode;
-	
+
 	dtBVNode& node = nodes[curNode++];
-	
+
 	if (inum == 1)
 	{
 		// Leaf
 		node.bmin[0] = items[imin].bmin[0];
 		node.bmin[1] = items[imin].bmin[1];
 		node.bmin[2] = items[imin].bmin[2];
-		
+
 		node.bmax[0] = items[imin].bmax[0];
 		node.bmax[1] = items[imin].bmax[1];
 		node.bmax[2] = items[imin].bmax[2];
-		
+
 		node.i = items[imin].i;
 	}
 	else
 	{
 		// Split
 		calcExtends(items, nitems, imin, imax, node.bmin, node.bmax);
-		
+
 		int	axis = longestAxis(node.bmax[0] - node.bmin[0],
 							   node.bmax[1] - node.bmin[1],
 							   node.bmax[2] - node.bmin[2]);
-		
+
 		if (axis == 0)
 		{
 			// Sort along x-axis
@@ -149,14 +149,14 @@
 			// Sort along z-axis
 			qsort(items+imin, inum, sizeof(BVItem), compareItemZ);
 		}
-		
+
 		int isplit = imin+inum/2;
-		
+
 		// Left
 		subdivide(items, nitems, imin, isplit, curNode, nodes);
 		// Right
 		subdivide(items, nitems, isplit, imax, curNode, nodes);
-		
+
 		int iescape = curNode - icur;
 		// Negative index means escape.
 		node.i = -iescape;
@@ -179,18 +179,18 @@
 		it.bmin[0] = it.bmax[0] = verts[p[0]*3+0];
 		it.bmin[1] = it.bmax[1] = verts[p[0]*3+1];
 		it.bmin[2] = it.bmax[2] = verts[p[0]*3+2];
-		
+
 		for (int j = 1; j < nvp; ++j)
 		{
 			if (p[j] == MESH_NULL_IDX) break;
 			unsigned short x = verts[p[j]*3+0];
 			unsigned short y = verts[p[j]*3+1];
 			unsigned short z = verts[p[j]*3+2];
-			
+
 			if (x < it.bmin[0]) it.bmin[0] = x;
 			if (y < it.bmin[1]) it.bmin[1] = y;
 			if (z < it.bmin[2]) it.bmin[2] = z;
-			
+
 			if (x > it.bmax[0]) it.bmax[0] = x;
 			if (y > it.bmax[1]) it.bmax[1] = y;
 			if (z > it.bmax[2]) it.bmax[2] = z;
@@ -199,12 +199,12 @@
 		it.bmin[1] = (unsigned short)floorf((float)it.bmin[1]*ch/cs);
 		it.bmax[1] = (unsigned short)ceilf((float)it.bmax[1]*ch/cs);
 	}
-	
+
 	int curNode = 0;
 	subdivide(items, npolys, 0, npolys, curNode, nodes);
-	
+
 	free(items);
-	
+
 	return curNode;
 }
 
@@ -213,7 +213,7 @@
 	static const unsigned char XP = 1<<0;
 	static const unsigned char ZP = 1<<1;
 	static const unsigned char XM = 1<<2;
-	static const unsigned char ZM = 1<<3;	
+	static const unsigned char ZM = 1<<3;
 
 	unsigned char outcode = 0; 
 	outcode |= (pt[0] >= bmax[0]) ? XP : 0;
@@ -232,7 +232,7 @@
 	case ZM: return 6;
 	case XP|ZM: return 7;
 	};
-	return 0xff;	
+	return 0xff;
 }
 
 // TODO: Better error handling.
@@ -247,17 +247,15 @@
 		return false;
 	if (!params->polyCount || !params->polys)
 		return false;
-	if (!params->detailMeshes || !params->detailVerts || !params->detailTris)
-		return false;
 
 	const int nvp = params->nvp;
-	
+
 	// Classify off-mesh connection points. We store only the connections
 	// whose start point is inside the tile.
 	unsigned char* offMeshConClass = 0;
 	int storedOffMeshConCount = 0;
 	int offMeshConLinkCount = 0;
-	
+
 	if (params->offMeshConCount > 0)
 	{
 		offMeshConClass = (unsigned char*)malloc(sizeof(unsigned char)*params->offMeshConCount*2);
@@ -279,11 +277,11 @@
 				storedOffMeshConCount++;
 		}
 	}
-	
+
 	// Off-mesh connectionss are stored as polygons, adjust values.
 	const int totPolyCount = params->polyCount + storedOffMeshConCount;
 	const int totVertCount = params->vertCount + storedOffMeshConCount*2;
-	
+
 	// Find portal edges which are at tile borders.
 	int edgeCount = 0;
 	int portalCount = 0;
@@ -293,45 +291,58 @@
 		for (int j = 0; j < nvp; ++j)
 		{
 			if (p[j] == MESH_NULL_IDX) break;
-			int nj = j+1;
-			if (nj >= nvp || p[nj] == MESH_NULL_IDX) nj = 0;
-			const unsigned short* va = &params->verts[p[j]*3];
-			const unsigned short* vb = &params->verts[p[nj]*3];
-			
 			edgeCount++;
-			
-			if (params->tileSize > 0)
+
+			if (p[nvp+j] & 0x8000)
 			{
-				if (va[0] == params->tileSize && vb[0] == params->tileSize)
-					portalCount++; // x+
-				else if (va[2] == params->tileSize && vb[2] == params->tileSize)
-					portalCount++; // z+
-				else if (va[0] == 0 && vb[0] == 0)
-					portalCount++; // x-
-				else if (va[2] == 0 && vb[2] == 0)
-					portalCount++; // z-
+				unsigned short dir = p[nvp+j] & 0xf;
+				if (dir != 0xf)
+					portalCount++;
 			}
 		}
 	}
 
 	const int maxLinkCount = edgeCount + portalCount*2 + offMeshConLinkCount*2;
-	
+
 	// Find unique detail vertices.
 	int uniqueDetailVertCount = 0;
-	for (int i = 0; i < params->polyCount; ++i)
+	int detailTriCount = 0;
+	if (params->detailMeshes)
 	{
-		const unsigned short* p = &params->polys[i*nvp*2];
-		int ndv = params->detailMeshes[i*4+1];
-		int nv = 0;
-		for (int j = 0; j < nvp; ++j)
+		// Has detail mesh, count unique detail vertex count and use input detail tri count.
+		detailTriCount = params->detailTriCount;
+		for (int i = 0; i < params->polyCount; ++i)
 		{
-			if (p[j] == MESH_NULL_IDX) break;
-			nv++;
+			const unsigned short* p = &params->polys[i*nvp*2];
+			int ndv = params->detailMeshes[i*4+1];
+			int nv = 0;
+			for (int j = 0; j < nvp; ++j)
+			{
+				if (p[j] == MESH_NULL_IDX) break;
+				nv++;
+			}
+			ndv -= nv;
+			uniqueDetailVertCount += ndv;
 		}
-		ndv -= nv;
-		uniqueDetailVertCount += ndv;
 	}
-	
+	else
+	{
+		// No input detail mesh, build detail mesh from nav polys.
+		uniqueDetailVertCount = 0; // No extra detail verts.
+		detailTriCount = 0;
+		for (int i = 0; i < params->polyCount; ++i)
+		{
+			const unsigned short* p = &params->polys[i*nvp*2];
+			int nv = 0;
+			for (int j = 0; j < nvp; ++j)
+			{
+				if (p[j] == MESH_NULL_IDX) break;
+				nv++;
+			}
+			detailTriCount += nv-2;
+		}
+	}
+
 	// Calculate data size
 	const int headerSize = dtAlign4(sizeof(dtMeshHeader));
 	const int vertsSize = dtAlign4(sizeof(float)*3*totVertCount);
@@ -339,10 +350,10 @@
 	const int linksSize = dtAlign4(sizeof(dtLink)*maxLinkCount);
 	const int detailMeshesSize = dtAlign4(sizeof(dtPolyDetail)*params->polyCount);
 	const int detailVertsSize = dtAlign4(sizeof(float)*3*uniqueDetailVertCount);
-	const int detailTrisSize = dtAlign4(sizeof(unsigned char)*4*params->detailTriCount);
-	const int bvTreeSize = dtAlign4(sizeof(dtBVNode)*params->polyCount*2);
+	const int detailTrisSize = dtAlign4(sizeof(unsigned char)*4*detailTriCount);
+	const int bvTreeSize = params->buildBvTree ? dtAlign4(sizeof(dtBVNode)*params->polyCount*2) : 0;
 	const int offMeshConsSize = dtAlign4(sizeof(dtOffMeshConnection)*storedOffMeshConCount);
-	
+
 	const int dataSize = headerSize + vertsSize + polysSize + linksSize +
 						 detailMeshesSize + detailVertsSize + detailTrisSize +
 						 bvTreeSize + offMeshConsSize;
@@ -365,13 +376,14 @@
 	unsigned char* navDTris = (unsigned char*)d; d += detailTrisSize;
 	dtBVNode* navBvtree = (dtBVNode*)d; d += bvTreeSize;
 	dtOffMeshConnection* offMeshCons = (dtOffMeshConnection*)d; d += offMeshConsSize;
-	
-	
+
+
 	// Store header
 	header->magic = DT_NAVMESH_MAGIC;
 	header->version = DT_NAVMESH_VERSION;
 	header->x = params->tileX;
 	header->y = params->tileY;
+	header->layer = params->tileLayer;
 	header->userId = params->userId;
 	header->polyCount = totPolyCount;
 	header->vertCount = totVertCount;
@@ -380,18 +392,18 @@
 	dtVcopy(header->bmax, params->bmax);
 	header->detailMeshCount = params->polyCount;
 	header->detailVertCount = uniqueDetailVertCount;
-	header->detailTriCount = params->detailTriCount;
+	header->detailTriCount = detailTriCount;
 	header->bvQuantFactor = 1.0f / params->cs;
 	header->offMeshBase = params->polyCount;
 	header->walkableHeight = params->walkableHeight;
 	header->walkableRadius = params->walkableRadius;
 	header->walkableClimb = params->walkableClimb;
 	header->offMeshConCount = storedOffMeshConCount;
-	header->bvNodeCount = params->polyCount*2;
-	
+	header->bvNodeCount = params->buildBvTree ? params->polyCount*2 : 0;
+
 	const int offMeshVertsBase = params->vertCount;
 	const int offMeshPolyBase = params->polyCount;
-	
+
 	// Store vertices
 	// Mesh vertices
 	for (int i = 0; i < params->vertCount; ++i)
@@ -431,7 +443,27 @@
 		{
 			if (src[j] == MESH_NULL_IDX) break;
 			p->verts[j] = src[j];
-			p->neis[j] = (src[nvp+j]+1) & 0xffff;
+			if (src[nvp+j] & 0x8000)
+			{
+				// Border or portal edge.
+				unsigned short dir = src[nvp+j] & 0xf;
+				if (dir == 0xf) // Border
+					p->neis[j] = 0;
+				else if (dir == 0) // Portal x-
+					p->neis[j] = DT_EXT_LINK | 4;
+				else if (dir == 1) // Portal z+
+					p->neis[j] = DT_EXT_LINK | 2;
+				else if (dir == 2) // Portal x+
+					p->neis[j] = DT_EXT_LINK | 0;
+				else if (dir == 3) // Portal z-
+					p->neis[j] = DT_EXT_LINK | 6;
+			}
+			else
+			{
+				// Normal connection
+				p->neis[j] = src[nvp+j]+1;
+			}
+
 			p->vertCount++;
 		}
 		src += nvp*2;
@@ -453,62 +485,69 @@
 			n++;
 		}
 	}
-	
-	// Store portal edges.
-	if (params->tileSize > 0)
+
+	// Store detail meshes and vertices.
+	// The nav polygon vertices are stored as the first vertices on each mesh.
+	// We compress the mesh data by skipping them and using the navmesh coordinates.
+	if (params->detailMeshes)
 	{
+		unsigned short vbase = 0;
 		for (int i = 0; i < params->polyCount; ++i)
 		{
-			dtPoly* poly = &navPolys[i];
-			for (int j = 0; j < poly->vertCount; ++j)
+			dtPolyDetail& dtl = navDMeshes[i];
+			const int vb = (int)params->detailMeshes[i*4+0];
+			const int ndv = (int)params->detailMeshes[i*4+1];
+			const int nv = navPolys[i].vertCount;
+			dtl.vertBase = (unsigned int)vbase;
+			dtl.vertCount = (unsigned char)(ndv-nv);
+			dtl.triBase = (unsigned int)params->detailMeshes[i*4+2];
+			dtl.triCount = (unsigned char)params->detailMeshes[i*4+3];
+			// Copy vertices except the first 'nv' verts which are equal to nav poly verts.
+			if (ndv-nv)
 			{
-				int nj = j+1;
-				if (nj >= poly->vertCount) nj = 0;
-
-				const unsigned short* va = &params->verts[poly->verts[j]*3];
-				const unsigned short* vb = &params->verts[poly->verts[nj]*3];
-							
-				if (va[0] == params->tileSize && vb[0] == params->tileSize) // x+
-					poly->neis[j] = DT_EXT_LINK | 0;
-				else if (va[2] == params->tileSize && vb[2]  == params->tileSize) // z+
-					poly->neis[j] = DT_EXT_LINK | 2;
-				else if (va[0] == 0 && vb[0] == 0) // x-
-					poly->neis[j] = DT_EXT_LINK | 4;
-				else if (va[2] == 0 && vb[2] == 0) // z-
-					poly->neis[j] = DT_EXT_LINK | 6;
+				memcpy(&navDVerts[vbase*3], &params->detailVerts[(vb+nv)*3], sizeof(float)*3*(ndv-nv));
+				vbase += (unsigned short)(ndv-nv);
 			}
 		}
+		// Store triangles.
+		memcpy(navDTris, params->detailTris, sizeof(unsigned char)*4*params->detailTriCount);
 	}
-
-	// Store detail meshes and vertices.
-	// The nav polygon vertices are stored as the first vertices on each mesh.
-	// We compress the mesh data by skipping them and using the navmesh coordinates.
-	unsigned short vbase = 0;
-	for (int i = 0; i < params->polyCount; ++i)
+	else
 	{
-		dtPolyDetail& dtl = navDMeshes[i];
-		const int vb = (int)params->detailMeshes[i*4+0];
-		const int ndv = (int)params->detailMeshes[i*4+1];
-		const int nv = navPolys[i].vertCount;
-		dtl.vertBase = (unsigned int)vbase;
-		dtl.vertCount = (unsigned char)(ndv-nv);
-		dtl.triBase = (unsigned int)params->detailMeshes[i*4+2];
-		dtl.triCount = (unsigned char)params->detailMeshes[i*4+3];
-		// Copy vertices except the first 'nv' verts which are equal to nav poly verts.
-		if (ndv-nv)
+		// Create dummy detail mesh by triangulating polys.
+		int tbase = 0;
+		for (int i = 0; i < params->polyCount; ++i)
 		{
-			memcpy(&navDVerts[vbase*3], &params->detailVerts[(vb+nv)*3], sizeof(float)*3*(ndv-nv));
-			vbase += (unsigned short)(ndv-nv);
+			dtPolyDetail& dtl = navDMeshes[i];
+			const int nv = navPolys[i].vertCount;
+			dtl.vertBase = 0;
+			dtl.vertCount = 0;
+			dtl.triBase = (unsigned int)tbase;
+			dtl.triCount = (unsigned char)(nv-2);
+			// Triangulate polygon (local indices).
+			for (int j = 2; j < nv; ++j)
+			{
+				unsigned char* t = &navDTris[tbase*4];
+				t[0] = 0;
+				t[1] = (unsigned char)(j-1);
+				t[2] = (unsigned char)j;
+				// Bit for each edge that belongs to poly boundary.
+				t[3] = (1<<2);
+				if (j == 2) t[3] |= (1<<0);
+				if (j == nv-1) t[3] |= (1<<4);
+				tbase++;
+			}
 		}
 	}
-	// Store triangles.
-	memcpy(navDTris, params->detailTris, sizeof(unsigned char)*4*params->detailTriCount);
 
 	// Store and create BVtree.
 	// TODO: take detail mesh into account! use byte per bbox extent?
-	createBVTree(params->verts, params->vertCount, params->polys, params->polyCount,
-				 nvp, params->cs, params->ch, params->polyCount*2, navBvtree);
-	
+	if (params->buildBvTree)
+	{
+		createBVTree(params->verts, params->vertCount, params->polys, params->polyCount,
+					 nvp, params->cs, params->ch, params->polyCount*2, navBvtree);
+	}
+
 	// Store Off-Mesh connections.
 	n = 0;
 	for (int i = 0; i < params->offMeshConCount; ++i)
@@ -530,12 +569,12 @@
 			n++;
 		}
 	}
-		
+
 	free(offMeshConClass);
-	
+
 	*outData = data;
 	*outDataSize = dataSize;
-	
+
 	return true;
 }
 
@@ -579,22 +618,23 @@
 bool dtNavMeshHeaderSwapEndian(unsigned char* data, const int /*dataSize*/)
 {
 	dtMeshHeader* header = (dtMeshHeader*)data;
-	
+
 	int swappedMagic = DT_NAVMESH_MAGIC;
 	int swappedVersion = DT_NAVMESH_VERSION;
 	swapEndian(&swappedMagic);
 	swapEndian(&swappedVersion);
-	
+
 	if ((header->magic != DT_NAVMESH_MAGIC || header->version != DT_NAVMESH_VERSION) &&
 		(header->magic != swappedMagic || header->version != swappedVersion))
 	{
 		return false;
 	}
-		
+
 	swapEndian(&header->magic);
 	swapEndian(&header->version);
 	swapEndian(&header->x);
 	swapEndian(&header->y);
+	swapEndian(&header->layer);
 	swapEndian(&header->userId);
 	swapEndian(&header->polyCount);
 	swapEndian(&header->vertCount);
@@ -629,7 +669,7 @@
 		return false;
 	if (header->version != DT_NAVMESH_VERSION)
 		return false;
-	
+
 	// Patch header pointers.
 	const int headerSize = dtAlign4(sizeof(dtMeshHeader));
 	const int vertsSize = dtAlign4(sizeof(float)*3*header->vertCount);
@@ -640,7 +680,7 @@
 	const int detailTrisSize = dtAlign4(sizeof(unsigned char)*4*header->detailTriCount);
 	const int bvtreeSize = dtAlign4(sizeof(dtBVNode)*header->bvNodeCount);
 	const int offMeshLinksSize = dtAlign4(sizeof(dtOffMeshConnection)*header->offMeshConCount);
-	
+
 	unsigned char* d = data + headerSize;
 	float* verts = (float*)d; d += vertsSize;
 	dtPoly* polys = (dtPoly*)d; d += polysSize;
@@ -650,7 +690,7 @@
 	/*unsigned char* detailTris = (unsigned char*)d;*/ d += detailTrisSize;
 	dtBVNode* bvTree = (dtBVNode*)d; d += bvtreeSize;
 	dtOffMeshConnection* offMeshCons = (dtOffMeshConnection*)d; d += offMeshLinksSize;
-	
+
 	// Vertices
 	for (int i = 0; i < header->vertCount*3; ++i)
 	{
@@ -679,7 +719,7 @@
 		swapEndian(&pd->vertBase);
 		swapEndian(&pd->triBase);
 	}
-	
+
 	// Detail verts
 	for (int i = 0; i < header->detailVertCount*3; ++i)
 	{
@@ -707,6 +747,6 @@
 		swapEndian(&con->rad);
 		swapEndian(&con->poly);
 	}
-	
+
 	return true;
 }
Index: src/hearthstone-shared/Pathfinding/Detour/DetourNavMeshBuilder.h
===================================================================
--- src/hearthstone-shared/Pathfinding/Detour/DetourNavMeshBuilder.h	(revision 1490)
+++ src/hearthstone-shared/Pathfinding/Detour/DetourNavMeshBuilder.h	(working copy)
@@ -21,56 +21,74 @@
 
 #include "../../Common.h"
 
-// The units of the parameters are specified in parenthesis as follows:
-// (vx) voxels, (wu) world units
+
+/// The units of the parameters are specified in parenthesis as follows:
+/// (vx) voxels, (wu) world units
 struct dtNavMeshCreateParams
 {
-	// Navmesh vertices.
-	const unsigned short* verts;			// Array of vertices, each vertex has 3 components. (vx).
-	int vertCount;							// Vertex count
-	// Navmesh polygons
-	const unsigned short* polys;			// Array of polygons, uses same format as rcPolyMesh. 
-	const unsigned short* polyFlags;		// Array of flags per polygon.
-	const unsigned char* polyAreas;			// Array of area ids per polygon.
-	int polyCount;							// Number of polygons
-	int nvp;								// Number of verts per polygon.
-	// Navmesh Detail
-	const unsigned int* detailMeshes;		// Detail meshes, uses same format as rcPolyMeshDetail.
-	const float* detailVerts;				// Detail mesh vertices, uses same format as rcPolyMeshDetail (wu).
-	int detailVertsCount;					// Total number of detail vertices
-	const unsigned char* detailTris;		// Array of detail tris per detail mesh.
-	int detailTriCount;						// Total number of detail triangles.
-	// Off-Mesh Connections.
-	const float* offMeshConVerts;			// Off-mesh connection vertices (wu).
-	const float* offMeshConRad;				// Off-mesh connection radii (wu).
-	const unsigned short* offMeshConFlags;	// Off-mesh connection flags.
-	const unsigned char* offMeshConAreas;	// Off-mesh connection area ids.
-	const unsigned char* offMeshConDir;		// Off-mesh connection direction flags (1 = bidir, 0 = oneway).
-	const unsigned int* offMeshConUserID;	// Off-mesh connection user id (optional).
-	int offMeshConCount;					// Number of off-mesh connections
-	// Tile location
-	unsigned int userId;					// User ID bound to the tile.
-	int tileX, tileY;						// Tile location (tile coords).
-	float bmin[3], bmax[3];					// Tile bounds (wu).
-	// Settings
-	float walkableHeight;					// Agent height (wu).
-	float walkableRadius;					// Agent radius (wu).
-	float walkableClimb;					// Agent max climb (wu).
-	float cs;								// Cell size (xz) (wu).
-	float ch;								// Cell height (y) (wu).
-	int tileSize;							// Tile size (width & height) (vx).
+	/// @name Navmesh vertices.
+	///@{
+	const unsigned short* verts;			///< Array of vertices, each vertex has 3 components. (vx).
+	int vertCount;							///< Vertex count
+	///@{
+
+	/// @name Navmesh polygons
+	///@{
+	const unsigned short* polys;			///< Array of polygons, uses same format as rcPolyMesh.
+	const unsigned short* polyFlags;		///< Array of flags per polygon.
+	const unsigned char* polyAreas;			///< Array of area ids per polygon.
+	int polyCount;							///< Number of polygons
+	int nvp;								///< Number of verts per polygon.
+	///@}
+
+	/// @name Navmesh Detail (optional)
+	///@{
+	const unsigned int* detailMeshes;		///< Detail meshes, uses same format as rcPolyMeshDetail.
+	const float* detailVerts;				///< Detail mesh vertices, uses same format as rcPolyMeshDetail (wu).
+	int detailVertsCount;					///< Total number of detail vertices
+	const unsigned char* detailTris;		///< Array of detail tris per detail mesh.
+	int detailTriCount;						///< Total number of detail triangles.
+	///@}
+
+	/// @name Off-Mesh Connections.
+	///@{
+	const float* offMeshConVerts;			///< Off-mesh connection vertices (wu).
+	const float* offMeshConRad;				///< Off-mesh connection radii (wu).
+	const unsigned short* offMeshConFlags;	///< Off-mesh connection flags.
+	const unsigned char* offMeshConAreas;	///< Off-mesh connection area ids.
+	const unsigned char* offMeshConDir;		///< Off-mesh connection direction flags (1 = bidir, 0 = oneway).
+	const unsigned int* offMeshConUserID;	///< Off-mesh connection user id (optional).
+	int offMeshConCount;					///< Number of off-mesh connections
+	///@}
+
+	/// @name Tile location
+	///@{
+	unsigned int userId;					///< User ID bound to the tile.
+	int tileX, tileY, tileLayer;			///< Tile location (tile coords).
+	float bmin[3], bmax[3];					///< Tile bounds (wu).
+	///@}
+
+	/// @name Settings
+	///@{
+	float walkableHeight;					///< Agent height (wu).
+	float walkableRadius;					///< Agent radius (wu).
+	float walkableClimb;					///< Agent max climb (wu).
+	float cs;								///< Cell size (xz) (wu).
+	float ch;								///< Cell height (y) (wu).
+	bool buildBvTree;						///< Flag indicating if BVTree for polygon query should be build.
+	///@}
 };
 
-// Build navmesh data from given input data.
+/// Build navmesh data from given input data.
 bool dtCreateNavMeshData(dtNavMeshCreateParams* params, unsigned char** outData, int* outDataSize);
 
-// Swaps endianess of navmesh header.
+/// Swaps endianess of navmesh header.
 bool dtNavMeshHeaderSwapEndian(unsigned char* data, const int dataSize);
 
-// Swaps endianess of the navmesh data. This function assumes that the header is in correct
-// endianess already. Call dtNavMeshHeaderSwapEndian() first on the data if the data is
-// assumed to be in wrong endianess to start with. If converting from native endianess to foreign,
-// call dtNavMeshHeaderSwapEndian() after the data has been swapped.
+/// Swaps endianess of the navmesh data. This function assumes that the header is in correct
+/// endianess already. Call dtNavMeshHeaderSwapEndian() first on the data if the data is
+/// assumed to be in wrong endianess to start with. If converting from native endianess to foreign,
+/// call dtNavMeshHeaderSwapEndian() after the data has been swapped.
 bool dtNavMeshDataSwapEndian(unsigned char* data, const int dataSize);
 
 #endif // DETOURNAVMESHBUILDER_H
Index: src/hearthstone-shared/Pathfinding/Detour/DetourNavMeshQuery.cpp
===================================================================
--- src/hearthstone-shared/Pathfinding/Detour/DetourNavMeshQuery.cpp	(revision 1490)
+++ src/hearthstone-shared/Pathfinding/Detour/DetourNavMeshQuery.cpp	(working copy)
@@ -22,6 +22,39 @@
 #include "DetourCommon.h"
 #include "../../Common.h"
 
+/// @class dtQueryFilter
+///
+/// <b>The Default Implmentation</b>
+/// 
+/// At construction: All area costs default to 1.0.  All flags are included
+/// and none are excluded.
+/// 
+/// If a polygon has both an include and an exclude flag, it will be excluded.
+/// 
+/// The way filtering works, a navigation mesh polygon must have at least one flag 
+/// set to ever be considered by a query. So a polygon with no flags will never
+/// be considered.
+///
+/// Setting the include flags to 0 will result in all polygons being excluded.
+///
+/// <b>Custom Implementations</b>
+/// 
+/// DT_VIRTUAL_QUERYFILTER must be defined in order to extend this class.
+/// 
+/// Implement a custom query filter by overriding the virtual passFilter() 
+/// and getCost() functions. If this is done, both functions should be as 
+/// fast as possible. Use cached local copies of data rather than accessing 
+/// your own objects where possible.
+/// 
+/// Custom implementations do not need to adhere to the flags or cost logic 
+/// used by the default implementation.  
+/// 
+/// In order for A* searches to work properly, the cost should be proportional to
+/// the travel distance. Implementing a cost modifier less than 1.0 is likely 
+/// to lead to problems during pathfinding.
+///
+/// @see dtNavMeshQuery
+
 dtQueryFilter::dtQueryFilter() :
 	m_includeFlags(0xffff),
 	m_excludeFlags(0)
@@ -62,8 +95,9 @@
 }
 #endif
 
-static const float H_SCALE = 2.0f; // Search heuristic scale.
+static const float H_SCALE = 0.999f; // Search heuristic scale.
 
+
 dtNavMeshQuery* mallocNavMeshQuery()
 {
 	void* mem = malloc(sizeof(dtNavMeshQuery));
@@ -79,7 +113,25 @@
 }
 
 //////////////////////////////////////////////////////////////////////////////////////////
+
+/// @class dtNavMeshQuery
+///
+/// For methods that support undersized buffers, if the buffer is too small 
+/// to hold the entire result set the return status of the method will include 
+/// the #DT_BUFFER_TOO_SMALL flag.
+///
+/// Constant member functions can be used by multiple clients without side
+/// effects. (E.g. No change to the closed list. No impact on an in-progress
+/// sliced path query. Etc.)
+/// 
+/// Walls and portals: A @e wall is a polygon segment that is 
+/// considered impassable. A @e portal is a passable segment between polygons.
+/// A portal may be treated as a wall based on the dtQueryFilter used for a query.
+///
+/// @see dtNavMesh, dtQueryFilter, #mallocNavMeshQuery(), #mallocNavMeshQuery()
+
 dtNavMeshQuery::dtNavMeshQuery() :
+	m_nav(0),
 	m_tinyNodePool(0),
 	m_nodePool(0),
 	m_openList(0)
@@ -100,10 +152,16 @@
 	free(m_openList);
 }
 
+/// @par 
+///
+/// Must be the first function called after construction, before other
+/// functions are used.
+///
+/// This function can be used multiple times.
 dtStatus dtNavMeshQuery::init(const dtNavMesh* nav, const int maxNodes)
 {
 	m_nav = nav;
-	
+
 	if (!m_nodePool || m_nodePool->getMaxNodes() < maxNodes)
 	{
 		if (m_nodePool)
@@ -114,24 +172,24 @@
 		}
 		m_nodePool = new (malloc(sizeof(dtNodePool))) dtNodePool(maxNodes, dtNextPow2(maxNodes/4));
 		if (!m_nodePool)
-			return DT_FAILURE_OUT_OF_MEMORY;
+			return DT_FAILURE | DT_OUT_OF_MEMORY;
 	}
 	else
 	{
 		m_nodePool->clear();
 	}
-	
+
 	if (!m_tinyNodePool)
 	{
 		m_tinyNodePool = new (malloc(sizeof(dtNodePool))) dtNodePool(64, 32);
 		if (!m_tinyNodePool)
-			return DT_FAILURE_OUT_OF_MEMORY;
+			return DT_FAILURE | DT_OUT_OF_MEMORY;
 	}
 	else
 	{
 		m_tinyNodePool->clear();
 	}
-	
+
 	// TODO: check the open list size too.
 	if (!m_openList || m_openList->getCapacity() < maxNodes)
 	{
@@ -143,32 +201,43 @@
 		}
 		m_openList = new (malloc(sizeof(dtNodeQueue))) dtNodeQueue(maxNodes);
 		if (!m_openList)
-			return DT_FAILURE_OUT_OF_MEMORY;
+			return DT_FAILURE | DT_OUT_OF_MEMORY;
 	}
 	else
 	{
 		m_openList->clear();
 	}
-	
+
 	return DT_SUCCESS;
 }
 
 //////////////////////////////////////////////////////////////////////////////////////////
+
+/// @par
+///
+/// Uses the detail polygons to find the surface height. (Most accurate.)
+///
+/// @p pos does not have to be within the bounds of the polygon or navigation mesh.
+///
+/// See closestPointOnPolyBoundary() for a limited but faster option.
+///
 dtStatus dtNavMeshQuery::closestPointOnPoly(dtPolyRef ref, const float* pos, float* closest) const
 {
 	ASSERT(m_nav);
 	const dtMeshTile* tile = 0;
 	const dtPoly* poly = 0;
-	if (m_nav->getTileAndPolyByRef(ref, &tile, &poly) != DT_SUCCESS)
-		return DT_FAILURE;
-	if (!tile) return DT_FAILURE;
-	if (closestPointOnPolyInTile(tile, poly, pos, closest) != DT_SUCCESS)
-		return DT_FAILURE;
+	if (dtStatusFailed(m_nav->getTileAndPolyByRef(ref, &tile, &poly)))
+		return DT_FAILURE | DT_INVALID_PARAM;
+	if (!tile)
+		return DT_FAILURE | DT_INVALID_PARAM;
+
+	closestPointOnPolyInTile(tile, poly, pos, closest);
+
 	return DT_SUCCESS;
 }
 
-dtStatus dtNavMeshQuery::closestPointOnPolyInTile(const dtMeshTile* tile, const dtPoly* poly,
-												  const float* pos, float* closest) const
+void dtNavMeshQuery::closestPointOnPolyInTile(const dtMeshTile* tile, const dtPoly* poly,
+											  const float* pos, float* closest) const
 {
 	const unsigned int ip = (unsigned int)(poly - tile->polys);
 	const dtPolyDetail* pd = &tile->detailMeshes[ip];
@@ -177,13 +246,13 @@
 	// Test and enable.
 /*
 	// Clamp point to be inside the polygon.
-	float verts[DT_VERTS_PER_POLYGON*3];	
+	float verts[DT_VERTS_PER_POLYGON*3];
 	float edged[DT_VERTS_PER_POLYGON];
 	float edget[DT_VERTS_PER_POLYGON];
 	const int nv = poly->vertCount;
 	for (int i = 0; i < nv; ++i)
 		dtVcopy(&verts[i*3], &tile->verts[poly->verts[i]*3]);
-	
+
 	dtVcopy(closest, pos);
 	if (!dtDistancePtPolyEdgesSqr(pos, verts, nv, edged, edget))
 	{
@@ -239,28 +308,37 @@
 		float pt[3];
 		dtClosestPtPointTriangle(pt, pos, v[0], v[1], v[2]);
 		float d = dtVdistSqr(pos, pt);
-		
+
 		if (d < closestDistSqr)
 		{
 			dtVcopy(closest, pt);
 			closestDistSqr = d;
 		}
 	}
-	
-	return DT_SUCCESS;
 }
 
+/// @par
+///
+/// Much faster than closestPointOnPoly().
+///
+/// If the provided position lies within the polygon's xz-bounds (above or below), 
+/// then @p pos and @p closest will be equal.
+///
+/// The height of @p closest will be the polygon boundary.  The height detail is not used.
+/// 
+/// @p pos does not have to be within the bounds of the polybon or the navigation mesh.
+/// 
 dtStatus dtNavMeshQuery::closestPointOnPolyBoundary(dtPolyRef ref, const float* pos, float* closest) const
 {
 	ASSERT(m_nav);
-	
+
 	const dtMeshTile* tile = 0;
 	const dtPoly* poly = 0;
-	if (m_nav->getTileAndPolyByRef(ref, &tile, &poly) != DT_SUCCESS)
-		return DT_FAILURE;
-	
+	if (dtStatusFailed(m_nav->getTileAndPolyByRef(ref, &tile, &poly)))
+		return DT_FAILURE | DT_INVALID_PARAM;
+
 	// Collect vertices.
-	float verts[DT_VERTS_PER_POLYGON*3];	
+	float verts[DT_VERTS_PER_POLYGON*3];
 	float edged[DT_VERTS_PER_POLYGON];
 	float edget[DT_VERTS_PER_POLYGON];
 	int nv = 0;
@@ -268,8 +346,8 @@
 	{
 		dtVcopy(&verts[nv*3], &tile->verts[poly->verts[i]*3]);
 		nv++;
-	}		
-	
+	}
+
 	bool inside = dtDistancePtPolyEdgesSqr(pos, verts, nv, edged, edget);
 	if (inside)
 	{
@@ -293,20 +371,24 @@
 		const float* vb = &verts[((imin+1)%nv)*3];
 		dtVlerp(closest, va, vb, edget[imin]);
 	}
-	
+
 	return DT_SUCCESS;
 }
 
-
+/// @par
+///
+/// Will return #DT_FAILURE if the provided position is outside the xz-bounds 
+/// of the polygon.
+/// 
 dtStatus dtNavMeshQuery::getPolyHeight(dtPolyRef ref, const float* pos, float* height) const
 {
 	ASSERT(m_nav);
 
 	const dtMeshTile* tile = 0;
 	const dtPoly* poly = 0;
-	if (m_nav->getTileAndPolyByRef(ref, &tile, &poly) != DT_SUCCESS)
-		return DT_FAILURE;
-	
+	if (dtStatusFailed(m_nav->getTileAndPolyByRef(ref, &tile, &poly)))
+		return DT_FAILURE | DT_INVALID_PARAM;
+
 	if (poly->getType() == DT_POLYTYPE_OFFMESH_CONNECTION)
 	{
 		const float* v0 = &tile->verts[poly->verts[0]*3];
@@ -342,10 +424,19 @@
 			}
 		}
 	}
-	
-	return DT_FAILURE;
+
+	return DT_FAILURE | DT_INVALID_PARAM;
 }
 
+/// @par 
+///
+/// @note If the search box does not intersect any polygons the search will 
+/// return #DT_SUCCESS, but @p nearestRef will be zero. So if in doubt, check 
+/// @p nearestRef before using @p nearestPt.
+///
+/// @warning This function is not suitable for large area searches.  If the search
+/// extents overlaps more than 128 polygons it may return an invalid result.
+///
 dtStatus dtNavMeshQuery::findNearestPoly(const float* center, const float* extents,
 										 const dtQueryFilter* filter,
 										 dtPolyRef* nearestRef, float* nearestPt) const
@@ -353,13 +444,16 @@
 	ASSERT(m_nav);
 
 	*nearestRef = 0;
-	
+
 	// Get nearby polygons from proximity grid.
 	dtPolyRef polys[128];
 	int polyCount = 0;
-	if (queryPolygons(center, extents, filter, polys, &polyCount, 128) != DT_SUCCESS)
-		return DT_FAILURE;
-	
+	if (dtStatusFailed(queryPolygons(center, extents, filter, polys, &polyCount, 128)))
+	{
+		PRINTF("dtNavMeshQuery:: queryPolygons failed in findNearestPoly()\n");
+		return DT_FAILURE | DT_INVALID_PARAM;
+	}
+
 	// Find nearest polygon amongst the nearby polygons.
 	dtPolyRef nearest = 0;
 	float nearestDistanceSqr = FLT_MAX;
@@ -367,8 +461,7 @@
 	{
 		dtPolyRef ref = polys[i];
 		float closestPtPoly[3];
-		if (closestPointOnPoly(ref, center, closestPtPoly) != DT_SUCCESS)
-			continue;
+		closestPointOnPoly(ref, center, closestPtPoly);
 		float d = dtVdistSqr(center, closestPtPoly);
 		if (d < nearestDistanceSqr)
 		{
@@ -378,26 +471,34 @@
 			nearest = ref;
 		}
 	}
-	
-	if (nearestRef)
-		*nearestRef = nearest;
-	
-	return DT_SUCCESS;
+
+	if(nearest != 0)
+	{
+		if (nearestRef)
+		{
+			PRINTF("dtNavMeshQuery:: queryPolygons success in findNearestPoly() return %u\n", nearest);
+			*nearestRef = nearest;
+			return DT_SUCCESS;
+		}
+	}
+
+	PRINTF("dtNavMeshQuery:: queryPolygons failure in findNearestPoly()\n");
+	return DT_FAILURE;
 }
 
 dtPolyRef dtNavMeshQuery::findNearestPolyInTile(const dtMeshTile* tile, const float* center, const float* extents,
 												const dtQueryFilter* filter, float* nearestPt) const
 {
 	ASSERT(m_nav);
-	
+
 	float bmin[3], bmax[3];
 	dtVsub(bmin, center, extents);
 	dtVadd(bmax, center, extents);
-	
+
 	// Get nearby polygons from proximity grid.
 	dtPolyRef polys[128];
 	int polyCount = queryPolygonsInTile(tile, bmin, bmax, filter, polys, 128);
-	
+
 	// Find nearest polygon amongst the nearby polygons.
 	dtPolyRef nearest = 0;
 	float nearestDistanceSqr = FLT_MAX;
@@ -406,9 +507,8 @@
 		dtPolyRef ref = polys[i];
 		const dtPoly* poly = &tile->polys[m_nav->decodePolyIdPoly(ref)];
 		float closestPtPoly[3];
-		if (closestPointOnPolyInTile(tile, poly, center, closestPtPoly) != DT_SUCCESS)
-			continue;
-			
+		closestPointOnPolyInTile(tile, poly, center, closestPtPoly);
+
 		float d = dtVdistSqr(center, closestPtPoly);
 		if (d < nearestDistanceSqr)
 		{
@@ -418,7 +518,7 @@
 			nearest = ref;
 		}
 	}
-	
+
 	return nearest;
 }
 
@@ -435,7 +535,7 @@
 		const float* tbmin = tile->header->bmin;
 		const float* tbmax = tile->header->bmax;
 		const float qfac = tile->header->bvQuantFactor;
-		
+
 		// Calculate quantized box
 		unsigned short bmin[3], bmax[3];
 		// dtClamp query box to world box.
@@ -452,7 +552,7 @@
 		bmax[0] = (unsigned short)(qfac * maxx + 1) | 1;
 		bmax[1] = (unsigned short)(qfac * maxy + 1) | 1;
 		bmax[2] = (unsigned short)(qfac * maxz + 1) | 1;
-		
+
 		// Traverse tree
 		const dtPolyRef base = m_nav->getPolyRefBase(tile);
 		int n = 0;
@@ -460,7 +560,7 @@
 		{
 			const bool overlap = dtOverlapQuantBounds(bmin, bmax, node->bmin, node->bmax);
 			const bool isLeafNode = node->i >= 0;
-			
+
 			if (isLeafNode && overlap)
 			{
 				dtPolyRef ref = base | (dtPolyRef)node->i;
@@ -470,7 +570,7 @@
 						polys[n++] = ref;
 				}
 			}
-			
+
 			if (overlap || isLeafNode)
 				node++;
 			else
@@ -479,7 +579,7 @@
 				node += escapeIndex;
 			}
 		}
-		
+
 		return n;
 	}
 	else
@@ -489,8 +589,12 @@
 		const dtPolyRef base = m_nav->getPolyRefBase(tile);
 		for (int i = 0; i < tile->header->polyCount; ++i)
 		{
+			const dtPoly* p = &tile->polys[i];
+			const dtPolyRef ref = base | (dtPolyRef)i;
+			if (!filter->passFilter(ref, tile, p))
+				continue;
+
 			// Calc polygon bounds.
-			dtPoly* p = &tile->polys[i];
 			const float* v = &tile->verts[p->verts[0]*3];
 			dtVcopy(bmin, v);
 			dtVcopy(bmax, v);
@@ -502,53 +606,85 @@
 			}
 			if (dtOverlapBounds(qmin,qmax, bmin,bmax))
 			{
-				const dtPolyRef ref = base | (dtPolyRef)i;
-				if (filter->passFilter(ref, tile, p))
-				{
-					if (n < maxPolys)
-						polys[n++] = ref;
-				}
+				if (n < maxPolys)
+					polys[n++] = ref;
 			}
 		}
 		return n;
 	}
 }
 
+/// @par 
+///
+/// If no polygons are found, the function will return #DT_SUCCESS with a
+/// @p polyCount of zero.
+///
+/// If @p polys is too small to hold the entire result set, then the array will 
+/// be filled to capacity. The method of choosing which polygons from the 
+/// full set are included in the partial result set is undefined.
+///
 dtStatus dtNavMeshQuery::queryPolygons(const float* center, const float* extents,
 									   const dtQueryFilter* filter,
 									   dtPolyRef* polys, int* polyCount, const int maxPolys) const
 {
 	ASSERT(m_nav);
-	
+
 	float bmin[3], bmax[3];
 	dtVsub(bmin, center, extents);
 	dtVadd(bmax, center, extents);
-	
+
 	// Find tiles the query touches.
 	int minx, miny, maxx, maxy;
 	m_nav->calcTileLoc(bmin, &minx, &miny);
 	m_nav->calcTileLoc(bmax, &maxx, &maxy);
 
+	static const int MAX_NEIS = 32;
+	const dtMeshTile* neis[MAX_NEIS];
+
 	int n = 0;
 	for (int y = miny; y <= maxy; ++y)
 	{
 		for (int x = minx; x <= maxx; ++x)
 		{
-			const dtMeshTile* tile = m_nav->getTileAt(x,y);
-			if (!tile) continue;
-			n += queryPolygonsInTile(tile, bmin, bmax, filter, polys+n, maxPolys-n);
-			if (n >= maxPolys)
+			const int nneis = m_nav->getTilesAt(x,y,neis,MAX_NEIS);
+			for (int j = 0; j < nneis; ++j)
 			{
-				*polyCount = n;
-				return DT_SUCCESS;
+				n += queryPolygonsInTile(neis[j], bmin, bmax, filter, polys+n, maxPolys-n);
+				if (n >= maxPolys)
+				{
+					*polyCount = n;
+					PRINTF("dtNavMeshQuery:: queryPolygons() failure return %u\n", n);
+					return DT_SUCCESS | DT_BUFFER_TOO_SMALL;
+				}
 			}
 		}
 	}
-	*polyCount = n;
-	
-	return DT_SUCCESS;
+
+	if(n != 0)
+	{
+		if (polyCount)
+		{
+			PRINTF("dtNavMeshQuery:: success in queryPolygons() return %u\n", n);
+			*polyCount = n;
+			return DT_SUCCESS;
+		}
+	}
+
+	PRINTF("dtNavMeshQuery:: queryPolygons() failure return %u\n", n);
+	return DT_FAILURE;
 }
 
+/// @par
+///
+/// If the end polygon cannot be reached through the navigation graph,
+/// the last polygon in the path will be the nearest the end polygon.
+///
+/// If the path array is to small to hold the full result, it will be filled as 
+/// far as possible from the start polygon toward the end polygon.
+///
+/// The start and end positions are used to calculate traversal costs. 
+/// (The y-values impact the result.)
+///
 dtStatus dtNavMeshQuery::findPath(dtPolyRef startRef, dtPolyRef endRef,
 								  const float* startPos, const float* endPos,
 								  const dtQueryFilter* filter,
@@ -557,29 +693,29 @@
 	ASSERT(m_nav);
 	ASSERT(m_nodePool);
 	ASSERT(m_openList);
-	
+
 	*pathCount = 0;
-	
+
 	if (!startRef || !endRef)
-		return DT_FAILURE;
-	
+		return DT_FAILURE | DT_INVALID_PARAM;
+
 	if (!maxPath)
-		return DT_FAILURE;
-	
+		return DT_FAILURE | DT_INVALID_PARAM;
+
 	// Validate input
 	if (!m_nav->isValidPolyRef(startRef) || !m_nav->isValidPolyRef(endRef))
-		return DT_FAILURE;
-	
+		return DT_FAILURE | DT_INVALID_PARAM;
+
 	if (startRef == endRef)
 	{
 		path[0] = startRef;
 		*pathCount = 1;
 		return DT_SUCCESS;
 	}
-	
+
 	m_nodePool->clear();
 	m_openList->clear();
-	
+
 	dtNode* startNode = m_nodePool->getNode(startRef);
 	dtVcopy(startNode->pos, startPos);
 	startNode->pidx = 0;
@@ -588,31 +724,33 @@
 	startNode->id = startRef;
 	startNode->flags = DT_NODE_OPEN;
 	m_openList->push(startNode);
-	
+
 	dtNode* lastBestNode = startNode;
 	float lastBestNodeCost = startNode->total;
-	
+
+	dtStatus status = DT_SUCCESS;
+
 	while (!m_openList->empty())
 	{
 		// Remove node from open list and put it in closed list.
 		dtNode* bestNode = m_openList->pop();
 		bestNode->flags &= ~DT_NODE_OPEN;
 		bestNode->flags |= DT_NODE_CLOSED;
-		
+
 		// Reached the goal, stop searching.
 		if (bestNode->id == endRef)
 		{
 			lastBestNode = bestNode;
 			break;
 		}
-		
+
 		// Get current poly and tile.
 		// The API input has been cheked already, skip checking internal data.
 		const dtPolyRef bestRef = bestNode->id;
 		const dtMeshTile* bestTile = 0;
 		const dtPoly* bestPoly = 0;
 		m_nav->getTileAndPolyByRefUnsafe(bestRef, &bestTile, &bestPoly);
-		
+
 		// Get parent poly and tile.
 		dtPolyRef parentRef = 0;
 		const dtMeshTile* parentTile = 0;
@@ -621,28 +759,31 @@
 			parentRef = m_nodePool->getNodeAtIdx(bestNode->pidx)->id;
 		if (parentRef)
 			m_nav->getTileAndPolyByRefUnsafe(parentRef, &parentTile, &parentPoly);
-		
+
 		for (unsigned int i = bestPoly->firstLink; i != DT_NULL_LINK; i = bestTile->links[i].next)
 		{
 			dtPolyRef neighbourRef = bestTile->links[i].ref;
-			
+
 			// Skip invalid ids and do not expand back to where we came from.
 			if (!neighbourRef || neighbourRef == parentRef)
 				continue;
-			
+
 			// Get neighbour poly and tile.
 			// The API input has been cheked already, skip checking internal data.
 			const dtMeshTile* neighbourTile = 0;
 			const dtPoly* neighbourPoly = 0;
-			m_nav->getTileAndPolyByRefUnsafe(neighbourRef, &neighbourTile, &neighbourPoly);			
-			
+			m_nav->getTileAndPolyByRefUnsafe(neighbourRef, &neighbourTile, &neighbourPoly);
+
 			if (!filter->passFilter(neighbourRef, neighbourTile, neighbourPoly))
 				continue;
 
 			dtNode* neighbourNode = m_nodePool->getNode(neighbourRef);
 			if (!neighbourNode)
+			{
+				status |= DT_OUT_OF_NODES;
 				continue;
-			
+			}
+
 			// If the node is visited the first time, calculate node position.
 			if (neighbourNode->flags == 0)
 			{
@@ -683,16 +824,21 @@
 			}
 
 			const float total = cost + heuristic;
-			if(total >= neighbourNode->total) // The new result is worse!
-				if (neighbourNode->flags & DT_NODE_OPEN || neighbourNode->flags & DT_NODE_CLOSED)
-					continue; // The node is already in open list or visited and processed, skip.
 
+			// The node is already in open list and the new result is worse, skip.
+			if ((neighbourNode->flags & DT_NODE_OPEN) && total >= neighbourNode->total)
+				continue;
+			// The node is already visited and process, and the new result is worse, skip.
+			if ((neighbourNode->flags & DT_NODE_CLOSED) && total >= neighbourNode->total)
+				continue;
+
 			// Add or update the node.
 			neighbourNode->pidx = m_nodePool->getNodeIdx(bestNode);
 			neighbourNode->id = neighbourRef;
 			neighbourNode->flags &= ~DT_NODE_CLOSED;
 			neighbourNode->cost = cost;
 			neighbourNode->total = total;
+
 			if (neighbourNode->flags & DT_NODE_OPEN)
 			{
 				// Already in open, update node location.
@@ -714,6 +860,9 @@
 		}
 	}
 
+	if (lastBestNode->id != endRef)
+		status |= DT_PARTIAL_RESULT;
+
 	// Reverse the path.
 	dtNode* prev = 0;
 	dtNode* node = lastBestNode;
@@ -725,22 +874,35 @@
 		node = next;
 	}
 	while (node);
-	
+
 	// Store path
 	node = prev;
 	int n = 0;
 	do
 	{
 		path[n++] = node->id;
+		if (n >= maxPath)
+		{
+			status |= DT_BUFFER_TOO_SMALL;
+			break;
+		}
 		node = m_nodePool->getNodeAtIdx(node->pidx);
 	}
-	while (node && n < maxPath);
-	
+	while (node);
+
 	*pathCount = n;
-	
-	return DT_SUCCESS;
+
+	return status;
 }
 
+/// @par
+///
+/// @warning Calling any non-slice methods before calling finalizeSlicedFindPath() 
+/// or finalizeSlicedFindPathPartial() may result in corrupted data!
+///
+/// The @p filter pointer is stored and used for the duration of the sliced
+/// path query.
+///
 dtStatus dtNavMeshQuery::initSlicedFindPath(dtPolyRef startRef, dtPolyRef endRef,
 											const float* startPos, const float* endPos,
 											const dtQueryFilter* filter)
@@ -757,23 +919,23 @@
 	dtVcopy(m_query.startPos, startPos);
 	dtVcopy(m_query.endPos, endPos);
 	m_query.filter = filter;
-	
+
 	if (!startRef || !endRef)
-		return DT_FAILURE;
-	
+		return DT_FAILURE | DT_INVALID_PARAM;
+
 	// Validate input
 	if (!m_nav->isValidPolyRef(startRef) || !m_nav->isValidPolyRef(endRef))
-		return DT_FAILURE;
+		return DT_FAILURE | DT_INVALID_PARAM;
 
 	if (startRef == endRef)
 	{
 		m_query.status = DT_SUCCESS;
 		return DT_SUCCESS;
 	}
-	
+
 	m_nodePool->clear();
 	m_openList->clear();
-	
+
 	dtNode* startNode = m_nodePool->getNode(startRef);
 	dtVcopy(startNode->pos, startPos);
 	startNode->pidx = 0;
@@ -782,17 +944,17 @@
 	startNode->id = startRef;
 	startNode->flags = DT_NODE_OPEN;
 	m_openList->push(startNode);
-	
+
 	m_query.status = DT_IN_PROGRESS;
 	m_query.lastBestNode = startNode;
 	m_query.lastBestNodeCost = startNode->total;
-	
+
 	return m_query.status;
 }
-	
-dtStatus dtNavMeshQuery::updateSlicedFindPath(const int maxIter)
+
+dtStatus dtNavMeshQuery::updateSlicedFindPath(const int maxIter, int* doneIters)
 {
-	if (m_query.status!= DT_IN_PROGRESS)
+	if (!dtStatusInProgress(m_query.status))
 		return m_query.status;
 
 	// Make sure the request is still valid.
@@ -801,37 +963,42 @@
 		m_query.status = DT_FAILURE;
 		return DT_FAILURE;
 	}
-		
+
 	int iter = 0;
 	while (iter < maxIter && !m_openList->empty())
 	{
 		iter++;
-		
+
 		// Remove node from open list and put it in closed list.
 		dtNode* bestNode = m_openList->pop();
 		bestNode->flags &= ~DT_NODE_OPEN;
 		bestNode->flags |= DT_NODE_CLOSED;
-		
+
 		// Reached the goal, stop searching.
 		if (bestNode->id == m_query.endRef)
 		{
 			m_query.lastBestNode = bestNode;
-			m_query.status = DT_SUCCESS;
+			const dtStatus details = m_query.status & DT_STATUS_DETAIL_MASK;
+			m_query.status = DT_SUCCESS | details;
+			if (doneIters)
+				*doneIters = iter;
 			return m_query.status;
 		}
-		
+
 		// Get current poly and tile.
 		// The API input has been cheked already, skip checking internal data.
 		const dtPolyRef bestRef = bestNode->id;
 		const dtMeshTile* bestTile = 0;
 		const dtPoly* bestPoly = 0;
-		if (m_nav->getTileAndPolyByRef(bestRef, &bestTile, &bestPoly) != DT_SUCCESS)
+		if (dtStatusFailed(m_nav->getTileAndPolyByRef(bestRef, &bestTile, &bestPoly)))
 		{
 			// The polygon has disappeared during the sliced query, fail.
 			m_query.status = DT_FAILURE;
+			if (doneIters)
+				*doneIters = iter;
 			return m_query.status;
 		}
-		
+
 		// Get parent poly and tile.
 		dtPolyRef parentRef = 0;
 		const dtMeshTile* parentTile = 0;
@@ -840,35 +1007,40 @@
 			parentRef = m_nodePool->getNodeAtIdx(bestNode->pidx)->id;
 		if (parentRef)
 		{
-			if (m_nav->getTileAndPolyByRef(parentRef, &parentTile, &parentPoly) != DT_SUCCESS)
+			if (dtStatusFailed(m_nav->getTileAndPolyByRef(parentRef, &parentTile, &parentPoly)))
 			{
 				// The polygon has disappeared during the sliced query, fail.
 				m_query.status = DT_FAILURE;
+				if (doneIters)
+					*doneIters = iter;
 				return m_query.status;
 			}
 		}
-		
+
 		for (unsigned int i = bestPoly->firstLink; i != DT_NULL_LINK; i = bestTile->links[i].next)
 		{
 			dtPolyRef neighbourRef = bestTile->links[i].ref;
-			
+
 			// Skip invalid ids and do not expand back to where we came from.
 			if (!neighbourRef || neighbourRef == parentRef)
 				continue;
-			
+
 			// Get neighbour poly and tile.
 			// The API input has been cheked already, skip checking internal data.
 			const dtMeshTile* neighbourTile = 0;
 			const dtPoly* neighbourPoly = 0;
-			m_nav->getTileAndPolyByRefUnsafe(neighbourRef, &neighbourTile, &neighbourPoly);			
-			
+			m_nav->getTileAndPolyByRefUnsafe(neighbourRef, &neighbourTile, &neighbourPoly);
+
 			if (!m_query.filter->passFilter(neighbourRef, neighbourTile, neighbourPoly))
 				continue;
-			
+
 			dtNode* neighbourNode = m_nodePool->getNode(neighbourRef);
 			if (!neighbourNode)
+			{
+				m_query.status |= DT_OUT_OF_NODES;
 				continue;
-			
+			}
+
 			// If the node is visited the first time, calculate node position.
 			if (neighbourNode->flags == 0)
 			{
@@ -876,11 +1048,11 @@
 								neighbourRef, neighbourPoly, neighbourTile,
 								neighbourNode->pos);
 			}
-			
+
 			// Calculate cost and heuristic.
 			float cost = 0;
 			float heuristic = 0;
-			
+
 			// Special case for last node.
 			if (neighbourRef == m_query.endRef)
 			{
@@ -893,7 +1065,7 @@
 															  bestRef, bestTile, bestPoly,
 															  neighbourRef, neighbourTile, neighbourPoly,
 															  0, 0, 0);
-				
+
 				cost = bestNode->cost + curCost + endCost;
 				heuristic = 0;
 			}
@@ -907,23 +1079,23 @@
 				cost = bestNode->cost + curCost;
 				heuristic = dtVdist(neighbourNode->pos, m_query.endPos)*H_SCALE;
 			}
-			
+
 			const float total = cost + heuristic;
-			
+
 			// The node is already in open list and the new result is worse, skip.
 			if ((neighbourNode->flags & DT_NODE_OPEN) && total >= neighbourNode->total)
 				continue;
 			// The node is already visited and process, and the new result is worse, skip.
 			if ((neighbourNode->flags & DT_NODE_CLOSED) && total >= neighbourNode->total)
 				continue;
-			
+
 			// Add or update the node.
 			neighbourNode->pidx = m_nodePool->getNodeIdx(bestNode);
 			neighbourNode->id = neighbourRef;
 			neighbourNode->flags &= ~DT_NODE_CLOSED;
 			neighbourNode->cost = cost;
 			neighbourNode->total = total;
-			
+
 			if (neighbourNode->flags & DT_NODE_OPEN)
 			{
 				// Already in open, update node location.
@@ -935,7 +1107,7 @@
 				neighbourNode->flags |= DT_NODE_OPEN;
 				m_openList->push(neighbourNode);
 			}
-			
+
 			// Update nearest node to target so far.
 			if (heuristic < m_query.lastBestNodeCost)
 			{
@@ -944,19 +1116,25 @@
 			}
 		}
 	}
-	
+
 	// Exhausted all nodes, but could not find path.
 	if (m_openList->empty())
-		m_query.status = DT_SUCCESS;
+	{
+		const dtStatus details = m_query.status & DT_STATUS_DETAIL_MASK;
+		m_query.status = DT_SUCCESS | details;
+	}
 
+	if (doneIters)
+		*doneIters = iter;
+
 	return m_query.status;
 }
 
 dtStatus dtNavMeshQuery::finalizeSlicedFindPath(dtPolyRef* path, int* pathCount, const int maxPath)
 {
 	*pathCount = 0;
-	
-	if (m_query.status != DT_SUCCESS)
+
+	if (dtStatusFailed(m_query.status))
 	{
 		// Reset query.
 		memset(&m_query, 0, sizeof(dtQueryData));
@@ -974,6 +1152,10 @@
 	{
 		// Reverse the path.
 		ASSERT(m_query.lastBestNode);
+
+		if (m_query.lastBestNode->id != m_query.endRef)
+			m_query.status |= DT_PARTIAL_RESULT;
+
 		dtNode* prev = 0;
 		dtNode* node = m_query.lastBestNode;
 		do
@@ -984,44 +1166,51 @@
 			node = next;
 		}
 		while (node);
-		
+
 		// Store path
 		node = prev;
 		do
 		{
 			path[n++] = node->id;
+			if (n >= maxPath)
+			{
+				m_query.status |= DT_BUFFER_TOO_SMALL;
+				break;
+			}
 			node = m_nodePool->getNodeAtIdx(node->pidx);
 		}
-		while (node && n < maxPath);
+		while (node);
 	}
-	
+
+	const dtStatus details = m_query.status & DT_STATUS_DETAIL_MASK;
+
 	// Reset query.
 	memset(&m_query, 0, sizeof(dtQueryData));
-	
+
 	*pathCount = n;
-	
-	return DT_SUCCESS;
+
+	return DT_SUCCESS | details;
 }
 
 dtStatus dtNavMeshQuery::finalizeSlicedFindPathPartial(const dtPolyRef* existing, const int existingSize,
 													   dtPolyRef* path, int* pathCount, const int maxPath)
 {
 	*pathCount = 0;
-	
+
 	if (existingSize == 0)
 	{
 		return DT_FAILURE;
 	}
-	
-	if (m_query.status != DT_SUCCESS && m_query.status != DT_IN_PROGRESS)
+
+	if (dtStatusFailed(m_query.status))
 	{
 		// Reset query.
 		memset(&m_query, 0, sizeof(dtQueryData));
 		return DT_FAILURE;
 	}
-	
+
 	int n = 0;
-	
+
 	if (m_query.startRef == m_query.endRef)
 	{
 		// Special case: the search starts and ends at same poly.
@@ -1038,12 +1227,12 @@
 			if (node)
 				break;
 		}
-		
+
 		if (!node)
 		{
 			return DT_FAILURE;
 		}
-		
+
 		// Reverse the path.
 		do
 		{
@@ -1053,48 +1242,71 @@
 			node = next;
 		}
 		while (node);
-		
+
 		// Store path
 		node = prev;
 		do
 		{
 			path[n++] = node->id;
+			if (n >= maxPath)
+			{
+				m_query.status |= DT_BUFFER_TOO_SMALL;
+				break;
+			}
 			node = m_nodePool->getNodeAtIdx(node->pidx);
 		}
-		while (node && n < maxPath);
+		while (node);
 	}
-	
+
+	const dtStatus details = m_query.status & DT_STATUS_DETAIL_MASK;
+
 	// Reset query.
 	memset(&m_query, 0, sizeof(dtQueryData));
-	
+
 	*pathCount = n;
-	
-	return DT_SUCCESS;
+
+	return DT_SUCCESS | details;
 }
 
-
+/// @par
+/// 
+/// This method peforms what is often called 'string pulling'.
+///
+/// The start position is clamped to the first polygon in the path, and the 
+/// end position is clamped to the last. So the start and end positions should 
+/// normally be within or very near the first and last polygons respectively.
+///
+/// The returned polygon references represent the reference id of the polygon 
+/// that is entered at the associated path position. The reference id associated 
+/// with the end point will always be zero.  This allows, for example, matching 
+/// off-mesh link points to their representative polygons.
+///
+/// If the provided result buffers are too small for the entire result set, 
+/// they will be filled as far as possible from the start toward the end 
+/// position.
+///
 dtStatus dtNavMeshQuery::findStraightPath(const float* startPos, const float* endPos,
 										  const dtPolyRef* path, const int pathSize,
 										  float* straightPath, unsigned char* straightPathFlags, dtPolyRef* straightPathRefs,
 										  int* straightPathCount, const int maxStraightPath) const
 {
 	ASSERT(m_nav);
-	
+
 	*straightPathCount = 0;
-	
+
 	if (!maxStraightPath)
-		return DT_FAILURE;
-	
+		return DT_FAILURE | DT_INVALID_PARAM;
+
 	if (!path[0])
-		return DT_FAILURE;
-	
+		return DT_FAILURE | DT_INVALID_PARAM;
+
 	int n = 0;
-	
+
 	// TODO: Should this be callers responsibility?
 	float closestStartPos[3];
-	if (closestPointOnPolyBoundary(path[0], startPos, closestStartPos) != DT_SUCCESS)
-		return DT_FAILURE;
-	
+	if (dtStatusFailed(closestPointOnPolyBoundary(path[0], startPos, closestStartPos)))
+		return DT_FAILURE | DT_INVALID_PARAM;
+
 	// Add start point.
 	dtVcopy(&straightPath[n*3], closestStartPos);
 	if (straightPathFlags)
@@ -1105,12 +1317,12 @@
 	if (n >= maxStraightPath)
 	{
 		*straightPathCount = n;
-		return DT_SUCCESS;
+		return DT_SUCCESS | DT_BUFFER_TOO_SMALL;
 	}
-	
+
 	float closestEndPos[3];
-	if (closestPointOnPolyBoundary(path[pathSize-1], endPos, closestEndPos) != DT_SUCCESS)
-		return DT_FAILURE;
+	if (dtStatusFailed(closestPointOnPolyBoundary(path[pathSize-1], endPos, closestEndPos)))
+		return DT_FAILURE | DT_INVALID_PARAM;
 
 	if (pathSize > 1)
 	{
@@ -1136,11 +1348,17 @@
 			if (i+1 < pathSize)
 			{
 				// Next portal.
-				if (getPortalPoints(path[i], path[i+1], left, right, fromType, toType) != DT_SUCCESS)
+				if (dtStatusFailed(getPortalPoints(path[i], path[i+1], left, right, fromType, toType)))
 				{
-					if (closestPointOnPolyBoundary(path[i], endPos, closestEndPos) != DT_SUCCESS)
-						return DT_FAILURE;
+					// Failed to get portal points, in practice this means that path[i+1] is invalid polygon.
+					// Clamp the end point to path[i], and return the path so far.
 
+					if (dtStatusFailed(closestPointOnPolyBoundary(path[i], endPos, closestEndPos)))
+					{
+						// This should only happen when the first polygon is invalid.
+						return DT_FAILURE | DT_INVALID_PARAM;
+					}
+
 					dtVcopy(&straightPath[n*3], closestEndPos);
 					if (straightPathFlags)
 						straightPathFlags[n] = 0;
@@ -1148,7 +1366,9 @@
 						straightPathRefs[n] = path[i];
 					n++;
 
-					return DT_SUCCESS;
+					*straightPathCount = n;
+
+					return DT_SUCCESS | DT_PARTIAL_RESULT | ((n >= maxStraightPath) ? DT_BUFFER_TOO_SMALL : 0);
 				}
 
 				// If starting really close the portal, advance.
@@ -1203,7 +1423,7 @@
 						if (flags == DT_STRAIGHTPATH_END || n >= maxStraightPath)
 						{
 							*straightPathCount = n;
-							return DT_SUCCESS;
+							return DT_SUCCESS | ((n >= maxStraightPath) ? DT_BUFFER_TOO_SMALL : 0);
 						}
 					}
 					else
@@ -1262,7 +1482,7 @@
 						if (flags == DT_STRAIGHTPATH_END || n >= maxStraightPath)
 						{
 							*straightPathCount = n;
-							return DT_SUCCESS;
+							return DT_SUCCESS | ((n >= maxStraightPath) ? DT_BUFFER_TOO_SMALL : 0);
 						}
 					}
 					else
@@ -1281,6 +1501,7 @@
 
 					// Restart
 					i = apexIndex;
+
 					continue;
 				}
 			}
@@ -1303,9 +1524,30 @@
 	}
 
 	*straightPathCount = n;
-	return DT_SUCCESS;
+
+	return DT_SUCCESS | ((n >= maxStraightPath) ? DT_BUFFER_TOO_SMALL : 0);
 }
 
+/// @par
+///
+/// This method is optimized for small delta movement and a small number of 
+/// polygons. If used for too great a distance, the result set will form an 
+/// incomplete path.
+///
+/// @p resultPos will equal the @p endPos if the end is reached. 
+/// Otherwise the closest reachable position will be returned.
+/// 
+/// @p resultPos is not projected onto the surface of the navigation 
+/// mesh. Use #getPolyHeight if this is needed.
+///
+/// This method treats the end position in the same manner as 
+/// the #raycast method. (As a 2D point.) See that method's documentation 
+/// for details.
+/// 
+/// If the @p visited array is too small to hold the entire result set, it will 
+/// be filled as far as possible from the start position toward the end 
+/// position.
+///
 dtStatus dtNavMeshQuery::moveAlongSurface(dtPolyRef startRef, const float* startPos, const float* endPos,
 										  const dtQueryFilter* filter,
 										  float* resultPos, dtPolyRef* visited, int* visitedCount, const int maxVisitedSize) const
@@ -1314,17 +1556,21 @@
 	ASSERT(m_tinyNodePool);
 
 	*visitedCount = 0;
-	
+
 	// Validate input
-	if (!startRef) return DT_FAILURE;
-	if (!m_nav->isValidPolyRef(startRef)) return DT_FAILURE;
-	
+	if (!startRef)
+		return DT_FAILURE | DT_INVALID_PARAM;
+	if (!m_nav->isValidPolyRef(startRef))
+		return DT_FAILURE | DT_INVALID_PARAM;
+
+	dtStatus status = DT_SUCCESS;
+
 	static const int MAX_STACK = 48;
 	dtNode* stack[MAX_STACK];
 	int nstack = 0;
-	
+
 	m_tinyNodePool->clear();
-	
+
 	dtNode* startNode = m_tinyNodePool->getNode(startRef);
 	startNode->pidx = 0;
 	startNode->cost = 0;
@@ -1332,19 +1578,19 @@
 	startNode->id = startRef;
 	startNode->flags = DT_NODE_CLOSED;
 	stack[nstack++] = startNode;
-	
+
 	float bestPos[3];
 	float bestDist = FLT_MAX;
 	dtNode* bestNode = 0;
 	dtVcopy(bestPos, startPos);
-	
+
 	// Search constraints
 	float searchPos[3], searchRadSqr;
 	dtVlerp(searchPos, startPos, endPos, 0.5f);
 	searchRadSqr = dtSqr(dtVdist(startPos, endPos)/2.0f + 0.001f);
-	
+
 	float verts[DT_VERTS_PER_POLYGON*3];
-	
+
 	while (nstack)
 	{
 		// Pop front.
@@ -1352,19 +1598,19 @@
 		for (int i = 0; i < nstack-1; ++i)
 			stack[i] = stack[i+1];
 		nstack--;
-		
+
 		// Get poly and tile.
 		// The API input has been cheked already, skip checking internal data.
 		const dtPolyRef curRef = curNode->id;
 		const dtMeshTile* curTile = 0;
 		const dtPoly* curPoly = 0;
-		m_nav->getTileAndPolyByRefUnsafe(curRef, &curTile, &curPoly);			
-		
+		m_nav->getTileAndPolyByRefUnsafe(curRef, &curTile, &curPoly);
+
 		// Collect vertices.
 		const int nverts = curPoly->vertCount;
 		for (int i = 0; i < nverts; ++i)
 			dtVcopy(&verts[i*3], &curTile->verts[curPoly->verts[i]*3]);
-		
+
 		// If target is inside the poly, stop search.
 		if (dtPointInPolygon(endPos, verts, nverts))
 		{
@@ -1372,7 +1618,7 @@
 			dtVcopy(bestPos, endPos);
 			break;
 		}
-		
+
 		// Find wall edges and find nearest point inside the walls.
 		for (int i = 0, j = (int)curPoly->vertCount-1; i < (int)curPoly->vertCount; j = i++)
 		{
@@ -1380,7 +1626,7 @@
 			static const int MAX_NEIS = 8;
 			int nneis = 0;
 			dtPolyRef neis[MAX_NEIS];
-			
+
 			if (curPoly->neis[j] & DT_EXT_LINK)
 			{
 				// Tile border.
@@ -1413,7 +1659,7 @@
 					neis[nneis++] = ref;
 				}
 			}
-			
+
 			if (!nneis)
 			{
 				// Wall edge, calc distance.
@@ -1440,7 +1686,7 @@
 					// Skip if already visited.
 					if (neighbourNode->flags & DT_NODE_CLOSED)
 						continue;
-					
+
 					// Skip the link if it is too far from search constraint.
 					// TODO: Maybe should use getPortalPoints(), but this one is way faster.
 					const float* vj = &verts[j*3];
@@ -1449,7 +1695,7 @@
 					float distSqr = dtDistancePtSegSqr2D(searchPos, vj, vi, tseg);
 					if (distSqr > searchRadSqr)
 						continue;
-					
+
 					// Mark as the node as visited and push to queue.
 					if (nstack < MAX_STACK)
 					{
@@ -1461,7 +1707,7 @@
 			}
 		}
 	}
-	
+
 	int n = 0;
 	if (bestNode)
 	{
@@ -1476,22 +1722,27 @@
 			node = next;
 		}
 		while (node);
-		
+
 		// Store result
 		node = prev;
 		do
 		{
 			visited[n++] = node->id;
+			if (n >= maxVisitedSize)
+			{
+				status |= DT_BUFFER_TOO_SMALL;
+				break;
+			}
 			node = m_tinyNodePool->getNodeAtIdx(node->pidx);
 		}
-		while (node && n < maxVisitedSize);
+		while (node);
 	}
-	
+
 	dtVcopy(resultPos, bestPos);
-	
+
 	*visitedCount = n;
-	
-	return DT_SUCCESS;
+
+	return status;
 }
 
 
@@ -1499,19 +1750,19 @@
 										 unsigned char& fromType, unsigned char& toType) const
 {
 	ASSERT(m_nav);
-	
+
 	const dtMeshTile* fromTile = 0;
 	const dtPoly* fromPoly = 0;
-	if (m_nav->getTileAndPolyByRef(from, &fromTile, &fromPoly) != DT_SUCCESS)
-		return DT_FAILURE;
+	if (dtStatusFailed(m_nav->getTileAndPolyByRef(from, &fromTile, &fromPoly)))
+		return DT_FAILURE | DT_INVALID_PARAM;
 	fromType = fromPoly->getType();
 
 	const dtMeshTile* toTile = 0;
 	const dtPoly* toPoly = 0;
-	if (m_nav->getTileAndPolyByRef(to, &toTile, &toPoly) != DT_SUCCESS)
-		return DT_FAILURE;
+	if (dtStatusFailed(m_nav->getTileAndPolyByRef(to, &toTile, &toPoly)))
+		return DT_FAILURE | DT_INVALID_PARAM;
 	toType = toPoly->getType();
-		
+
 	return getPortalPoints(from, fromPoly, fromTile, to, toPoly, toTile, left, right);
 }
 
@@ -1531,8 +1782,8 @@
 		}
 	}
 	if (!link)
-		return DT_FAILURE;
-	
+		return DT_FAILURE | DT_INVALID_PARAM;
+
 	// Handle off-mesh connections.
 	if (fromPoly->getType() == DT_POLYTYPE_OFFMESH_CONNECTION)
 	{
@@ -1547,9 +1798,9 @@
 				return DT_SUCCESS;
 			}
 		}
-		return DT_FAILURE;
+		return DT_FAILURE | DT_INVALID_PARAM;
 	}
-	
+
 	if (toPoly->getType() == DT_POLYTYPE_OFFMESH_CONNECTION)
 	{
 		for (unsigned int i = toPoly->firstLink; i != DT_NULL_LINK; i = toTile->links[i].next)
@@ -1562,15 +1813,15 @@
 				return DT_SUCCESS;
 			}
 		}
-		return DT_FAILURE;
+		return DT_FAILURE | DT_INVALID_PARAM;
 	}
-	
+
 	// Find portal vertices.
 	const int v0 = fromPoly->verts[link->edge];
 	const int v1 = fromPoly->verts[(link->edge+1) % (int)fromPoly->vertCount];
 	dtVcopy(left, &fromTile->verts[v0*3]);
 	dtVcopy(right, &fromTile->verts[v1*3]);
-	
+
 	// If the link is at tile boundary, dtClamp the vertices to
 	// the link width.
 	if (link->side != 0xff)
@@ -1585,7 +1836,7 @@
 			dtVlerp(right, &fromTile->verts[v0*3], &fromTile->verts[v1*3], tmax);
 		}
 	}
-	
+
 	return DT_SUCCESS;
 }
 
@@ -1594,7 +1845,8 @@
 {
 	float left[3], right[3];
 	unsigned char fromType, toType;
-	if (!getPortalPoints(from, to, left,right, fromType, toType)) return DT_FAILURE;
+	if (dtStatusFailed(getPortalPoints(from, to, left,right, fromType, toType)))
+		return DT_FAILURE | DT_INVALID_PARAM;
 	mid[0] = (left[0]+right[0])*0.5f;
 	mid[1] = (left[1]+right[1])*0.5f;
 	mid[2] = (left[2]+right[2])*0.5f;
@@ -1606,53 +1858,93 @@
 										 float* mid) const
 {
 	float left[3], right[3];
-	if (getPortalPoints(from, fromPoly, fromTile, to, toPoly, toTile, left, right) != DT_SUCCESS)
-		return DT_FAILURE;
+	if (dtStatusFailed(getPortalPoints(from, fromPoly, fromTile, to, toPoly, toTile, left, right)))
+		return DT_FAILURE | DT_INVALID_PARAM;
 	mid[0] = (left[0]+right[0])*0.5f;
 	mid[1] = (left[1]+right[1])*0.5f;
 	mid[2] = (left[2]+right[2])*0.5f;
 	return DT_SUCCESS;
 }
 
+/// @par
+///
+/// This method is meant to be used for quick, short distance checks.
+///
+/// If the path array is too small to hold the result, it will be filled as 
+/// far as possible from the start postion toward the end position.
+///
+/// <b>Using the Hit Parameter (t)</b>
+/// 
+/// If the hit parameter is a very high value (FLT_MAX), then the ray has hit 
+/// the end position. In this case the path represents a valid corridor to the 
+/// end position and the value of @p hitNormal is undefined.
+///
+/// If the hit parameter is zero, then the start position is on the wall that 
+/// was hit and the value of @p hitNormal is undefined.
+///
+/// If 0 < t < 1.0 then the following applies:
+///
+/// @code
+/// distanceToHitBorder = distanceToEndPosition * t
+/// hitPoint = startPos + (endPos - startPos) * t
+/// @endcode
+///
+/// <b>Use Case Restriction</b>
+///
+/// The raycast ignores the y-value of the end position. (2D check.) This 
+/// places significant limits on how it can be used. For example:
+///
+/// Consider a scene where there is a main floor with a second floor balcony 
+/// that hangs over the main floor. So the first floor mesh extends below the 
+/// balcony mesh. The start position is somewhere on the first floor. The end 
+/// position is on the balcony.
+///
+/// The raycast will search toward the end position along the first floor mesh. 
+/// If it reaches the end position's xz-coordinates it will indicate FLT_MAX
+/// (no wall hit), meaning it reached the end position. This is one example of why
+/// this method is meant for short distance checks.
+///
 dtStatus dtNavMeshQuery::raycast(dtPolyRef startRef, const float* startPos, const float* endPos,
 								 const dtQueryFilter* filter,
 								 float* t, float* hitNormal, dtPolyRef* path, int* pathCount, const int maxPath) const
 {
 	ASSERT(m_nav);
-	
+
 	*t = 0;
 	if (pathCount)
 		*pathCount = 0;
-	
+
 	// Validate input
 	if (!startRef || !m_nav->isValidPolyRef(startRef))
-		return DT_FAILURE;
-	
+		return DT_FAILURE | DT_INVALID_PARAM;
+
 	dtPolyRef curRef = startRef;
-	float verts[DT_VERTS_PER_POLYGON*3];	
+	float verts[DT_VERTS_PER_POLYGON*3];
 	int n = 0;
-	
+
 	hitNormal[0] = 0;
 	hitNormal[1] = 0;
 	hitNormal[2] = 0;
-	
+
+	dtStatus status = DT_SUCCESS;
+
 	while (curRef)
 	{
 		// Cast ray against current polygon.
-		
+
 		// The API input has been cheked already, skip checking internal data.
 		const dtMeshTile* tile = 0;
 		const dtPoly* poly = 0;
 		m_nav->getTileAndPolyByRefUnsafe(curRef, &tile, &poly);
-		
+
 		// Collect vertices.
 		int nv = 0;
 		for (int i = 0; i < (int)poly->vertCount; ++i)
 		{
 			dtVcopy(&verts[nv*3], &tile->verts[poly->verts[i]*3]);
 			nv++;
-		}		
-		
+		}
+
 		float tmin, tmax;
 		int segMin, segMax;
 		if (!dtIntersectSegmentPoly2D(startPos, endPos, verts, nv, tmin, tmax, segMin, segMax))
@@ -1660,71 +1952,73 @@
 			// Could not hit the polygon, keep the old t and report hit.
 			if (pathCount)
 				*pathCount = n;
-			return DT_SUCCESS;
+			return status;
 		}
 		// Keep track of furthest t so far.
 		if (tmax > *t)
 			*t = tmax;
-		
+
 		// Store visited polygons.
 		if (n < maxPath)
 			path[n++] = curRef;
-		
+		else
+			status |= DT_BUFFER_TOO_SMALL;
+
 		// Ray end is completely inside the polygon.
 		if (segMax == -1)
 		{
 			*t = FLT_MAX;
 			if (pathCount)
 				*pathCount = n;
-			return DT_SUCCESS;
+			return status;
 		}
-		
+
 		// Follow neighbours.
 		dtPolyRef nextRef = 0;
-		
+
 		for (unsigned int i = poly->firstLink; i != DT_NULL_LINK; i = tile->links[i].next)
 		{
 			const dtLink* link = &tile->links[i];
-			
+
 			// Find link which contains this edge.
 			if ((int)link->edge != segMax)
 				continue;
-			
+
 			// Get pointer to the next polygon.
 			const dtMeshTile* nextTile = 0;
 			const dtPoly* nextPoly = 0;
 			m_nav->getTileAndPolyByRefUnsafe(link->ref, &nextTile, &nextPoly);
-			
+
 			// Skip off-mesh connections.
 			if (nextPoly->getType() == DT_POLYTYPE_OFFMESH_CONNECTION)
 				continue;
-			
+
 			// Skip links based on filter.
 			if (!filter->passFilter(link->ref, nextTile, nextPoly))
 				continue;
-			
+
 			// If the link is internal, just return the ref.
 			if (link->side == 0xff)
 			{
 				nextRef = link->ref;
 				break;
 			}
-			
+
 			// If the link is at tile boundary,
-			
+
 			// Check if the link spans the whole edge, and accept.
 			if (link->bmin == 0 && link->bmax == 255)
 			{
 				nextRef = link->ref;
 				break;
 			}
-			
+
 			// Check for partial edge links.
 			const int v0 = poly->verts[link->edge];
 			const int v1 = poly->verts[(link->edge+1) % poly->vertCount];
 			const float* left = &tile->verts[v0*3];
 			const float* right = &tile->verts[v1*3];
-			
+
 			// Check that the intersection lies inside the link portal.
 			if (link->side == 0 || link->side == 4)
 			{
@@ -1733,7 +2027,7 @@
 				float lmin = left[2] + (right[2] - left[2])*(link->bmin*s);
 				float lmax = left[2] + (right[2] - left[2])*(link->bmax*s);
 				if (lmin > lmax) dtSwap(lmin, lmax);
-				
+
 				// Find Z intersection.
 				float z = startPos[2] + (endPos[2]-startPos[2])*tmax;
 				if (z >= lmin && z <= lmax)
@@ -1749,7 +2043,7 @@
 				float lmin = left[0] + (right[0] - left[0])*(link->bmin*s);
 				float lmax = left[0] + (right[0] - left[0])*(link->bmax*s);
 				if (lmin > lmax) dtSwap(lmin, lmax);
-				
+
 				// Find X intersection.
 				float x = startPos[0] + (endPos[0]-startPos[0])*tmax;
 				if (x >= lmin && x <= lmax)
@@ -1759,11 +2053,11 @@
 				}
 			}
 		}
-		
+
 		if (!nextRef)
 		{
 			// No neighbour, we hit a wall.
-			
+
 			// Calculate hit normal.
 			const int a = segMax;
 			const int b = segMax+1 < nv ? segMax+1 : 0;
@@ -1775,22 +2069,51 @@
 			hitNormal[1] = 0;
 			hitNormal[2] = -dx;
 			dtVnormalize(hitNormal);
-			
+
 			if (pathCount)
 				*pathCount = n;
-			return DT_SUCCESS;
+			return status;
 		}
-		
+
 		// No hit, advance to neighbour polygon.
 		curRef = nextRef;
 	}
-	
+
 	if (pathCount)
 		*pathCount = n;
-	
-	return DT_SUCCESS;
+
+	return status;
 }
 
+/// @par
+///
+/// At least one result array must be provided.
+///
+/// The order of the result set is from least to highest cost to reach the polygon.
+///
+/// A common use case for this method is to perform Dijkstra searches. 
+/// Candidate polygons are found by searching the graph beginning at the start polygon.
+///
+/// If a polygon is not found via the graph search, even if it intersects the 
+/// search circle, it will not be included in the result set. For example:
+///
+/// polyA is the start polygon.
+/// polyB shares an edge with polyA. (Is adjacent.)
+/// polyC shares an edge with polyB, but not with polyA
+/// Even if the search circle overlaps polyC, it will not be included in the 
+/// result set unless polyB is also in the set.
+/// 
+/// The value of the center point is used as the start position for cost 
+/// calculations. It is not projected onto the surface of the mesh, so its 
+/// y-value will effect the costs.
+///
+/// Intersection tests occur in 2D. All polygons and the search circle are 
+/// projected onto the xz-plane. So the y-value of the center point does not 
+/// effect intersection tests.
+///
+/// If the result arrays are to small to hold the entire result set, they will be 
+/// filled to capacity.
+/// 
 dtStatus dtNavMeshQuery::findPolysAroundCircle(dtPolyRef startRef, const float* centerPos, const float radius,
 											   const dtQueryFilter* filter,
 											   dtPolyRef* resultRef, dtPolyRef* resultParent, float* resultCost,
@@ -1801,14 +2124,14 @@
 	ASSERT(m_openList);
 
 	*resultCount = 0;
-	
+
 	// Validate input
-	if (!startRef) return DT_FAILURE;
-	if (!m_nav->isValidPolyRef(startRef)) return DT_FAILURE;
-	
+	if (!startRef || !m_nav->isValidPolyRef(startRef))
+		return DT_FAILURE | DT_INVALID_PARAM;
+
 	m_nodePool->clear();
 	m_openList->clear();
-	
+
 	dtNode* startNode = m_nodePool->getNode(startRef);
 	dtVcopy(startNode->pos, centerPos);
 	startNode->pidx = 0;
@@ -1817,7 +2140,9 @@
 	startNode->id = startRef;
 	startNode->flags = DT_NODE_OPEN;
 	m_openList->push(startNode);
-	
+
+	dtStatus status = DT_SUCCESS;
+
 	int n = 0;
 	if (n < maxResult)
 	{
@@ -1829,22 +2154,26 @@
 			resultCost[n] = 0;
 		++n;
 	}
-	
+	else
+	{
+		status |= DT_BUFFER_TOO_SMALL;
+	}
+
 	const float radiusSqr = dtSqr(radius);
-	
+
 	while (!m_openList->empty())
 	{
 		dtNode* bestNode = m_openList->pop();
 		bestNode->flags &= ~DT_NODE_OPEN;
 		bestNode->flags |= DT_NODE_CLOSED;
-		
+
 		// Get poly and tile.
 		// The API input has been cheked already, skip checking internal data.
 		const dtPolyRef bestRef = bestNode->id;
 		const dtMeshTile* bestTile = 0;
 		const dtPoly* bestPoly = 0;
 		m_nav->getTileAndPolyByRefUnsafe(bestRef, &bestTile, &bestPoly);
-		
+
 		// Get parent poly and tile.
 		dtPolyRef parentRef = 0;
 		const dtMeshTile* parentTile = 0;
@@ -1853,7 +2182,7 @@
 			parentRef = m_nodePool->getNodeAtIdx(bestNode->pidx)->id;
 		if (parentRef)
 			m_nav->getTileAndPolyByRefUnsafe(parentRef, &parentTile, &parentPoly);
-		
+
 		for (unsigned int i = bestPoly->firstLink; i != DT_NULL_LINK; i = bestTile->links[i].next)
 		{
 			const dtLink* link = &bestTile->links[i];
@@ -1861,49 +2190,52 @@
 			// Skip invalid neighbours and do not follow back to parent.
 			if (!neighbourRef || neighbourRef == parentRef)
 				continue;
-			
+
 			// Expand to neighbour
 			const dtMeshTile* neighbourTile = 0;
 			const dtPoly* neighbourPoly = 0;
 			m_nav->getTileAndPolyByRefUnsafe(neighbourRef, &neighbourTile, &neighbourPoly);
-		
+
 			// Do not advance if the polygon is excluded by the filter.
 			if (!filter->passFilter(neighbourRef, neighbourTile, neighbourPoly))
 				continue;
-			
+
 			// Find edge and calc distance to the edge.
 			float va[3], vb[3];
 			if (!getPortalPoints(bestRef, bestPoly, bestTile, neighbourRef, neighbourPoly, neighbourTile, va, vb))
 				continue;
-			
+
 			// If the circle is not touching the next polygon, skip it.
 			float tseg;
 			float distSqr = dtDistancePtSegSqr2D(centerPos, va, vb, tseg);
 			if (distSqr > radiusSqr)
 				continue;
-			
+
 			dtNode* neighbourNode = m_nodePool->getNode(neighbourRef);
 			if (!neighbourNode)
+			{
+				status |= DT_OUT_OF_NODES;
 				continue;
-				
+			}
+
 			if (neighbourNode->flags & DT_NODE_CLOSED)
 				continue;
-			
+
 			// Cost
 			if (neighbourNode->flags == 0)
 				dtVlerp(neighbourNode->pos, va, vb, 0.5f);
-			
+
 			const float total = bestNode->total + dtVdist(bestNode->pos, neighbourNode->pos);
-			
+
 			// The node is already in open list and the new result is worse, skip.
 			if ((neighbourNode->flags & DT_NODE_OPEN) && total >= neighbourNode->total)
 				continue;
-			
+
 			neighbourNode->id = neighbourRef;
 			neighbourNode->flags &= ~DT_NODE_CLOSED;
 			neighbourNode->pidx = m_nodePool->getNodeIdx(bestNode);
 			neighbourNode->total = total;
-			
+
 			if (neighbourNode->flags & DT_NODE_OPEN)
 			{
 				m_openList->modify(neighbourNode);
@@ -1920,17 +2252,43 @@
 						resultCost[n] = neighbourNode->total;
 					++n;
 				}
+				else
+				{
+					status |= DT_BUFFER_TOO_SMALL;
+				}
 				neighbourNode->flags = DT_NODE_OPEN;
 				m_openList->push(neighbourNode);
 			}
 		}
 	}
-	
+
 	*resultCount = n;
-	
-	return DT_SUCCESS;
+
+	return status;
 }
 
+/// @par
+///
+/// The order of the result set is from least to highest cost.
+/// 
+/// At least one result array must be provided.
+///
+/// A common use case for this method is to perform Dijkstra searches. 
+/// Candidate polygons are found by searching the graph beginning at the start 
+/// polygon.
+/// 
+/// The same intersection test restrictions that apply to findPolysAroundCircle()
+/// method apply to this method.
+/// 
+/// The 3D centroid of the search polygon is used as the start position for cost 
+/// calculations.
+/// 
+/// Intersection tests occur in 2D. All polygons are projected onto the 
+/// xz-plane. So the y-values of the vertices do not effect intersection tests.
+/// 
+/// If the result arrays are is too small to hold the entire result set, they will 
+/// be filled to capacity.
+///
 dtStatus dtNavMeshQuery::findPolysAroundShape(dtPolyRef startRef, const float* verts, const int nverts,
 											  const dtQueryFilter* filter,
 											  dtPolyRef* resultRef, dtPolyRef* resultParent, float* resultCost,
@@ -1939,16 +2297,16 @@
 	ASSERT(m_nav);
 	ASSERT(m_nodePool);
 	ASSERT(m_openList);
-	
+
 	*resultCount = 0;
-	
+
 	// Validate input
-	if (!startRef) return DT_FAILURE;
-	if (!m_nav->isValidPolyRef(startRef)) return DT_FAILURE;
-	
+	if (!startRef || !m_nav->isValidPolyRef(startRef))
+		return DT_FAILURE | DT_INVALID_PARAM;
+
 	m_nodePool->clear();
 	m_openList->clear();
-	
+
 	float centerPos[3] = {0,0,0};
 	for (int i = 0; i < nverts; ++i)
 		dtVadd(centerPos,centerPos,&verts[i*3]);
@@ -1962,7 +2320,9 @@
 	startNode->id = startRef;
 	startNode->flags = DT_NODE_OPEN;
 	m_openList->push(startNode);
-	
+
+	dtStatus status = DT_SUCCESS;
+
 	int n = 0;
 	if (n < maxResult)
 	{
@@ -1974,20 +2334,24 @@
 			resultCost[n] = 0;
 		++n;
 	}
-	
+	else
+	{
+		status |= DT_BUFFER_TOO_SMALL;
+	}
+
 	while (!m_openList->empty())
 	{
 		dtNode* bestNode = m_openList->pop();
 		bestNode->flags &= ~DT_NODE_OPEN;
 		bestNode->flags |= DT_NODE_CLOSED;
-		
+
 		// Get poly and tile.
 		// The API input has been cheked already, skip checking internal data.
 		const dtPolyRef bestRef = bestNode->id;
 		const dtMeshTile* bestTile = 0;
 		const dtPoly* bestPoly = 0;
 		m_nav->getTileAndPolyByRefUnsafe(bestRef, &bestTile, &bestPoly);
-		
+
 		// Get parent poly and tile.
 		dtPolyRef parentRef = 0;
 		const dtMeshTile* parentTile = 0;
@@ -1996,7 +2360,7 @@
 			parentRef = m_nodePool->getNodeAtIdx(bestNode->pidx)->id;
 		if (parentRef)
 			m_nav->getTileAndPolyByRefUnsafe(parentRef, &parentTile, &parentPoly);
-		
+
 		for (unsigned int i = bestPoly->firstLink; i != DT_NULL_LINK; i = bestTile->links[i].next)
 		{
 			const dtLink* link = &bestTile->links[i];
@@ -2004,21 +2368,21 @@
 			// Skip invalid neighbours and do not follow back to parent.
 			if (!neighbourRef || neighbourRef == parentRef)
 				continue;
-			
+
 			// Expand to neighbour
 			const dtMeshTile* neighbourTile = 0;
 			const dtPoly* neighbourPoly = 0;
 			m_nav->getTileAndPolyByRefUnsafe(neighbourRef, &neighbourTile, &neighbourPoly);
-			
+
 			// Do not advance if the polygon is excluded by the filter.
 			if (!filter->passFilter(neighbourRef, neighbourTile, neighbourPoly))
 				continue;
-			
+
 			// Find edge and calc distance to the edge.
 			float va[3], vb[3];
 			if (!getPortalPoints(bestRef, bestPoly, bestTile, neighbourRef, neighbourPoly, neighbourTile, va, vb))
 				continue;
-			
+
 			// If the poly is not touching the edge to the next polygon, skip the connection it.
 			float tmin, tmax;
 			int segMin, segMax;
@@ -2026,29 +2390,32 @@
 				continue;
 			if (tmin > 1.0f || tmax < 0.0f)
 				continue;
-			
+
 			dtNode* neighbourNode = m_nodePool->getNode(neighbourRef);
 			if (!neighbourNode)
+			{
+				status |= DT_OUT_OF_NODES;
 				continue;
-			
+			}
+
 			if (neighbourNode->flags & DT_NODE_CLOSED)
 				continue;
-			
+
 			// Cost
 			if (neighbourNode->flags == 0)
 				dtVlerp(neighbourNode->pos, va, vb, 0.5f);
-			
+
 			const float total = bestNode->total + dtVdist(bestNode->pos, neighbourNode->pos);
-			
+
 			// The node is already in open list and the new result is worse, skip.
 			if ((neighbourNode->flags & DT_NODE_OPEN) && total >= neighbourNode->total)
 				continue;
-			
+
 			neighbourNode->id = neighbourRef;
 			neighbourNode->flags &= ~DT_NODE_CLOSED;
 			neighbourNode->pidx = m_nodePool->getNodeIdx(bestNode);
 			neighbourNode->total = total;
-			
+
 			if (neighbourNode->flags & DT_NODE_OPEN)
 			{
 				m_openList->modify(neighbourNode);
@@ -2065,17 +2432,43 @@
 						resultCost[n] = neighbourNode->total;
 					++n;
 				}
+				else
+				{
+					status |= DT_BUFFER_TOO_SMALL;
+				}
 				neighbourNode->flags = DT_NODE_OPEN;
 				m_openList->push(neighbourNode);
 			}
 		}
 	}
-	
+
 	*resultCount = n;
-	
-	return DT_SUCCESS;
+
+	return status;
 }
 
+/// @par
+///
+/// This method is optimized for a small search radius and small number of result 
+/// polygons.
+///
+/// Candidate polygons are found by searching the navigation graph beginning at 
+/// the start polygon.
+///
+/// The same intersection test restrictions that apply to the findPolysAroundCircle 
+/// mehtod applies to this method.
+///
+/// The value of the center point is used as the start point for cost calculations. 
+/// It is not projected onto the surface of the mesh, so its y-value will effect 
+/// the costs.
+/// 
+/// Intersection tests occur in 2D. All polygons and the search circle are 
+/// projected onto the xz-plane. So the y-value of the center point does not 
+/// effect intersection tests.
+/// 
+/// If the result arrays are is too small to hold the entire result set, they will 
+/// be filled to capacity.
+/// 
 dtStatus dtNavMeshQuery::findLocalNeighbourhood(dtPolyRef startRef, const float* centerPos, const float radius,
 												const dtQueryFilter* filter,
 												dtPolyRef* resultRef, dtPolyRef* resultParent,
@@ -2083,30 +2476,32 @@
 {
 	ASSERT(m_nav);
 	ASSERT(m_tinyNodePool);
-	
+
 	*resultCount = 0;
 
 	// Validate input
-	if (!startRef) return DT_FAILURE;
-	if (!m_nav->isValidPolyRef(startRef)) return DT_FAILURE;
-	
+	if (!startRef || !m_nav->isValidPolyRef(startRef))
+		return DT_FAILURE | DT_INVALID_PARAM;
+
 	static const int MAX_STACK = 48;
 	dtNode* stack[MAX_STACK];
 	int nstack = 0;
-	
+
 	m_tinyNodePool->clear();
-	
+
 	dtNode* startNode = m_tinyNodePool->getNode(startRef);
 	startNode->pidx = 0;
 	startNode->id = startRef;
 	startNode->flags = DT_NODE_CLOSED;
 	stack[nstack++] = startNode;
-	
+
 	const float radiusSqr = dtSqr(radius);
-	
+
 	float pa[DT_VERTS_PER_POLYGON*3];
 	float pb[DT_VERTS_PER_POLYGON*3];
-	
+
+	dtStatus status = DT_SUCCESS;
+
 	int n = 0;
 	if (n < maxResult)
 	{
@@ -2115,7 +2510,11 @@
 			resultParent[n] = 0;
 		++n;
 	}
-	
+	else
+	{
+		status |= DT_BUFFER_TOO_SMALL;
+	}
+
 	while (nstack)
 	{
 		// Pop front.
@@ -2123,14 +2522,14 @@
 		for (int i = 0; i < nstack-1; ++i)
 			stack[i] = stack[i+1];
 		nstack--;
-		
+
 		// Get poly and tile.
 		// The API input has been cheked already, skip checking internal data.
 		const dtPolyRef curRef = curNode->id;
 		const dtMeshTile* curTile = 0;
 		const dtPoly* curPoly = 0;
 		m_nav->getTileAndPolyByRefUnsafe(curRef, &curTile, &curPoly);
-		
+
 		for (unsigned int i = curPoly->firstLink; i != DT_NULL_LINK; i = curTile->links[i].next)
 		{
 			const dtLink* link = &curTile->links[i];
@@ -2138,7 +2537,7 @@
 			// Skip invalid neighbours.
 			if (!neighbourRef)
 				continue;
-			
+
 			// Skip if cannot alloca more nodes.
 			dtNode* neighbourNode = m_tinyNodePool->getNode(neighbourRef);
 			if (!neighbourNode)
@@ -2146,48 +2545,48 @@
 			// Skip visited.
 			if (neighbourNode->flags & DT_NODE_CLOSED)
 				continue;
-			
+
 			// Expand to neighbour
 			const dtMeshTile* neighbourTile = 0;
 			const dtPoly* neighbourPoly = 0;
 			m_nav->getTileAndPolyByRefUnsafe(neighbourRef, &neighbourTile, &neighbourPoly);
-			
+
 			// Skip off-mesh connections.
 			if (neighbourPoly->getType() == DT_POLYTYPE_OFFMESH_CONNECTION)
 				continue;
-			
+
 			// Do not advance if the polygon is excluded by the filter.
 			if (!filter->passFilter(neighbourRef, neighbourTile, neighbourPoly))
 				continue;
-			
+
 			// Find edge and calc distance to the edge.
 			float va[3], vb[3];
 			if (!getPortalPoints(curRef, curPoly, curTile, neighbourRef, neighbourPoly, neighbourTile, va, vb))
 				continue;
-			
+
 			// If the circle is not touching the next polygon, skip it.
 			float tseg;
 			float distSqr = dtDistancePtSegSqr2D(centerPos, va, vb, tseg);
 			if (distSqr > radiusSqr)
 				continue;
-			
+
 			// Mark node visited, this is done before the overlap test so that
 			// we will not visit the poly again if the test fails.
 			neighbourNode->flags |= DT_NODE_CLOSED;
 			neighbourNode->pidx = m_tinyNodePool->getNodeIdx(curNode);
-			
+
 			// Check that the polygon does not collide with existing polygons.
-			
+
 			// Collect vertices of the neighbour poly.
 			const int npa = neighbourPoly->vertCount;
 			for (int k = 0; k < npa; ++k)
 				dtVcopy(&pa[k*3], &neighbourTile->verts[neighbourPoly->verts[k]*3]);
-			
+
 			bool overlap = false;
 			for (int j = 0; j < n; ++j)
 			{
 				dtPolyRef pastRef = resultRef[j];
-				
+
 				// Connected polys do not overlap.
 				bool connected = false;
 				for (unsigned int k = curPoly->firstLink; k != DT_NULL_LINK; k = curTile->links[k].next)
@@ -2200,17 +2599,17 @@
 				}
 				if (connected)
 					continue;
-				
+
 				// Potentially overlapping.
 				const dtMeshTile* pastTile = 0;
 				const dtPoly* pastPoly = 0;
 				m_nav->getTileAndPolyByRefUnsafe(pastRef, &pastTile, &pastPoly);
-				
+
 				// Get vertices and test overlap
 				const int npb = pastPoly->vertCount;
 				for (int k = 0; k < npb; ++k)
 					dtVcopy(&pb[k*3], &pastTile->verts[pastPoly->verts[k]*3]);
-				
+
 				if (dtOverlapPolyPoly2D(pa,npa, pb,npb))
 				{
 					overlap = true;
@@ -2219,7 +2618,7 @@
 			}
 			if (overlap)
 				continue;
-			
+
 			// This poly is fine, store and advance to the poly.
 			if (n < maxResult)
 			{
@@ -2228,27 +2627,32 @@
 					resultParent[n] = curRef;
 				++n;
 			}
-			
+			else
+			{
+				status |= DT_BUFFER_TOO_SMALL;
+			}
+
 			if (nstack < MAX_STACK)
 			{
 				stack[nstack++] = neighbourNode;
 			}
 		}
 	}
-	
+
 	*resultCount = n;
-	
-	return DT_SUCCESS;
+
+	return status;
 }
 
 
 struct dtSegInterval
 {
+	dtPolyRef ref;
 	short tmin, tmax;
 };
 
 static void insertInterval(dtSegInterval* ints, int& nints, const int maxInts,
-						   const short tmin, const short tmax)
+						   const short tmin, const short tmax, const dtPolyRef ref)
 {
 	if (nints+1 > maxInts) return;
 	// Find insertion point.
@@ -2263,28 +2667,45 @@
 	if (nints-idx)
 		memmove(ints+idx+1, ints+idx, sizeof(dtSegInterval)*(nints-idx));
 	// Store
+	ints[idx].ref = ref;
 	ints[idx].tmin = tmin;
 	ints[idx].tmax = tmax;
 	nints++;
 }
 
+/// @par
+///
+/// If the @p segmentRefs parameter is provided, then all polygon segments will be returned. 
+/// Otherwise only the wall segments are returned.
+/// 
+/// A segment that is normally a portal will be included in the result set as a 
+/// wall if the @p filter results in the neighbor polygon becoomming impassable.
+/// 
+/// The @p segmentVerts and @p segmentRefs buffers should normally be sized for the 
+/// maximum segments per polygon of the source navigation mesh.
+/// 
 dtStatus dtNavMeshQuery::getPolyWallSegments(dtPolyRef ref, const dtQueryFilter* filter,
-											 float* segments, int* segmentCount, const int maxSegments) const
+											 float* segmentVerts, dtPolyRef* segmentRefs, int* segmentCount,
+											 const int maxSegments) const
 {
 	ASSERT(m_nav);
-	
+
 	*segmentCount = 0;
-	
+
 	const dtMeshTile* tile = 0;
 	const dtPoly* poly = 0;
-	if (m_nav->getTileAndPolyByRef(ref, &tile, &poly) != DT_SUCCESS)
-		return DT_FAILURE;
-	
+	if (dtStatusFailed(m_nav->getTileAndPolyByRef(ref, &tile, &poly)))
+		return DT_FAILURE | DT_INVALID_PARAM;
+
 	int n = 0;
 	static const int MAX_INTERVAL = 16;
 	dtSegInterval ints[MAX_INTERVAL];
 	int nints;
-	
+
+	const bool storePortals = segmentRefs != 0;
+
+	dtStatus status = DT_SUCCESS;
+
 	for (int i = 0, j = (int)poly->vertCount-1; i < (int)poly->vertCount; j = i++)
 	{
 		// Skip non-solid edges.
@@ -2304,64 +2725,115 @@
 						m_nav->getTileAndPolyByRefUnsafe(link->ref, &neiTile, &neiPoly);
 						if (filter->passFilter(link->ref, neiTile, neiPoly))
 						{
-							insertInterval(ints, nints, MAX_INTERVAL, link->bmin, link->bmax);
+							insertInterval(ints, nints, MAX_INTERVAL, link->bmin, link->bmax, link->ref);
 						}
 					}
 				}
 			}
 		}
-		else if (poly->neis[j])
+		else
 		{
 			// Internal edge
-			const unsigned int idx = (unsigned int)(poly->neis[j]-1);
-			const dtPolyRef ref = m_nav->getPolyRefBase(tile) | idx;
-			if (filter->passFilter(ref, tile, &tile->polys[idx]))
+			dtPolyRef ref = 0;
+			if (poly->neis[j])
+			{
+				const unsigned int idx = (unsigned int)(poly->neis[j]-1);
+				ref = m_nav->getPolyRefBase(tile) | idx;
+				if (!filter->passFilter(ref, tile, &tile->polys[idx]))
+					ref = 0;
+			}
+
+			// If the edge leads to another polygon and portals are not stored, skip.
+			if (ref != 0 && !storePortals)
 				continue;
+
+			if (n < maxSegments)
+			{
+				const float* vj = &tile->verts[poly->verts[j]*3];
+				const float* vi = &tile->verts[poly->verts[i]*3];
+				float* seg = &segmentVerts[n*6];
+				dtVcopy(seg+0, vj);
+				dtVcopy(seg+3, vi);
+				if (segmentRefs)
+					segmentRefs[n] = ref;
+				n++;
+			}
+			else
+			{
+				status |= DT_BUFFER_TOO_SMALL;
+			}
+
+			continue;
 		}
-		
+
 		// Add sentinels
-		insertInterval(ints, nints, MAX_INTERVAL, -1, 0);
-		insertInterval(ints, nints, MAX_INTERVAL, 255, 256);
-		
-		// Store segment.
+		insertInterval(ints, nints, MAX_INTERVAL, -1, 0, 0);
+		insertInterval(ints, nints, MAX_INTERVAL, 255, 256, 0);
+
+		// Store segments.
 		const float* vj = &tile->verts[poly->verts[j]*3];
 		const float* vi = &tile->verts[poly->verts[i]*3];
 		for (int k = 1; k < nints; ++k)
 		{
-			// Find the space inbetween the opening areas.
-			const int imin = ints[k-1].tmax;
-			const int imax = ints[k].tmin;
-			if (imin == imax) continue;
-			if (imin == 0 && imax == 255)
+			// Portal segment.
+			if (storePortals && ints[k].ref)
 			{
+				const float tmin = ints[k].tmin/255.0f; 
+				const float tmax = ints[k].tmax/255.0f; 
 				if (n < maxSegments)
 				{
-					float* seg = &segments[n*6];
+					float* seg = &segmentVerts[n*6];
+					dtVlerp(seg+0, vj,vi, tmin);
+					dtVlerp(seg+3, vj,vi, tmax);
+					if (segmentRefs)
+						segmentRefs[n] = ints[k].ref;
 					n++;
-					dtVcopy(seg+0, vj);
-					dtVcopy(seg+3, vi);
 				}
+				else
+				{
+					status |= DT_BUFFER_TOO_SMALL;
+				}
 			}
-			else
+
+			// Wall segment.
+			const int imin = ints[k-1].tmax;
+			const int imax = ints[k].tmin;
+			if (imin != imax)
 			{
 				const float tmin = imin/255.0f; 
 				const float tmax = imax/255.0f; 
 				if (n < maxSegments)
 				{
-					float* seg = &segments[n*6];
-					n++;
+					float* seg = &segmentVerts[n*6];
 					dtVlerp(seg+0, vj,vi, tmin);
 					dtVlerp(seg+3, vj,vi, tmax);
+					if (segmentRefs)
+						segmentRefs[n] = 0;
+					n++;
 				}
+				else
+				{
+					status |= DT_BUFFER_TOO_SMALL;
+				}
 			}
 		}
 	}
-	
+
 	*segmentCount = n;
-	
-	return DT_SUCCESS;
+
+	return status;
 }
 
+/// @par
+///
+/// @p hitPos is not adjusted using the height detail data.
+///
+/// @p hitDist will equal the search radius if there is no wall within the 
+/// radius. In this case the values of @p hitPos and @p hitNormal are
+/// undefined.
+///
+/// The normal will become unpredicable if @p hitDist is a very small number.
+///
 dtStatus dtNavMeshQuery::findDistanceToWall(dtPolyRef startRef, const float* centerPos, const float maxRadius,
 											const dtQueryFilter* filter,
 											float* hitDist, float* hitPos, float* hitNormal) const
@@ -2369,14 +2841,14 @@
 	ASSERT(m_nav);
 	ASSERT(m_nodePool);
 	ASSERT(m_openList);
-	
+
 	// Validate input
-	if (!startRef) return DT_FAILURE;
-	if (!m_nav->isValidPolyRef(startRef)) return DT_FAILURE;
-	
+	if (!startRef || !m_nav->isValidPolyRef(startRef))
+		return DT_FAILURE | DT_INVALID_PARAM;
+
 	m_nodePool->clear();
 	m_openList->clear();
-	
+
 	dtNode* startNode = m_nodePool->getNode(startRef);
 	dtVcopy(startNode->pos, centerPos);
 	startNode->pidx = 0;
@@ -2385,22 +2857,24 @@
 	startNode->id = startRef;
 	startNode->flags = DT_NODE_OPEN;
 	m_openList->push(startNode);
-	
+
 	float radiusSqr = dtSqr(maxRadius);
-	
+
+	dtStatus status = DT_SUCCESS;
+
 	while (!m_openList->empty())
 	{
 		dtNode* bestNode = m_openList->pop();
 		bestNode->flags &= ~DT_NODE_OPEN;
 		bestNode->flags |= DT_NODE_CLOSED;
-		
+
 		// Get poly and tile.
 		// The API input has been cheked already, skip checking internal data.
 		const dtPolyRef bestRef = bestNode->id;
 		const dtMeshTile* bestTile = 0;
 		const dtPoly* bestPoly = 0;
 		m_nav->getTileAndPolyByRefUnsafe(bestRef, &bestTile, &bestPoly);
-		
+
 		// Get parent poly and tile.
 		dtPolyRef parentRef = 0;
 		const dtMeshTile* parentTile = 0;
@@ -2409,7 +2883,7 @@
 			parentRef = m_nodePool->getNodeAtIdx(bestNode->pidx)->id;
 		if (parentRef)
 			m_nav->getTileAndPolyByRefUnsafe(parentRef, &parentTile, &parentPoly);
-		
+
 		// Hit test walls.
 		for (int i = 0, j = (int)bestPoly->vertCount-1; i < (int)bestPoly->vertCount; j = i++)
 		{
@@ -2444,17 +2918,17 @@
 				if (filter->passFilter(ref, bestTile, &bestTile->polys[idx]))
 					continue;
 			}
-			
+
 			// Calc distance to the edge.
 			const float* vj = &bestTile->verts[bestPoly->verts[j]*3];
 			const float* vi = &bestTile->verts[bestPoly->verts[i]*3];
 			float tseg;
 			float distSqr = dtDistancePtSegSqr2D(centerPos, vj, vi, tseg);
-			
+
 			// Edge is too far, skip.
 			if (distSqr > radiusSqr)
 				continue;
-			
+
 			// Hit wall, update radius.
 			radiusSqr = distSqr;
 			// Calculate hit pos.
@@ -2462,7 +2936,7 @@
 			hitPos[1] = vj[1] + (vi[1] - vj[1])*tseg;
 			hitPos[2] = vj[2] + (vi[2] - vj[2])*tseg;
 		}
-		
+
 		for (unsigned int i = bestPoly->firstLink; i != DT_NULL_LINK; i = bestTile->links[i].next)
 		{
 			const dtLink* link = &bestTile->links[i];
@@ -2470,54 +2944,57 @@
 			// Skip invalid neighbours and do not follow back to parent.
 			if (!neighbourRef || neighbourRef == parentRef)
 				continue;
-			
+
 			// Expand to neighbour.
 			const dtMeshTile* neighbourTile = 0;
 			const dtPoly* neighbourPoly = 0;
 			m_nav->getTileAndPolyByRefUnsafe(neighbourRef, &neighbourTile, &neighbourPoly);
-			
+
 			// Skip off-mesh connections.
 			if (neighbourPoly->getType() == DT_POLYTYPE_OFFMESH_CONNECTION)
 				continue;
-			
+
 			// Calc distance to the edge.
 			const float* va = &bestTile->verts[bestPoly->verts[link->edge]*3];
 			const float* vb = &bestTile->verts[bestPoly->verts[(link->edge+1) % bestPoly->vertCount]*3];
 			float tseg;
 			float distSqr = dtDistancePtSegSqr2D(centerPos, va, vb, tseg);
-			
+
 			// If the circle is not touching the next polygon, skip it.
 			if (distSqr > radiusSqr)
 				continue;
-			
+
 			if (!filter->passFilter(neighbourRef, neighbourTile, neighbourPoly))
 				continue;
 
 			dtNode* neighbourNode = m_nodePool->getNode(neighbourRef);
 			if (!neighbourNode)
+			{
+				status |= DT_OUT_OF_NODES;
 				continue;
-			
+			}
+
 			if (neighbourNode->flags & DT_NODE_CLOSED)
 				continue;
-			
+
 			// Cost
 			if (neighbourNode->flags == 0)
 			{
 				getEdgeMidPoint(bestRef, bestPoly, bestTile,
 								neighbourRef, neighbourPoly, neighbourTile, neighbourNode->pos);
 			}
-			
+
 			const float total = bestNode->total + dtVdist(bestNode->pos, neighbourNode->pos);
-			
+
 			// The node is already in open list and the new result is worse, skip.
 			if ((neighbourNode->flags & DT_NODE_OPEN) && total >= neighbourNode->total)
 				continue;
-			
+
 			neighbourNode->id = neighbourRef;
 			neighbourNode->flags &= ~DT_NODE_CLOSED;
 			neighbourNode->pidx = m_nodePool->getNodeIdx(bestNode);
 			neighbourNode->total = total;
-				
+
 			if (neighbourNode->flags & DT_NODE_OPEN)
 			{
 				m_openList->modify(neighbourNode);
@@ -2529,16 +3006,35 @@
 			}
 		}
 	}
-	
+
 	// Calc hit normal.
 	dtVsub(hitNormal, centerPos, hitPos);
 	dtVnormalize(hitNormal);
-	
+
 	*hitDist = sqrtf(radiusSqr);
-	
-	return DT_SUCCESS;
+
+	return status;
 }
 
+bool dtNavMeshQuery::isValidPolyRef(dtPolyRef ref, const dtQueryFilter* filter) const
+{
+	const dtMeshTile* tile = 0;
+	const dtPoly* poly = 0;
+	dtStatus status = m_nav->getTileAndPolyByRef(ref, &tile, &poly);
+	// If cannot get polygon, assume it does not exists and boundary is invalid.
+	if (dtStatusFailed(status))
+		return false;
+	// If cannot pass filter, assume flags has changed and boundary is invalid.
+	if (!filter->passFilter(ref, tile, poly))
+		return false;
+	return true;
+}
+
+/// @par
+///
+/// The closed list is the list of polygons that were fully evaluated during 
+/// the last navigation graph search. (A* or Dijkstra)
+/// 
 bool dtNavMeshQuery::isInClosedList(dtPolyRef ref) const
 {
 	if (!m_nodePool) return false;
Index: src/hearthstone-shared/Pathfinding/Detour/DetourNavMeshQuery.h
===================================================================
--- src/hearthstone-shared/Pathfinding/Detour/DetourNavMeshQuery.h	(revision 1490)
+++ src/hearthstone-shared/Pathfinding/Detour/DetourNavMeshQuery.h	(working copy)
@@ -20,39 +20,31 @@
 #define DETOURNAVMESHQUERY_H
 
 #include "DetourNavMesh.h"
+#include "DetourStatus.h"
 
 
 // Define DT_VIRTUAL_QUERYFILTER if you wish to derive a custom filter from dtQueryFilter.
 // On certain platforms indirect or virtual function call is expensive. The default
-// setting is to use non-virtual functions, the actualy implementations of the functions
+// setting is to use non-virtual functions, the actual implementations of the functions
 // are declared as inline for maximum speed. 
 
 //#define DT_VIRTUAL_QUERYFILTER 1
 
-// Class for polygon filtering and cost calculation during query operations.
-// - It is possible to derive a custom query filter from dtQueryFilter by overriding
-//   the virtual functions passFilter() and getCost().
-// - Both functions should be as fast as possible. Use cached local copy of data
-//   instead of accessing your own objects where possible.
-// - You do not need to adhere to the flags and cost logic provided by the default
-//   implementation.
-// - In order for the A* to work properly, the cost should be proportional to
-//   the travel distance. Using cost modifier less than 1.0 is likely to lead
-//   to problems during pathfinding.
+/// Defines polygon filtering and traversal costs for navigation mesh query operations.
+/// @ingroup detour
 class dtQueryFilter
 {
-	float m_areaCost[DT_MAX_AREAS];		// Array storing cost per area type, used by default implementation.
-	unsigned short m_includeFlags;		// Include poly flags, used by default implementation.
-	unsigned short m_excludeFlags;		// Exclude poly flags, used by default implementation.
-	
+	float m_areaCost[DT_MAX_AREAS];		///< Cost per area type. (Used by default implementation.)
+	unsigned short m_includeFlags;		///< Flags for polygons that can be visited. (Used by default implementation.)
+	unsigned short m_excludeFlags;		///< Flags for polygons that should not be visted. (Used by default implementation.)
+
 public:
 	dtQueryFilter();
-	
-	// Returns true if the polygon is can visited.
-	// Params:
-	//  ref - (in) reference to the polygon test.
-	//  tile - (in) pointer to the tile of the polygon test.
-	//  poly - (in) pointer to the polygon test.
+
+	/// Returns true if the polygon can be visited.  (I.e. Is traversable.)
+	///  @param[in]		ref		The reference id of the polygon test.
+	///  @param[in]		tile	The tile containing the polygon.
+	///  @param[in]		poly  The polygon to test.
 #ifdef DT_VIRTUAL_QUERYFILTER
 	virtual bool passFilter(const dtPolyRef ref,
 							const dtMeshTile* tile,
@@ -63,16 +55,19 @@
 					const dtPoly* poly) const;
 #endif
 
-	// Returns cost to travel from 'pa' to 'pb'.'
-	// The segment is fully contained inside 'cur'.
-	// 'pa' lies on the edge between 'prev' and 'cur', 
-	// 'pb' lies on the edge between 'cur' and 'next'.
-	// Params:
-	//  pa - (in) segment start position.
-	//  pb - (in) segment end position.
-	//  prevRef, prevTile, prevPoly - (in) data describing the previous polygon, can be null.
-	//  curRef, curTile, curPoly - (in) data describing the current polygon.
-	//  nextRef, nextTile, nextPoly - (in) data describing the next polygon, can be null.
+	/// Returns cost to move from the beginning to the end of a line segment
+	/// that is fully contained within a polygon.
+	///  @param[in]		pa			The start position on the edge of the previous and current polygon. [(x, y, z)]
+	///  @param[in]		pb			The end position on the edge of the current and next polygon. [(x, y, z)]
+	///  @param[in]		prevRef		The reference id of the previous polygon. [opt]
+	///  @param[in]		prevTile	The tile containing the previous polygon. [opt]
+	///  @param[in]		prevPoly	The previous polygon. [opt]
+	///  @param[in]		curRef		The reference id of the current polygon.
+	///  @param[in]		curTile		The tile containing the current polygon.
+	///  @param[in]		curPoly		The current polygon.
+	///  @param[in]		nextRef		The refernece id of the next polygon. [opt]
+	///  @param[in]		nextTile	The tile containing the next polygon. [opt]
+	///  @param[in]		nextPoly	The next polygon. [opt]
 #ifdef DT_VIRTUAL_QUERYFILTER
 	virtual float getCost(const float* pa, const float* pb,
 						  const dtPolyRef prevRef, const dtMeshTile* prevTile, const dtPoly* prevPoly,
@@ -85,305 +80,350 @@
 				  const dtPolyRef nextRef, const dtMeshTile* nextTile, const dtPoly* nextPoly) const;
 #endif
 
-	// Getters and setters for the default implementation data.
+	/// @name Getters and setters for the default implementation data.
+	///@{
+
+	/// Returns the traversal cost of the area.
+	///  @param[in]		i		The id of the area.
+	/// @returns The traversal cost of the area.
 	inline float getAreaCost(const int i) const { return m_areaCost[i]; }
+
+	/// Sets the traversal cost of the area.
+	///  @param[in]		i		The id of the area.
+	///  @param[in]		cost	The new cost of traversing the area.
 	inline void setAreaCost(const int i, const float cost) { m_areaCost[i] = cost; } 
 
+	/// Returns the include flags for the filter.
+	/// Any polygons that include one or more of these flags will be
+	/// included in the operation.
 	inline unsigned short getIncludeFlags() const { return m_includeFlags; }
+
+	/// Sets the include flags for the filter.
+	/// @param[in]		flags	The new flags.
 	inline void setIncludeFlags(const unsigned short flags) { m_includeFlags = flags; }
 
+	/// Returns the exclude flags for the filter.
+	/// Any polygons that include one ore more of these flags will be
+	/// excluded from the operation.
 	inline unsigned short getExcludeFlags() const { return m_excludeFlags; }
-	inline void setExcludeFlags(const unsigned short flags) { m_excludeFlags = flags; }	
+
+	/// Sets the exclude flags for the filter.
+	/// @param[in]		flags		The new flags.
+	inline void setExcludeFlags(const unsigned short flags) { m_excludeFlags = flags; }
+
+	///@}
+
 };
 
+/// Provides the ability to perform pathfinding related queries against
+/// a navigation mesh.
+/// @ingroup detour
 class dtNavMeshQuery
 {
 public:
 	dtNavMeshQuery();
 	~dtNavMeshQuery();
-	
-	// Initializes the nav mesh query.
-	// Params:
-	//  nav - (in) pointer to navigation mesh data.
-	//  maxNodes - (in) Maximum number of search nodes to use (max 65536).
-	// Returns: True if succeed, else false.
+
+	/// Initializes the query object.
+	///  @param[in]		nav			Pointer to the dtNavMesh object to use for all queries.
+	///  @param[in]		maxNodes	Maximum number of search nodes. [Limits: 0 < value <= 65536]
+	/// @returns The status flags for the query.
 	dtStatus init(const dtNavMesh* nav, const int maxNodes);
-	
-	// Finds the nearest navigation polygon around the center location.
-	// Params:
-	//	center[3] - (in) The center of the search box.
-	//	extents[3] - (in) The extents of the search box.
-	//  filter - (in) path polygon filter.
-	//  nearestRef - (out) Reference to the nearest polygon.
-	//  nearestPt[3] - (out, opt) The nearest point on found polygon, null if not needed.
-	// Returns: Reference identifier for the polygon, or 0 if no polygons found.
-	dtStatus findNearestPoly(const float* center, const float* extents,
-							 const dtQueryFilter* filter,
-							 dtPolyRef* nearestRef, float* nearestPt) const;
-	
-	// Returns polygons which overlap the query box.
-	// Params:
-	//	center[3] - (in) the center of the search box.
-	//	extents[3] - (in) the extents of the search box.
-	//  filter - (in) path polygon filter.
-	//	polys - (out) array holding the search result.
-	//  polyCount - (out) Number of polygons in search result array.
-	//	maxPolys - (in) The max number of polygons the polys array can hold.
-	dtStatus queryPolygons(const float* center, const float* extents,
-						   const dtQueryFilter* filter,
-						   dtPolyRef* polys, int* polyCount, const int maxPolys) const;
-	
-	// Finds path from start polygon to end polygon.
-	// If target polygon canno be reached through the navigation graph,
-	// the last node on the array is nearest node to the end polygon.
-	// Start end end positions are needed to calculate more accurate
-	// traversal cost at start end end polygons.
-	// Params:
-	//	startRef - (in) ref to path start polygon.
-	//	endRef - (in) ref to path end polygon.
-	//	startPos[3] - (in) Path start location.
-	//	endPos[3] - (in) Path end location.
-	//  filter - (in) path polygon filter.
-	//	path - (out) array holding the search result.
-	//  pathCount - (out) Number of polygons in search result array.
-	//	maxPath - (in) The max number of polygons the path array can hold. Must be at least 1.
+
+	/// @name Standard Pathfinding Functions
+	// /@{
+
+	/// Finds a path from the start polygon to the end polygon.
+	///  @param[in]		startRef	The refrence id of the start polygon.
+	///  @param[in]		endRef		The reference id of the end polygon.
+	///  @param[in]		startPos	A position within the start polygon. [(x, y, z)]
+	///  @param[in]		endPos		A position within the end polygon. [(x, y, z)]
+	///  @param[in]		filter		The polygon filter to apply to the query.
+	///  @param[out]	path		An ordered list of polygon references representing the path. (Start to end.) 
+	///  							[(polyRef) * @p pathCount]
+	///  @param[out]	pathCount	The number of polygons returned in the @p path array.
+	///  @param[in]		maxPath		The maximum number of polygons the @p path array can hold. [Limit: >= 1]
 	dtStatus findPath(dtPolyRef startRef, dtPolyRef endRef,
 					  const float* startPos, const float* endPos,
 					  const dtQueryFilter* filter,
 					  dtPolyRef* path, int* pathCount, const int maxPath) const;
-	
-	// Intializes sliced path find query.
-	// Note 1: calling any other dtNavMeshQuery method before calling findPathEnd()
-	// may results in corrupted data!
-	// Note 2: The pointer to filter is store, and used in subsequent
-	// calls to updateSlicedFindPath().
-	// Params:
-	//	startRef - (in) ref to path start polygon.
-	//	endRef - (in) ref to path end polygon.
-	//	startPos[3] - (in) Path start location.
-	//	endPos[3] - (in) Path end location.
-	//  filter - (in) path polygon filter.
+
+	/// Finds the straight path from the start to the end position within the polygon corridor.
+	///  @param[in]		startPos			Path start position. [(x, y, z)]
+	///  @param[in]		endPos				Path end position. [(x, y, z)]
+	///  @param[in]		path				An array of polygon references that represent the path corridor.
+	///  @param[in]		pathSize			The number of polygons in the @p path array.
+	///  @param[out]	straightPath		Points describing the straight path. [(x, y, z) * @p straightPathCount].
+	///  @param[out]	straightPathFlags	Flags describing each point. (See: #dtStraightPathFlags) [opt]
+	///  @param[out]	straightPathRefs	The reference id of the polygon that is being entered at each point. [opt]
+	///  @param[out]	straightPathCount	The number of points in the straight path.
+	///  @param[in]		maxStraightPath		The maximum number of points the straight path arrays can hold.  [Limit: > 0]
+	/// @returns The status flags for the query.
+	dtStatus findStraightPath(const float* startPos, const float* endPos,
+							  const dtPolyRef* path, const int pathSize,
+							  float* straightPath, unsigned char* straightPathFlags, dtPolyRef* straightPathRefs,
+							  int* straightPathCount, const int maxStraightPath) const;
+
+	///@}
+	/// @name Sliced Pathfinding Functions
+	/// Common use case:
+	///	-# Call initSlicedFindPath() to initialize the sliced path query.
+	///	-# Call updateSlicedFindPath() until it returns complete.
+	///	-# Call finalizeSlicedFindPath() to get the path.
+	///@{ 
+
+	/// Intializes a sliced path query.
+	///  @param[in]		startRef	The refrence id of the start polygon.
+	///  @param[in]		endRef		The reference id of the end polygon.
+	///  @param[in]		startPos	A position within the start polygon. [(x, y, z)]
+	///  @param[in]		endPos		A position within the end polygon. [(x, y, z)]
+	///  @param[in]		filter		The polygon filter to apply to the query.
+	/// @returns The status flags for the query.
 	dtStatus initSlicedFindPath(dtPolyRef startRef, dtPolyRef endRef,
 								const float* startPos, const float* endPos,
 								const dtQueryFilter* filter);
 
-	// Updates sliced path find query.
-	// Params:
-	//  maxIter - (in) max number of iterations to update.
-	// Returns: Path query state.
-	dtStatus updateSlicedFindPath(const int maxIter);
+	/// Updates an in-progress sliced path query.
+	///  @param[in]		maxIter		The maximum number of iterations to perform.
+	///  @param[out]	doneIters	The actual number of iterations completed. [opt]
+	/// @returns The status flags for the query.
+	dtStatus updateSlicedFindPath(const int maxIter, int* doneIters);
 
-	// Finalizes sliced path find query and returns found path.
-	//	path - (out) array holding the search result.
-	//  pathCount - (out) Number of polygons in search result array.
-	//	maxPath - (in) The max number of polygons the path array can hold.
+	/// Finalizes and returns the results of a sliced path query.
+	///  @param[out]	path		An ordered list of polygon references representing the path. (Start to end.) 
+	///  							[(polyRef) * @p pathCount]
+	///  @param[out]	pathCount	The number of polygons returned in the @p path array.
+	///  @param[in]		maxPath		The max number of polygons the path array can hold. [Limit: >= 1]
+	/// @returns The status flags for the query.
 	dtStatus finalizeSlicedFindPath(dtPolyRef* path, int* pathCount, const int maxPath);
-	
-	// Finalizes partial sliced path find query and returns path to the furthest
-	// polygon on the existing path that was visited during the search.
-	//	existing - (out) Array of polygons in the existing path.
-	//  existingSize - (out) Number of polygons in existing path array.
-	//	path - (out) array holding the search result.
-	//  pathCount - (out) Number of polygons in search result array.
-	//	maxPath - (in) The max number of polygons the path array can hold.
+
+	/// Finalizes and returns the results of an incomplete sliced path query, returning the path to the furthest
+	/// polygon on the existing path that was visited during the search.
+	///  @param[out]	existing		An array of polygon references for the existing path.
+	///  @param[out]	existingSize	The number of polygon in the @p existing array.
+	///  @param[out]	path			An ordered list of polygon references representing the path. (Start to end.) 
+	///  								[(polyRef) * @p pathCount]
+	///  @param[out]	pathCount		The number of polygons returned in the @p path array.
+	///  @param[in]		maxPath			The max number of polygons the @p path array can hold. [Limit: >= 1]
+	/// @returns The status flags for the query.
 	dtStatus finalizeSlicedFindPathPartial(const dtPolyRef* existing, const int existingSize,
 										   dtPolyRef* path, int* pathCount, const int maxPath);
-	
-	// Finds a straight path from start to end locations within the corridor
-	// described by the path polygons.
-	// Start and end locations will be clamped on the corridor.
-	// The returned polygon references are point to polygon which was entered when
-	// a path point was added. For the end point, zero will be returned. This allows
-	// to match for example off-mesh link points to their representative polygons.
-	// Params:
-	//	startPos[3] - (in) Path start location.
-	//	endPo[3] - (in) Path end location.
-	//	path - (in) Array of connected polygons describing the corridor.
-	//	pathSize - (in) Number of polygons in path array.
-	//	straightPath - (out) Points describing the straight path.
-	//  straightPathFlags - (out, opt) Flags describing each point type, see dtStraightPathFlags.
-	//  straightPathRefs - (out, opt) References to polygons at point locations.
-	//  straightPathCount - (out) Number of points in the path.
-	//	maxStraightPath - (in) The max number of points the straight path array can hold. Must be at least 1.
-	dtStatus findStraightPath(const float* startPos, const float* endPos,
-							  const dtPolyRef* path, const int pathSize,
-							  float* straightPath, unsigned char* straightPathFlags, dtPolyRef* straightPathRefs,
-							  int* straightPathCount, const int maxStraightPath) const;
-	
-	// Moves from startPos to endPos constrained to the navmesh.
-	// If the endPos is reachable, the resultPos will be endPos,
-	// or else the resultPos will be the nearest point in navmesh.
-	// Note: The resulting point is not projected to the ground, use getPolyHeight() to get height.
-	// Note: The algorithm is optimized for small delta movement and small number of polygons. 
-	// Params:
-	//  startRef - (in) ref to the polygon where startPos lies.
-	//  startPos[3] - (in) start position of the mover.
-	//  endPos[3] - (in) desired end position of the mover.
-	//  filter - (in) path polygon filter.
-	//  resultPos[3] - (out) new position of the mover.
-	//  visited - (out) array of visited polygons.
-	//  visitedCount - (out) Number of entries in the visited array.
-	//  maxVisitedSize - (in) max number of polygons in the visited array.
-	dtStatus moveAlongSurface(dtPolyRef startRef, const float* startPos, const float* endPos,
-							  const dtQueryFilter* filter,
-							  float* resultPos, dtPolyRef* visited, int* visitedCount, const int maxVisitedSize) const;
-	
-	// Casts 'walkability' ray along the navmesh surface from startPos towards the endPos.
-	// Params:
-	//	startRef - (in) ref to the polygon where the start lies.
-	//	startPos[3] - (in) start position of the query.
-	//	endPos[3] - (in) end position of the query.
-	//	t - (out) hit parameter along the segment, FLT_MAX if no hit.
-	//	hitNormal[3] - (out) normal of the nearest hit.
-	//  filter - (in) path polygon filter.
-	//  path - (out,opt) visited path polygons.
-	//  pathCount - (out,opt) Number of polygons visited.
-	//  maxPath - (in) max number of polygons in the path array.
-	dtStatus raycast(dtPolyRef startRef, const float* startPos, const float* endPos,
-					 const dtQueryFilter* filter,
-					 float* t, float* hitNormal, dtPolyRef* path, int* pathCount, const int maxPath) const;
-	
-	// Returns distance to nearest wall from the specified location.
-	// Params:
-	//	startRef - (in) ref to the polygon where the center lies.
-	//	centerPos[3] - (in) center if the query circle.
-	//	maxRadius - (in) max search radius.
-	//  filter - (in) path polygon filter.
-	//  hitDist - (out) distance to nearest wall from the test location.
-	//	hitPos[3] - (out) location of the nearest hit.
-	//	hitNormal[3] - (out) normal of the nearest hit.
-	dtStatus findDistanceToWall(dtPolyRef startRef, const float* centerPos, const float maxRadius,
-								const dtQueryFilter* filter,
-								float* hitDist, float* hitPos, float* hitNormal) const;
-	
-	// Finds polygons found along the navigation graph which touch the specified circle.
-	// Params:
-	//	startRef - (in) ref to the polygon where the search starts.
-	//	centerPos[3] - (in) center if the query circle.
-	//	radius - (in) radius of the query circle.
-	//  filter - (in) path polygon filter.
-	//	resultRef - (out, opt) refs to the polygons touched by the circle.
-	//	resultParent - (out, opt) parent of each result polygon.
-	//	resultCost - (out, opt) search cost at each result polygon.
-	//  resultCount - (out, opt) Number of results.
-	//	maxResult - (int) maximum capacity of search results.
+
+	///@}
+	/// @name Dijkstra Search Functions
+	/// @{ 
+
+	/// Finds the polygons along the navigation graph that touch the specified circle.
+	///  @param[in]		startRef		The reference id of the polygon where the search starts.
+	///  @param[in]		centerPos		The center of the search circle. [(x, y, z)]
+	///  @param[in]		radius			The radius of the search circle.
+	///  @param[in]		filter			The polygon filter to apply to the query.
+	///  @param[out]	resultRef		The reference ids of the polygons touched by the circle. [opt]
+	///  @param[out]	resultParent	The reference ids of the parent polygons for each result. 
+	///  								Zero if a result polygon has no parent. [opt]
+	///  @param[out]	resultCost		The search cost from @p centerPos to the polygon. [opt]
+	///  @param[out]	resultCount		The number of polygons found. [opt]
+	///  @param[in]		maxResult		The maximum number of polygons the result arrays can hold.
+	/// @returns The status flags for the query.
 	dtStatus findPolysAroundCircle(dtPolyRef startRef, const float* centerPos, const float radius,
 								   const dtQueryFilter* filter,
 								   dtPolyRef* resultRef, dtPolyRef* resultParent, float* resultCost,
 								   int* resultCount, const int maxResult) const;
-	
-	// Finds polygons found along the navigation graph which touch the convex polygon shape.
-	// Params:
-	//	startRef - (in) ref to the polygon where the search starts.
-	//	verts[3*n] - (in) vertices describing convex polygon shape (CCW).
-	//	nverts - (in) number of vertices in the polygon.
-	//  filter - (in) path polygon filter.
-	//	resultRef - (out, opt) refs to the polygons touched by the circle.
-	//	resultParent - (out, opt) parent of each result polygon.
-	//	resultCost - (out, opt) search cost at each result polygon.
-	//  resultCount - (out) number of results.
-	//	maxResult - (int) maximum capacity of search results.
+
+	/// Finds the polygons along the naviation graph that touch the specified convex polygon.
+	///  @param[in]		startRef		The reference id of the polygon where the search starts.
+	///  @param[in]		verts			The vertices describing the convex polygon. (CCW) 
+	///  								[(x, y, z) * @p nverts]
+	///  @param[in]		nverts			The number of vertices in the polygon.
+	///  @param[in]		filter			The polygon filter to apply to the query.
+	///  @param[out]	resultRef		The reference ids of the polygons touched by the search polygon. [opt]
+	///  @param[out]	resultParent	The reference ids of the parent polygons for each result. Zero if a 
+	///  								result polygon has no parent. [opt]
+	///  @param[out]	resultCost		The search cost from the centroid point to the polygon. [opt]
+	///  @param[out]	resultCount		The number of polygons found.
+	///  @param[in]		maxResult		The maximum number of polygons the result arrays can hold.
+	/// @returns The status flags for the query.
 	dtStatus findPolysAroundShape(dtPolyRef startRef, const float* verts, const int nverts,
 								  const dtQueryFilter* filter,
 								  dtPolyRef* resultRef, dtPolyRef* resultParent, float* resultCost,
 								  int* resultCount, const int maxResult) const;
-	
-	// Finds non-overlapping local neighbourhood around center location.
-	// Note: The algorithm is optimized for small query radius and small number of polygons. 
-	// Params:
-	//	startRef - (in) ref to the polygon where the search starts.
-	//	centerPos[3] - (in) center if the query circle.
-	//	radius - (in) radius of the query circle.
-	//  filter - (in) path polygon filter.
-	//	resultRef - (out) refs to the polygons touched by the circle.
-	//	resultParent - (out, opt) parent of each result polygon.
-	//  resultCount - (out) number of results.
-	//	maxResult - (int) maximum capacity of search results.
+
+	/// @}
+	/// @name Local Query Functions
+	///@{
+
+	/// Finds the polygon nearest to the specified center point.
+	///  @param[in]		center		The center of the search box. [(x, y, z)]
+	///  @param[in]		extents		The search distance along each axis. [(x, y, z)]
+	///  @param[in]		filter		The polygon filter to apply to the query.
+	///  @param[out]	nearestRef	The reference id of the nearest polygon.
+	///  @param[out]	nearestPt	The nearest point on the polygon. [opt] [(x, y, z)]
+	/// @returns The status flags for the query.
+	dtStatus findNearestPoly(const float* center, const float* extents,
+							 const dtQueryFilter* filter,
+							 dtPolyRef* nearestRef, float* nearestPt) const;
+
+	/// Finds polygons that overlap the search box.
+	///  @param[in]		center		The center of the search box. [(x, y, z)]
+	///  @param[in]		extents		The search distance along each axis. [(x, y, z)]
+	///  @param[in]		filter		The polygon filter to apply to the query.
+	///  @param[out]	polys		The reference ids of the polygons that overlap the query box.
+	///  @param[out]	polyCount	The number of polygons in the search result.
+	///  @param[in]		maxPolys	The maximum number of polygons the search result can hold.
+	/// @returns The status flags for the query.
+	dtStatus queryPolygons(const float* center, const float* extents,
+						   const dtQueryFilter* filter,
+						   dtPolyRef* polys, int* polyCount, const int maxPolys) const;
+
+	/// Finds the non-overlapping navigation polygons in the local neighbourhood around the center position.
+	///  @param[in]		startRef		The reference id of the polygon where the search starts.
+	///  @param[in]		centerPos		The center of the query circle. [(x, y, z)]
+	///  @param[in]		radius			The radius of the query circle.
+	///  @param[in]		filter			The polygon filter to apply to the query.
+	///  @param[out]	resultRef		The reference ids of the polygons touched by the circle.
+	///  @param[out]	resultParent	The reference ids of the parent polygons for each result. 
+	///  								Zero if a result polygon has no parent. [opt]
+	///  @param[out]	resultCount		The number of polygons found.
+	///  @param[in]		maxResult		The maximum number of polygons the result arrays can hold.
+	/// @returns The status flags for the query.
 	dtStatus findLocalNeighbourhood(dtPolyRef startRef, const float* centerPos, const float radius,
 									const dtQueryFilter* filter,
 									dtPolyRef* resultRef, dtPolyRef* resultParent,
 									int* resultCount, const int maxResult) const;
-	
-	// Returns wall segments of specified polygon.
-	// Params:
-	//  ref - (in) ref to the polygon.
-	//  filter - (in) path polygon filter.
-	//  segments[6*maxSegments] - (out) wall segments (2 endpoints per segment).
-	//  segmentCount - (out) number of wall segments.
-	//  maxSegments - (in) max number of segments that can be stored in 'segments'.
+
+	/// Moves from the start to the end position constrained to the navigation mesh.
+	///  @param[in]		startRef		The reference id of the start polygon.
+	///  @param[in]		startPos		A position of the mover within the start polygon. [(x, y, x)]
+	///  @param[in]		endPos			The desired end position of the mover. [(x, y, z)]
+	///  @param[in]		filter			The polygon filter to apply to the query.
+	///  @param[out]	resultPos		The result position of the mover. [(x, y, z)]
+	///  @param[out]	visited			The reference ids of the polygons visited during the move.
+	///  @param[out]	visitedCount	The number of polygons visited during the move.
+	///  @param[in]		maxVisitedSize	The maximum number of polygons the @p visited array can hold.
+	/// @returns The status flags for the query.
+	dtStatus moveAlongSurface(dtPolyRef startRef, const float* startPos, const float* endPos,
+							  const dtQueryFilter* filter,
+							  float* resultPos, dtPolyRef* visited, int* visitedCount, const int maxVisitedSize) const;
+
+	/// Casts a 'walkability' ray along the surface of the navigation mesh from 
+	/// the start position toward the end position.
+	///  @param[in]		startRef	The reference id of the start polygon.
+	///  @param[in]		startPos	A position within the start polygon representing 
+	///  							the start of the ray. [(x, y, z)]
+	///  @param[in]		endPos		The position to cast the ray toward. [(x, y, z)]
+	///  @param[out]	t			The hit parameter. (FLT_MAX if no wall hit.)
+	///  @param[out]	hitNormal	The normal of the nearest wall hit. [(x, y, z)]
+	///  @param[in]		filter		The polygon filter to apply to the query.
+	///  @param[out]	path		The reference ids of the visited polygons. [opt]
+	///  @param[out]	pathCount	The number of visited polygons. [opt]
+	///  @param[in]		maxPath		The maximum number of polygons the @p path array can hold.
+	/// @returns The status flags for the query.
+	dtStatus raycast(dtPolyRef startRef, const float* startPos, const float* endPos,
+					 const dtQueryFilter* filter,
+					 float* t, float* hitNormal, dtPolyRef* path, int* pathCount, const int maxPath) const;
+
+	/// Finds the distance from the specified position to the nearest polygon wall.
+	///  @param[in]		startRef		The reference id of the polygon containing @p centerPos.
+	///  @param[in]		centerPos		The center of the search circle. [(x, y, z)]
+	///  @param[in]		maxRadius		The radius of the search circle.
+	///  @param[in]		filter			The polygon filter to apply to the query.
+	///  @param[out]	hitDist			The distance to the nearest wall from @p centerPos.
+	///  @param[out]	hitPos			The nearest position on the wall that was hit. [(x, y, z)]
+	///  @param[out]	hitNormal		The normalized ray formed from the wall point to the 
+	///  								source point. [(x, y, z)]
+	/// @returns The status flags for the query.
+	dtStatus findDistanceToWall(dtPolyRef startRef, const float* centerPos, const float maxRadius,
+								const dtQueryFilter* filter,
+								float* hitDist, float* hitPos, float* hitNormal) const;
+
+	/// Returns the segments for the specified polygon, optionally including portals.
+	///  @param[in]		ref				The reference id of the polygon.
+	///  @param[in]		filter			The polygon filter to apply to the query.
+	///  @param[out]	segmentVerts	The segments. [(ax, ay, az, bx, by, bz) * segmentCount]
+	///  @param[out]	segmentRefs		The reference ids of each segment's neighbor polygon. 
+	///  								Or zero if the segment is a wall. [opt] [(parentRef) * @p segmentCount] 
+	///  @param[out]	segmentCount	The number of segments returned.
+	///  @param[in]		maxSegments		The maximum number of segments the result arrays can hold.
+	/// @returns The status flags for the query.
 	dtStatus getPolyWallSegments(dtPolyRef ref, const dtQueryFilter* filter,
-								 float* segments, int* segmentCount, const int maxSegments) const;
-	
-	// Returns closest point on navigation polygon.
-	// Uses detail polygons to find the closest point to the navigation polygon surface. 
-	// Params:
-	//	ref - (in) ref to the polygon.
-	//	pos[3] - (in) the point to check.
-	//	closest[3] - (out) closest point.
-	// Returns: true if closest point found.
+								 float* segmentVerts, dtPolyRef* segmentRefs, int* segmentCount,
+								 const int maxSegments) const;
+
+	/// Finds the closest point on the specified polygon.
+	///  @param[in]		ref			The reference id of the polygon.
+	///  @param[in]		pos			The position to check. [(x, y, z)]
+	///  @param[out]	closest		The closest point on the polygon. [(x, y, z)]
+	/// @returns The status flags for the query.
 	dtStatus closestPointOnPoly(dtPolyRef ref, const float* pos, float* closest) const;
-	
-	// Returns closest point on navigation polygon boundary.
-	// Uses the navigation polygon boundary to snap the point to poly boundary
-	// if it is outside the polygon. Much faster than closestPointToPoly. Does not affect height.
-	// Params:
-	//	ref - (in) ref to the polygon.
-	//	pos[3] - (in) the point to check.
-	//	closest[3] - (out) closest point.
-	// Returns: true if closest point found.
+
+	/// Returns a point on the boundary closest to the source point if the source point is outside the 
+	/// polygon's xz-bounds.
+	///  @param[in]		ref			The reference id to the polygon.
+	///  @param[in]		pos			The position to check. [(x, y, z)]
+	///  @param[out]	closest		The closest point. [(x, y, z)]
+	/// @returns The status flags for the query.
 	dtStatus closestPointOnPolyBoundary(dtPolyRef ref, const float* pos, float* closest) const;
-	
-	// Returns start and end location of an off-mesh link polygon.
-	// Params:
-	//	prevRef - (in) ref to the polygon before the link (used to select direction).
-	//	polyRef - (in) ref to the off-mesh link polygon.
-	//	startPos[3] - (out) start point of the link.
-	//	endPos[3] - (out) end point of the link.
-	// Returns: true if link is found.
-	dtStatus getOffMeshConnectionPolyEndPoints(dtPolyRef prevRef, dtPolyRef polyRef, float* startPos, float* endPos) const;
-	
-	// Returns height of the polygon at specified location.
-	// Params:
-	//	ref - (in) ref to the polygon.
-	//	pos[3] - (in) the point where to locate the height.
-	//	height - (out) height at the location.
-	// Returns: true if over polygon.
+
+	/// Gets the height of the polygon at the provided position using the height detail. (Most accurate.)
+	///  @param[in]		ref			The reference id of the polygon.
+	///  @param[in]		pos			A position within the xz-bounds of the polygon. [(x, y, z)]
+	///  @param[out]	height		The height at the surface of the polygon.
+	/// @returns The status flags for the query.
 	dtStatus getPolyHeight(dtPolyRef ref, const float* pos, float* height) const;
-		
-	// Returns true if poly reference ins in closed list.
+
+	/// @}
+	/// @name Miscellaneous Functions
+	/// @{
+
+	/// Returns true if the polygon reference is valid and passes the filter restrictions.
+	///  @param[in]		ref			The polygon reference to check.
+	///  @param[in]		filter		The filter to apply.
+	bool isValidPolyRef(dtPolyRef ref, const dtQueryFilter* filter) const;
+
+	/// Returns true if the polygon reference is in the closed list. 
+	///  @param[in]		ref		The reference id of the polygon to check.
+	/// @returns True if the polygon is in closed list.
 	bool isInClosedList(dtPolyRef ref) const;
-	
+
+	/// Gets the node pool.
+	/// @returns The node pool.
 	class dtNodePool* getNodePool() const { return m_nodePool; }
-	
+
+	/// Gets the navigation mesh the query object is using.
+	/// @return The navigation mesh the query object is using.
+	const dtNavMesh* getAttachedNavMesh() const { return m_nav; }
+
+	/// @}
+
 private:
-	
-	// Returns neighbour tile based on side. 
+
+	/// Returns neighbour tile based on side.
 	dtMeshTile* getNeighbourTileAt(int x, int y, int side) const;
 
-	// Queries polygons within a tile.
+	/// Queries polygons within a tile.
 	int queryPolygonsInTile(const dtMeshTile* tile, const float* qmin, const float* qmax, const dtQueryFilter* filter,
 							dtPolyRef* polys, const int maxPolys) const;
-	// Find nearest polygon within a tile.
+	/// Find nearest polygon within a tile.
 	dtPolyRef findNearestPolyInTile(const dtMeshTile* tile, const float* center, const float* extents,
 									const dtQueryFilter* filter, float* nearestPt) const;
-	// Returns closest point on polygon.
-	dtStatus closestPointOnPolyInTile(const dtMeshTile* tile, const dtPoly* poly, const float* pos, float* closest) const;
-	
-	// Returns portal points between two polygons.
+	/// Returns closest point on polygon.
+	void closestPointOnPolyInTile(const dtMeshTile* tile, const dtPoly* poly, const float* pos, float* closest) const;
+
+	/// Returns portal points between two polygons.
 	dtStatus getPortalPoints(dtPolyRef from, dtPolyRef to, float* left, float* right,
 							 unsigned char& fromType, unsigned char& toType) const;
 	dtStatus getPortalPoints(dtPolyRef from, const dtPoly* fromPoly, const dtMeshTile* fromTile,
 							 dtPolyRef to, const dtPoly* toPoly, const dtMeshTile* toTile,
 							 float* left, float* right) const;
-	
-	// Returns edge mid point between two polygons.
+
+	/// Returns edge mid point between two polygons.
 	dtStatus getEdgeMidPoint(dtPolyRef from, dtPolyRef to, float* mid) const;
 	dtStatus getEdgeMidPoint(dtPolyRef from, const dtPoly* fromPoly, const dtMeshTile* fromTile,
 							 dtPolyRef to, const dtPoly* toPoly, const dtMeshTile* toTile,
 							 float* mid) const;
-	
-	const dtNavMesh* m_nav;				// Pointer to navmesh data.
 
+	const dtNavMesh* m_nav;				///< Pointer to navmesh data.
+
 	struct dtQueryData
 	{
 		dtStatus status;
@@ -393,15 +433,21 @@
 		float startPos[3], endPos[3];
 		const dtQueryFilter* filter;
 	};
-	dtQueryData m_query;				// Sliced query state.
+	dtQueryData m_query;				///< Sliced query state.
 
-	class dtNodePool* m_tinyNodePool;	// Pointer to small node pool.
-	class dtNodePool* m_nodePool;		// Pointer to node pool.
-	class dtNodeQueue* m_openList;		// Pointer to open list queue.
+	class dtNodePool* m_tinyNodePool;	///< Pointer to small node pool.
+	class dtNodePool* m_nodePool;		///< Pointer to node pool.
+	class dtNodeQueue* m_openList;		///< Pointer to open list queue.
 };
 
-// Helper function to allocate navmesh query class using Detour allocator.
+/// Allocates a query object using the Detour allocator.
+/// @return An allocated query object, or null on failure.
+/// @ingroup detour
 dtNavMeshQuery* mallocNavMeshQuery();
+
+/// Frees the specified query object using the Detour allocator.
+///  @param[in]		query		A query object allocated using #mallocNavMeshQuery
+/// @ingroup detour
 void freeNavMeshQuery(dtNavMeshQuery* query);
 
 #endif // DETOURNAVMESHQUERY_H
Index: src/hearthstone-shared/Pathfinding/Detour/DetourNode.cpp
===================================================================
--- src/hearthstone-shared/Pathfinding/Detour/DetourNode.cpp	(revision 1490)
+++ src/hearthstone-shared/Pathfinding/Detour/DetourNode.cpp	(working copy)
@@ -23,13 +23,13 @@
 
 inline unsigned int dtHashRef(dtPolyRef a)
 {
-    a = (~a) + (a << 18);
-    a = a ^ (a >> 31);
-    a = a * 21;
-    a = a ^ (a >> 11);
-    a = a + (a << 6);
-    a = a ^ (a >> 22);
-    return (unsigned int)a;
+	a += ~(a<<15);
+	a ^=  (a>>10);
+	a +=  (a<<3);
+	a ^=  (a>>6);
+	a += ~(a<<11);
+	a ^=  (a>>16);
+	return (unsigned int)a;
 }
 
 //////////////////////////////////////////////////////////////////////////////////////////
@@ -45,15 +45,15 @@
 	ASSERT(m_maxNodes > 0);
 
 	m_nodes = (dtNode*)malloc(sizeof(dtNode)*m_maxNodes);
-	m_next = (unsigned short*)malloc(sizeof(unsigned short)*m_maxNodes);
-	m_first = (unsigned short*)malloc(sizeof(unsigned short)*hashSize);
+	m_next = (dtNodeIndex*)malloc(sizeof(dtNodeIndex)*m_maxNodes);
+	m_first = (dtNodeIndex*)malloc(sizeof(dtNodeIndex)*hashSize);
 
 	ASSERT(m_nodes);
 	ASSERT(m_next);
 	ASSERT(m_first);
 
-	memset(m_first, 0xff, sizeof(unsigned short)*m_hashSize);
-	memset(m_next, 0xff, sizeof(unsigned short)*m_maxNodes);
+	memset(m_first, 0xff, sizeof(dtNodeIndex)*m_hashSize);
+	memset(m_next, 0xff, sizeof(dtNodeIndex)*m_maxNodes);
 }
 
 dtNodePool::~dtNodePool()
@@ -65,14 +65,14 @@
 
 void dtNodePool::clear()
 {
-	memset(m_first, 0xff, sizeof(unsigned short)*m_hashSize);
+	memset(m_first, 0xff, sizeof(dtNodeIndex)*m_hashSize);
 	m_nodeCount = 0;
 }
 
 dtNode* dtNodePool::findNode(dtPolyRef id)
 {
 	unsigned int bucket = dtHashRef(id) & (m_hashSize-1);
-	unsigned short i = m_first[bucket];
+	dtNodeIndex i = m_first[bucket];
 	while (i != DT_NULL_IDX)
 	{
 		if (m_nodes[i].id == id)
@@ -85,7 +85,7 @@
 dtNode* dtNodePool::getNode(dtPolyRef id)
 {
 	unsigned int bucket = dtHashRef(id) & (m_hashSize-1);
-	unsigned short i = m_first[bucket];
+	dtNodeIndex i = m_first[bucket];
 	dtNode* node = 0;
 	while (i != DT_NULL_IDX)
 	{
@@ -93,13 +93,13 @@
 			return &m_nodes[i];
 		i = m_next[i];
 	}
-	
+
 	if (m_nodeCount >= m_maxNodes)
 		return 0;
-	
-	i = (unsigned short)m_nodeCount;
+
+	i = (dtNodeIndex)m_nodeCount;
 	m_nodeCount++;
-	
+
 	// Init node
 	node = &m_nodes[i];
 	node->pidx = 0;
@@ -107,10 +107,10 @@
 	node->total = 0;
 	node->id = id;
 	node->flags = 0;
-	
+
 	m_next[i] = m_first[bucket];
 	m_first[bucket] = i;
-	
+
 	return node;
 }
 
@@ -122,7 +122,7 @@
 	m_size(0)
 {
 	ASSERT(m_capacity > 0);
-	
+
 	m_heap = (dtNode**)malloc(sizeof(dtNode*)*(m_capacity+1));
 	ASSERT(m_heap);
 }
Index: src/hearthstone-shared/Pathfinding/Detour/DetourNode.h
===================================================================
--- src/hearthstone-shared/Pathfinding/Detour/DetourNode.h	(revision 1490)
+++ src/hearthstone-shared/Pathfinding/Detour/DetourNode.h	(working copy)
@@ -27,18 +27,20 @@
 	DT_NODE_CLOSED = 0x02,
 };
 
-static const unsigned short DT_NULL_IDX = 0xffff;
+typedef unsigned short dtNodeIndex;
+static const dtNodeIndex DT_NULL_IDX = (dtNodeIndex)~0;
 
 struct dtNode
 {
-	float pos[3];				// Position of the node.
-	float cost;					// Cost from previous node to current node.
-	float total;				// Cost up to the node.
-	unsigned int pidx : 30;		// Index to parent node.
-	unsigned int flags : 2;		// Node flags 0/open/closed.
-	dtPolyRef id;				// Polygon ref the node corresponds to.
+	float pos[3];				///< Position of the node.
+	float cost;					///< Cost from previous node to current node.
+	float total;				///< Cost up to the node.
+	unsigned int pidx : 30;		///< Index to parent node.
+	unsigned int flags : 2;		///< Node flags 0/open/closed.
+	dtPolyRef id;				///< Polygon ref the node corresponds to.
 };
 
+
 class dtNodePool
 {
 public:
@@ -66,26 +68,26 @@
 		if (!idx) return 0;
 		return &m_nodes[idx-1];
 	}
-	
+
 	inline int getMemUsed() const
 	{
 		return sizeof(*this) +
-		sizeof(dtNode)*m_maxNodes +
-		sizeof(unsigned short)*m_maxNodes +
-		sizeof(unsigned short)*m_hashSize;
+			sizeof(dtNode)*m_maxNodes +
+			sizeof(dtNodeIndex)*m_maxNodes +
+			sizeof(dtNodeIndex)*m_hashSize;
 	}
-	
+
 	inline int getMaxNodes() const { return m_maxNodes; }
-	
+
 	inline int getHashSize() const { return m_hashSize; }
-	inline unsigned short getFirst(int bucket) const { return m_first[bucket]; }
-	inline unsigned short getNext(int i) const { return m_next[i]; }
-	
+	inline dtNodeIndex getFirst(int bucket) const { return m_first[bucket]; }
+	inline dtNodeIndex getNext(int i) const { return m_next[i]; }
+
 private:
-	
+
 	dtNode* m_nodes;
-	unsigned short* m_first;
-	unsigned short* m_next;
+	dtNodeIndex* m_first;
+	dtNodeIndex* m_next;
 	const int m_maxNodes;
 	const int m_hashSize;
 	int m_nodeCount;
@@ -97,17 +99,17 @@
 	dtNodeQueue(int n);
 	~dtNodeQueue();
 	inline void operator=(dtNodeQueue&) {}
-	
+
 	inline void clear()
 	{
 		m_size = 0;
 	}
-	
+
 	inline dtNode* top()
 	{
 		return m_heap[0];
 	}
-	
+
 	inline dtNode* pop()
 	{
 		dtNode* result = m_heap[0];
@@ -115,13 +117,13 @@
 		trickleDown(0, m_heap[m_size]);
 		return result;
 	}
-	
+
 	inline void push(dtNode* node)
 	{
 		m_size++;
 		bubbleUp(m_size-1, node);
 	}
-	
+
 	inline void modify(dtNode* node)
 	{
 		for (int i = 0; i < m_size; ++i)
@@ -133,25 +135,25 @@
 			}
 		}
 	}
-	
+
 	inline bool empty() const { return m_size == 0; }
-	
+
 	inline int getMemUsed() const
 	{
 		return sizeof(*this) +
 		sizeof(dtNode*)*(m_capacity+1);
 	}
-	
+
 	inline int getCapacity() const { return m_capacity; }
-	
+
 private:
 	void bubbleUp(int i, dtNode* node);
 	void trickleDown(int i, dtNode* node);
-	
+
 	dtNode** m_heap;
 	const int m_capacity;
 	int m_size;
-};		
+};
 
 
-#endif // DETOURNODE_H
\ No newline at end of file
+#endif // DETOURNODE_H
Index: src/hearthstone-shared/Pathfinding/Recast/Recast.cpp
===================================================================
--- src/hearthstone-shared/Pathfinding/Recast/Recast.cpp	(revision 1490)
+++ src/hearthstone-shared/Pathfinding/Recast/Recast.cpp	(working copy)
@@ -37,6 +37,26 @@
 	m_size = n;
 }
 
+/// @class rcContext
+/// @par
+///
+/// This class does not provide logging or timer functionality on its
+/// own.  Both must be provided by a concrete implementation
+/// by overriding the protected member functions.  Also, this class does not
+/// provide an interface for extracting log messages. (Only adding them.)
+/// So concrete implementations must provide one.
+///
+/// If no logging or timers are required, just pass an instance of this
+/// class through the Recast build process.
+///
+
+/// @par
+///
+/// Example:
+/// @code
+/// // Where ctx is an instance of rcContext and filepath is a char array.
+/// ctx->log(RC_LOG_ERROR, "buildTiledNavigation: Could not load '%s'", filepath);
+/// @endcode
 void rcContext::log(const rcLogCategory category, const char* format, ...)
 {
 	if (!m_logEnabled)
@@ -94,6 +114,28 @@
 	free(chf);
 }
 
+
+rcHeightfieldLayerSet* mallocHeightfieldLayerSet()
+{
+	rcHeightfieldLayerSet* lset = (rcHeightfieldLayerSet*)malloc(sizeof(rcHeightfieldLayerSet));
+	memset(lset, 0, sizeof(rcHeightfieldLayerSet));
+	return lset;
+}
+
+void freeHeightfieldLayerSet(rcHeightfieldLayerSet* lset)
+{
+	if (!lset) return;
+	for (int i = 0; i < lset->nlayers; ++i)
+	{
+		free(lset->layers[i].heights);
+		free(lset->layers[i].areas);
+		free(lset->layers[i].cons);
+	}
+	free(lset->layers);
+	free(lset);
+}
+
+
 rcContourSet* mallocContourSet()
 {
 	rcContourSet* cset = (rcContourSet*)malloc(sizeof(rcContourSet));
@@ -147,7 +189,6 @@
 	free(dmesh);
 }
 
-
 void rcCalcBounds(const float* verts, int nv, float* bmin, float* bmax)
 {
 	// Calculate bounding box.
@@ -167,13 +208,18 @@
 	*h = (int)((bmax[2] - bmin[2])/cs+0.5f);
 }
 
+/// @par
+///
+/// See the #rcConfig documentation for more information on the configuration parameters.
+///
+/// @see mallocHeightfield, rcHeightfield
 bool rcCreateHeightfield(rcContext* /*ctx*/, rcHeightfield& hf, int width, int height,
 						 const float* bmin, const float* bmax,
 						 float cs, float ch)
 {
 	// TODO: VC complains about unref formal variable, figure out a way to handle this better.
 //	ASSERT(ctx);
-	
+
 	hf.width = width;
 	hf.height = height;
 	rcVcopy(hf.bmin, bmin);
@@ -196,6 +242,14 @@
 	rcVnormalize(norm);
 }
 
+/// @par
+///
+/// Only sets the aread id's for the walkable triangles.  Does not alter the
+/// area id's for unwalkable triangles.
+///
+/// See the #rcConfig documentation for more information on the configuration parameters.
+///
+/// @see rcHeightfield, rcClearUnwalkableTriangles, rcRasterizeTriangles
 void rcMarkWalkableTriangles(rcContext* /*ctx*/, const float walkableSlopeAngle,
 							 const float* verts, int /*nv*/,
 							 const int* tris, int nt,
@@ -203,11 +257,11 @@
 {
 	// TODO: VC complains about unref formal variable, figure out a way to handle this better.
 //	ASSERT(ctx);
-	
+
 	const float walkableThr = cosf(walkableSlopeAngle/180.0f*RC_PI);
 
 	float norm[3];
-	
+
 	for (int i = 0; i < nt; ++i)
 	{
 		const int* tri = &tris[i*3];
@@ -218,6 +272,14 @@
 	}
 }
 
+/// @par
+///
+/// Only sets the aread id's for the unwalkable triangles.  Does not alter the
+/// area id's for walkable triangles.
+///
+/// See the #rcConfig documentation for more information on the configuration parameters.
+///
+/// @see rcHeightfield, rcClearUnwalkableTriangles, rcRasterizeTriangles
 void rcClearUnwalkableTriangles(rcContext* /*ctx*/, const float walkableSlopeAngle,
 								const float* verts, int /*nv*/,
 								const int* tris, int nt,
@@ -225,11 +287,11 @@
 {
 	// TODO: VC complains about unref formal variable, figure out a way to handle this better.
 //	ASSERT(ctx);
-	
+
 	const float walkableThr = cosf(walkableSlopeAngle/180.0f*RC_PI);
-	
+
 	float norm[3];
-	
+
 	for (int i = 0; i < nt; ++i)
 	{
 		const int* tri = &tris[i*3];
@@ -244,7 +306,7 @@
 {
 	// TODO: VC complains about unref formal variable, figure out a way to handle this better.
 //	ASSERT(ctx);
-	
+
 	const int w = hf.width;
 	const int h = hf.height;
 	int spanCount = 0;
@@ -262,13 +324,22 @@
 	return spanCount;
 }
 
+/// @par
+///
+/// This is just the beginning of the process of fully building a compact heightfield.
+/// Various filters may be applied applied, then the distance field and regions built.
+/// E.g: #rcBuildDistanceField and #rcBuildRegions
+///
+/// See the #rcConfig documentation for more information on the configuration parameters.
+///
+/// @see mallocCompactHeightfield, rcHeightfield, rcCompactHeightfield, rcConfig
 bool rcBuildCompactHeightfield(rcContext* ctx, const int walkableHeight, const int walkableClimb,
 							   rcHeightfield& hf, rcCompactHeightfield& chf)
 {
 	ASSERT(ctx);
-	
+
 	ctx->startTimer(RC_TIMER_BUILD_COMPACTHEIGHTFIELD);
-	
+
 	const int w = hf.width;
 	const int h = hf.height;
 	const int spanCount = rcGetHeightFieldSpanCount(ctx, hf);
@@ -306,9 +377,9 @@
 		return false;
 	}
 	memset(chf.areas, RC_NULL_AREA, sizeof(unsigned char)*spanCount);
-	
+
 	const int MAX_HEIGHT = 0xffff;
-	
+
 	// Fill in cells and spans.
 	int idx = 0;
 	for (int y = 0; y < h; ++y)
@@ -349,7 +420,7 @@
 			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)
 			{
 				rcCompactSpan& s = chf.spans[i];
-				
+
 				for (int dir = 0; dir < 4; ++dir)
 				{
 					rcSetCon(s, dir, RC_NOT_CONNECTED);
@@ -358,7 +429,7 @@
 					// First check that the neighbour cell is in bounds.
 					if (nx < 0 || ny < 0 || nx >= w || ny >= h)
 						continue;
-						
+
 					// Iterate over all neighbour spans and check if any of the is
 					// accessible from current cell.
 					const rcCompactCell& nc = chf.cells[nx+ny*w];
@@ -383,20 +454,19 @@
 							break;
 						}
 					}
-					
 				}
 			}
 		}
 	}
-	
+
 	if (tooHighNeighbour > MAX_LAYERS)
 	{
 		ctx->log(RC_LOG_ERROR, "rcBuildCompactHeightfield: Heightfield has too many layers %d (max: %d)",
 				 tooHighNeighbour, MAX_LAYERS);
 	}
-		
+
 	ctx->stopTimer(RC_TIMER_BUILD_COMPACTHEIGHTFIELD);
-	
+
 	return true;
 }
 
@@ -406,7 +476,7 @@
 	int size = 0;
 	size += sizeof(hf);
 	size += hf.width * hf.height * sizeof(rcSpan*);
-	
+
 	rcSpanPool* pool = hf.pools;
 	while (pool)
 	{
Index: src/hearthstone-shared/Pathfinding/Recast/Recast.h
===================================================================
--- src/hearthstone-shared/Pathfinding/Recast/Recast.h	(revision 1490)
+++ src/hearthstone-shared/Pathfinding/Recast/Recast.h	(working copy)
@@ -15,52 +15,87 @@
 //    misrepresented as being the original software.
 // 3. This notice may not be removed or altered from any source distribution.
 //
- 
+
 #ifndef RECAST_H
 #define RECAST_H
 
-// Some math headers don't have PI defined.
+/// The value of PI used by Recast.
 static const float RC_PI = 3.14159265f;
 
+/// Recast log categories.
+/// @see rcContext
 enum rcLogCategory
 {
-	RC_LOG_PROGRESS = 1,
-	RC_LOG_WARNING,
-	RC_LOG_ERROR,
+	RC_LOG_PROGRESS = 1,	///< A progress log entry.
+	RC_LOG_WARNING,			///< A warning log entry.
+	RC_LOG_ERROR,			///< An error log entry.
 };
 
+/// Recast performance timer categories.
+/// @see rcContext
 enum rcTimerLabel
 {
+	/// The user defined total time of the build.
 	RC_TIMER_TOTAL,
+	/// A user defined build time.
 	RC_TIMER_TEMP,
+	/// The time to rasterize the triangles. (See: #rcRasterizeTriangle)
 	RC_TIMER_RASTERIZE_TRIANGLES,
+	/// The time to build the compact heightfield. (See: #rcBuildCompactHeightfield)
 	RC_TIMER_BUILD_COMPACTHEIGHTFIELD,
+	/// The total time to build the contours. (See: #rcBuildContours)
 	RC_TIMER_BUILD_CONTOURS,
+	/// The time to trace the boundaries of the contours. (See: #rcBuildContours)
 	RC_TIMER_BUILD_CONTOURS_TRACE,
+	/// The time to simplify the contours. (See: #rcBuildContours)
 	RC_TIMER_BUILD_CONTOURS_SIMPLIFY,
+	/// The time to filter ledge spans. (See: #rcFilterLedgeSpans)
 	RC_TIMER_FILTER_BORDER,
+	/// The time to filter low height spans. (See: #rcFilterWalkableLowHeightSpans)
 	RC_TIMER_FILTER_WALKABLE,
+	/// The time to apply the median filter. (See: #rcMedianFilterWalkableArea)
 	RC_TIMER_MEDIAN_AREA,
+	/// The time to filter low obstacles. (See: #rcFilterLowHangingWalkableObstacles)
 	RC_TIMER_FILTER_LOW_OBSTACLES,
+	/// The time to build the polygon mesh. (See: #rcBuildPolyMesh)
 	RC_TIMER_BUILD_POLYMESH,
+	/// The time to merge polygon meshes. (See: #rcMergePolyMeshes)
 	RC_TIMER_MERGE_POLYMESH,
+	/// The time to erode the walkable area. (See: #rcErodeWalkableArea)
 	RC_TIMER_ERODE_AREA,
+	/// The time to mark a box area. (See: #rcMarkBoxArea)
 	RC_TIMER_MARK_BOX_AREA,
+	/// The time to mark a cylinder area. (See: #rcMarkCylinderArea)
+	RC_TIMER_MARK_CYLINDER_AREA,
+	/// The time to mark a convex polygon area. (See: #rcMarkConvexPolyArea)
 	RC_TIMER_MARK_CONVEXPOLY_AREA,
+	/// The total time to build the distance field. (See: #rcBuildDistanceField)
 	RC_TIMER_BUILD_DISTANCEFIELD,
+	/// The time to build the distances of the distance field. (See: #rcBuildDistanceField)
 	RC_TIMER_BUILD_DISTANCEFIELD_DIST,
+	/// The time to blur the distance field. (See: #rcBuildDistanceField)
 	RC_TIMER_BUILD_DISTANCEFIELD_BLUR,
+	/// The total time to build the regions. (See: #rcBuildRegions, #rcBuildRegionsMonotone)
 	RC_TIMER_BUILD_REGIONS,
+	/// The total time to apply the watershed algorithm. (See: #rcBuildRegions)
 	RC_TIMER_BUILD_REGIONS_WATERSHED,
+	/// The time to expand regions while applying the watershed algorithm. (See: #rcBuildRegions)
 	RC_TIMER_BUILD_REGIONS_EXPAND,
+	/// The time to flood regions while applying the watershed algorithm. (See: #rcBuildRegions)
 	RC_TIMER_BUILD_REGIONS_FLOOD,
+	/// The time to filter out small regions. (See: #rcBuildRegions, #rcBuildRegionsMonotone)
 	RC_TIMER_BUILD_REGIONS_FILTER,
+	/// The time to build heightfield layers. (See: #rcBuildHeightfieldLayers)
+	RC_TIMER_BUILD_LAYERS,
+	/// The time to build the polygon mesh detail. (See: #rcBuildPolyMeshDetail)
 	RC_TIMER_BUILD_POLYMESHDETAIL,
+	/// The time to merge polygon mesh details. (See: #rcMergePolyMeshDetails)
 	RC_TIMER_MERGE_POLYMESHDETAIL,
+	/// The maximum number of timers.  (Used for iterating timers.)
 	RC_MAX_TIMERS
 };
 
-// Simple dynamic array ints.
+/// A simple dynamic array of integers.
 class rcIntArray
 {
 	int* m_data;
@@ -68,309 +103,563 @@
 	inline rcIntArray(const rcIntArray&);
 	inline rcIntArray& operator=(const rcIntArray&);
 public:
+
+	/// Constructs an instance with an initial array size of zero.
 	inline rcIntArray() : m_data(0), m_size(0), m_cap(0) {}
+
+	/// Constructs an instance initialized to the specified size.
+	///  @param[in]		n	The initial size of the integer array.
 	inline rcIntArray(int n) : m_data(0), m_size(0), m_cap(0) { resize(n); }
 	inline ~rcIntArray() { free(m_data); }
+
+	/// Specifies the new size of the integer array.
+	///  @param[in]		n	The new size of the integer array.
 	void resize(int n);
+
+	/// Push the specified integer onto the end of the array and increases the size by one.
+	///  @param[in]		item	The new value.
 	inline void push(int item) { resize(m_size+1); m_data[m_size-1] = item; }
+
+	/// Returns the value at the end of the array and reduces the size by one.
+	///  @return The value at the end of the array.
 	inline int pop() { if (m_size > 0) m_size--; return m_data[m_size]; }
+
+	/// The value at the specified array index.
+	/// @warning Does not provide overflow protection.
+	///  @param[in]		i	The index of the value.
 	inline const int& operator[](int i) const { return m_data[i]; }
+
+	/// The value at the specified array index.
+	/// @warning Does not provide overflow protection.
+	///  @param[in]		i	The index of the value.
 	inline int& operator[](int i) { return m_data[i]; }
+
+	/// The current size of the integer array.
 	inline int size() const { return m_size; }
 };
 
-// Simple internal helper class to delete array in scope
+/// A simple helper class used to delete an array when it goes out of scope.
+/// @note This class is rarely if ever used by the end user.
 template<class T> class rcScopedDelete
 {
 	T* ptr;
 	inline T* operator=(T* p);
 public:
+
+	/// Constructs an instance with a null pointer.
 	inline rcScopedDelete() : ptr(0) {}
+
+	/// Constructs an instance with the specified pointer.
+	///  @param[in]		p	An pointer to an allocated array.
 	inline rcScopedDelete(T* p) : ptr(p) {}
 	inline ~rcScopedDelete() { free(ptr); }
+
+	/// The root array pointer.
+	///  @return The root array pointer.
 	inline operator T*() { return ptr; }
 };
 
-// Build context provides several optional utilities needed for the build process,
-// such as timing, logging, and build time collecting. 
+/// Provides an interface for optional logging and performance tracking of the Recast
+/// build process.
+/// @ingroup recast
 class rcContext
 {
 public:
+
+	/// Contructor.
+	///  @param[in]		state	TRUE if the logging and performance timers should be enabled.  [Default: true]
 	inline rcContext(bool state = true) : m_logEnabled(state), m_timerEnabled(state) {}
 	virtual ~rcContext() {}
 
-	// Enables or disables logging.
+	/// Enables or disables logging.
+	///  @param[in]		state	TRUE if logging should be enabled.
 	inline void enableLog(bool state) { m_logEnabled = state; }
-	// Resets log.
+
+	/// Clears all log entries.
 	inline void resetLog() { if (m_logEnabled) doResetLog(); }
-	// Logs a message.
+
+	/// Logs a message.
+	///  @param[in]		category	The category of the message.
+	///  @param[in]		format		The message.
 	void log(const rcLogCategory category, const char* format, ...);
 
-	// Enables or disables timer.
+	/// Enables or disables the performance timers.
+	///  @param[in]		state	TRUE if timers should be enabled.
 	inline void enableTimer(bool state) { m_timerEnabled = state; }
-	// Resets all timers.
+
+	/// Clears all peformance timers. (Resets all to unused.)
 	inline void resetTimers() { if (m_timerEnabled) doResetTimers(); }
-	// Starts timer, used for performance timing.
+
+	/// Starts the specified performance timer.
+	///  @param	label	The category of timer.
 	inline void startTimer(const rcTimerLabel label) { if (m_timerEnabled) doStartTimer(label); }
-	// Stops timer, used for performance timing.
+
+	/// Stops the specified performance timer.
+	///  @param	label	The category of the timer.
 	inline void stopTimer(const rcTimerLabel label) { if (m_timerEnabled) doStopTimer(label); }
-	// Returns time accumulated between timer start/stop.
+
+	/// Returns the total accumulated time of the specified performance timer.
+	///  @param	label	The category of the timer.
+	///  @return The accumulated time of the timer, or -1 if timers are disabled or the timer has never been started.
 	inline int getAccumulatedTime(const rcTimerLabel label) const { return m_timerEnabled ? doGetAccumulatedTime(label) : -1; }
 
 protected:
-	// Virtual functions to override for custom implementations.
+
+	/// Clears all log entries.
 	virtual void doResetLog() {}
+
+	/// Logs a message.
+	///  @param[in]		category	The category of the message.
+	///  @param[in]		msg			The formatted message.
+	///  @param[in]		len			The length of the formatted message.
 	virtual void doLog(const rcLogCategory /*category*/, const char* /*msg*/, const int /*len*/) {}
+
+	/// Clears all timers. (Resets all to unused.)
 	virtual void doResetTimers() {}
+
+	/// Starts the specified performance timer.
+	///  @param[in]		label	The category of timer.
 	virtual void doStartTimer(const rcTimerLabel /*label*/) {}
+
+	/// Stops the specified performance timer.
+	///  @param[in]		label	The category of the timer.
 	virtual void doStopTimer(const rcTimerLabel /*label*/) {}
+
+	/// Returns the total accumulated time of the specified performance timer.
+	///  @param[in]		label	The category of the timer.
+	///  @return The accumulated time of the timer, or -1 if timers are disabled or the timer has never been started.
 	virtual int doGetAccumulatedTime(const rcTimerLabel /*label*/) const { return -1; }
-	
+
+	/// True if logging is enabled.
 	bool m_logEnabled;
+
+	/// True if the performance timers are enabled.
 	bool m_timerEnabled;
 };
 
-
-// The units of the parameters are specified in parenthesis as follows:
-// (vx) voxels, (wu) world units
+/// Specifies a configuration to use when performing Recast builds.
+/// @ingroup recast
 struct rcConfig
 {
-	int width, height;				// Dimensions of the rasterized heightfield (vx)
-	int tileSize;					// Width and Height of a tile (vx)
-	int borderSize;					// Non-navigable Border around the heightfield (vx)
-	float cs, ch;					// Grid cell size and height (wu)
-	float bmin[3], bmax[3];			// Grid bounds (wu)
-	float walkableSlopeAngle;		// Maximum walkable slope angle in degrees.
-	int walkableHeight;				// Minimum height where the agent can still walk (vx)
-	int walkableClimb;				// Maximum height between grid cells the agent can climb (vx)
-	int walkableRadius;				// Radius of the agent in cells (vx)
-	int maxEdgeLen;					// Maximum contour edge length (vx)
-	float maxSimplificationError;	// Maximum distance error from contour to cells (vx)
-	int minRegionArea;				// Regions whose area is smaller than this threshold will be removed. (vx)
-	int mergeRegionArea;			// Regions whose area is smaller than this threshold will be merged (vx)
-	int maxVertsPerPoly;			// Max number of vertices per polygon
-	float detailSampleDist;			// Detail mesh sample spacing.
-	float detailSampleMaxError;		// Detail mesh simplification max sample error.
+	/// The width of the field along the x-axis. [Limit: >= 0] [Units: vx]
+	int width;
+
+	/// The height of the field along the z-axis. [Limit: >= 0] [Units: vx]
+	int height;
+
+	/// The width/height size of tile's on the xz-plane. [Limit: >= 0] [Units: vx]
+	int tileSize;
+
+	/// The size of the non-navigable border around the heightfield. [Limit: >=0] [Units: vx]
+	int borderSize;
+
+	/// The xz-plane cell size to use for fields. [Limit: > 0] [Units: wu]
+	float cs;
+
+	/// The y-axis cell size to use for fields. [Limit: > 0] [Units: wu]
+	float ch;
+
+	/// The minimum bounds of the field's AABB. [(x, y, z)] [Units: wu]
+	float bmin[3];
+
+	/// The maximum bounds of the field's AABB. [(x, y, z)] [Units: wu]
+	float bmax[3];
+
+	/// The maximum slope that is considered walkable. [Limits: 0 <= value < 90] [Units: Degrees]
+	float walkableSlopeAngle;
+
+	/// Minimum floor to 'ceiling' height that will still allow the floor area to
+	/// be considered walkable. [Limit: >= 3] [Units: vx]
+	int walkableHeight;
+
+	/// Maximum ledge height that is considered to still be traversable. [Limit: >=0] [Units: vx]
+	int walkableClimb;
+
+	/// The distance to erode/shrink the walkable area of the heightfield away from
+	/// obstructions.  [Limit: >=0] [Units: vx]
+	int walkableRadius;
+
+	/// The maximum allowed length for contour edges along the border of the mesh. [Limit: >=0] [Units: vx]
+	int maxEdgeLen;
+
+	/// The maximum distance a simplfied contour's border edges should deviate
+	/// the original raw contour. [Limit: >=0] [Units: wu]
+	float maxSimplificationError;
+
+	/// The minimum number of cells allowed to form isolated island areas. [Limit: >=0] [Units: vx]
+	int minRegionArea;
+
+	/// Any regions with a span count smaller than this value will, if possible,
+	/// be merged with larger regions. [Limit: >=0] [Units: vx]
+	int mergeRegionArea;
+
+	/// The maximum number of vertices allowed for polygons generated during the
+	/// contour to polygon conversion process. [Limit: >= 3]
+	int maxVertsPerPoly;
+
+	/// Sets the sampling distance to use when generating the detail mesh.
+	/// (For height detail only.) [Limits: 0 or >= 0.9] [Units: wu]
+	float detailSampleDist;
+
+	/// The maximum distance the detail mesh surface should deviate from heightfield
+	/// data. (For height detail only.) [Limit: >=0] [Units: wu]
+	float detailSampleMaxError;
 };
 
-// Define number of bits in the above structure for smin/smax.
-// The max height is used for clamping rasterized values.
-static const int RC_SPAN_HEIGHT_BITS = 16;
+/// Defines the number of bits allocated to rcSpan::smin and rcSpan::smax.
+static const int RC_SPAN_HEIGHT_BITS = 13;
+/// Defines the maximum value for rcSpan::smin and rcSpan::smax.
 static const int RC_SPAN_MAX_HEIGHT = (1<<RC_SPAN_HEIGHT_BITS)-1;
 
-// Heightfield span.
+/// The number of spans allocated per span spool.
+/// @see rcSpanPool
+static const int RC_SPANS_PER_POOL = 2048;
+
+/// Represents a span in a heightfield.
+/// @see rcHeightfield
 struct rcSpan
 {
-	unsigned int smin : 16;			// Span min height.
-	unsigned int smax : 16;			// Span max height.
-    unsigned char area;				// Span area type.
-	rcSpan* next;					// Next span in column.
+	unsigned int smin : 13;			///< The lower limit of the span. [Limit: < #smax]
+	unsigned int smax : 13;			///< The upper limit of the span. [Limit: <= #RC_SPAN_MAX_HEIGHT]
+	unsigned int area : 6;			///< The area id assigned to the span.
+	rcSpan* next;					///< The next span higher up in column.
 };
 
-// Number of spans allocated per pool.
-static const int RC_SPANS_PER_POOL = 2048;
-
-// Memory pool used for quick span allocation.
+/// A memory pool used for quick allocation of spans within a heightfield.
+/// @see rcHeightfield
 struct rcSpanPool
 {
-	rcSpanPool* next;					// Pointer to next pool.
-	rcSpan items[RC_SPANS_PER_POOL];	// Array of spans.
+	rcSpanPool* next;					///< The next span pool.
+	rcSpan items[RC_SPANS_PER_POOL];	///< Array of spans in the pool.
 };
 
-// Dynamic span-heightfield.
+/// A dynamic heightfield representing obstructed space.
+/// @ingroup recast
 struct rcHeightfield
 {
-	int width, height;			// Dimension of the heightfield.
-	float bmin[3], bmax[3];		// Bounding box of the heightfield
-	float cs, ch;				// Cell size and height.
-	rcSpan** spans;				// Heightfield of spans (width*height).
-	rcSpanPool* pools;			// Linked list of span pools.
-	rcSpan* freelist;			// Pointer to next free span.
+	int width;			///< The width of the heightfield. (Along the x-axis in cell units.)
+	int height;			///< The height of the heightfield. (Along the z-axis in cell units.)
+	float bmin[3];  	///< The minimum bounds in world space. [(x, y, z)]
+	float bmax[3];		///< The maximum bounds in world space. [(x, y, z)]
+	float cs;			///< The size of each cell. (On the xz-plane.)
+	float ch;			///< The height of each cell. (The minimum increment along the y-axis.)
+	rcSpan** spans;		///< Heightfield of spans (width*height).
+	rcSpanPool* pools;	///< Linked list of span pools.
+	rcSpan* freelist;	///< The next free span.
 };
 
-rcHeightfield* mallocHeightfield();
-void freeHeightField(rcHeightfield* hf);
-
-
+/// Provides information on the content of a cell column in a compact heightfield.
 struct rcCompactCell
 {
-	unsigned int index : 24;	// Index to first span in column.
-	unsigned int count : 8;		// Number of spans in this column.
+	unsigned int index : 24;	///< Index to the first span in the column.
+	unsigned int count : 8;		///< Number of spans in the column.
 };
 
+/// Represents a span of unobstructed space within a compact heightfield.
 struct rcCompactSpan
 {
-	unsigned short y;			// Bottom coordinate of the span.
-	unsigned short reg;
-	unsigned int con : 24;		// Connections to neighbour cells.
-	unsigned int h : 8;			// Height of the span.
+	unsigned short y;			///< The lower extent of the span. (Measured from the heightfield's base.)
+	unsigned short reg;			///< The id of the region the span belongs to. (Or zero if not in a region.)
+	unsigned int con : 24;		///< Packed neighbor connection data.
+	unsigned int h : 8;			///< The height of the span.  (Measured from #y.)
 };
 
-// Compact static heightfield. 
+/// A compact, static heightfield representing unobstructed space.
+/// @ingroup recast
 struct rcCompactHeightfield
 {
-	int width, height;					// Width and height of the heightfield.
-	int spanCount;						// Number of spans in the heightfield.
-	int walkableHeight, walkableClimb;	// Agent properties.
-	unsigned short maxDistance;			// Maximum distance value stored in heightfield.
-	unsigned short maxRegions;			// Maximum Region Id stored in heightfield.
-	float bmin[3], bmax[3];				// Bounding box of the heightfield.
-	float cs, ch;						// Cell size and height.
-	rcCompactCell* cells;				// Pointer to width*height cells.
-	rcCompactSpan* spans;				// Pointer to spans.
-	unsigned short* dist;				// Pointer to per span distance to border.
-	unsigned char* areas;				// Pointer to per span area ID.
+	int width;					///< The width of the heightfield. (Along the x-axis in cell units.)
+	int height;					///< The height of the heightfield. (Along the z-axis in cell units.)
+	int spanCount;				///< The number of spans in the heightfield.
+	int walkableHeight;			///< The walkable height used during the build of the field.  (See: rcConfig::walkableHeight)
+	int walkableClimb;			///< The walkable climb used during the build of the field. (See: rcConfig::walkableClimb)
+	int borderSize;				///< The AABB border size used during the build of the field. (See: rcConfig::borderSize)
+	unsigned short maxDistance;	///< The maximum distance value of any span within the field.
+	unsigned short maxRegions;	///< The maximum region id of any span within the field.
+	float bmin[3];				///< The minimum bounds in world space. [(x, y, z)]
+	float bmax[3];				///< The maximum bounds in world space. [(x, y, z)]
+	float cs;					///< The size of each cell. (On the xz-plane.)
+	float ch;					///< The height of each cell. (The minimum increment along the y-axis.)
+	rcCompactCell* cells;		///< Array of cells. [Size: #width*#height]
+	rcCompactSpan* spans;		///< Array of spans. [Size: #spanCount]
+	unsigned short* dist;		///< Array containing border distance data. [Size: #spanCount]
+	unsigned char* areas;		///< Array containing area id data. [Size: #spanCount]
 };
 
-rcCompactHeightfield* mallocCompactHeightfield();
-void freeCompactHeightfield(rcCompactHeightfield* chf);
+/// Represents a heightfield layer within a layer set.
+/// @see rcHeightfieldLayerSet
+struct rcHeightfieldLayer
+{
+	float bmin[3];				///< The minimum bounds in world space. [(x, y, z)]
+	float bmax[3];				///< The maximum bounds in world space. [(x, y, z)]
+	float cs;					///< The size of each cell. (On the xz-plane.)
+	float ch;					///< The height of each cell. (The minimum increment along the y-axis.)
+	int width;					///< The width of the heightfield. (Along the x-axis in cell units.)
+	int height;					///< The height of the heightfield. (Along the z-axis in cell units.)
+	int minx;					///< The minimum x-bounds of usable data.
+	int maxx;					///< The maximum x-bounds of usable data.
+	int miny;					///< The minimum y-bounds of usable data. (Along the z-axis.)
+	int maxy;					///< The maximum y-bounds of usable data. (Along the z-axis.)
+	int hmin;					///< The minimum height bounds of usable data. (Along the y-axis.)
+	int hmax;					///< The maximum height bounds of usable data. (Along the y-axis.)
+	unsigned char* heights;		///< The heightfield. [Size: (width - borderSize*2) * (h - borderSize*2)]
+	unsigned char* areas;		///< Area ids. [Size: Same as #heights]
+	unsigned char* cons;		///< Packed neighbor connection information. [Size: Same as #heights]
+};
 
+/// Represents a set of heightfield layers.
+/// @ingroup recast
+/// @see mallocHeightfieldLayerSet, freeHeightfieldLayerSet
+struct rcHeightfieldLayerSet
+{
+	rcHeightfieldLayer* layers;			///< The layers in the set. [Size: #nlayers]
+	int nlayers;						///< The number of layers in the set.
+};
 
+/// Represents a simple, non-overlapping contour in field space.
 struct rcContour
 {
-	int* verts;			// Vertex coordinates, each vertex contains 4 components.
-	int nverts;			// Number of vertices.
-	int* rverts;		// Raw vertex coordinates, each vertex contains 4 components.
-	int nrverts;		// Number of raw vertices.
-	unsigned short reg;	// Region ID of the contour.
-	unsigned char area;	// Area ID of the contour.
+	int* verts;			///< Simplified contour vertex and connection data. [Size: 4 * #nverts]
+	int nverts;			///< The number of vertices in the simplified contour.
+	int* rverts;		///< Raw contour vertex and connection data. [Size: 4 * #nrverts]
+	int nrverts;		///< The number of vertices in the raw contour.
+	unsigned short reg;	///< The region id of the contour.
+	unsigned char area;	///< The area id of the contour.
 };
 
+/// Represents a group of related contours.
+/// @ingroup recast
 struct rcContourSet
 {
-	rcContour* conts;		// Pointer to all contours.
-	int nconts;				// Number of contours.
-	float bmin[3], bmax[3];	// Bounding box of the heightfield.
-	float cs, ch;			// Cell size and height.
+	rcContour* conts;	///< An array of the contours in the set. [Size: #nconts]
+	int nconts;			///< The number of contours in the set.
+	float bmin[3];  	///< The minimum bounds in world space. [(x, y, z)]
+	float bmax[3];		///< The maximum bounds in world space. [(x, y, z)]
+	float cs;			///< The size of each cell. (On the xz-plane.)
+	float ch;			///< The height of each cell. (The minimum increment along the y-axis.)
+	int width;			///< The width of the set. (Along the x-axis in cell units.)
+	int height;			///< The height of the set. (Along the z-axis in cell units.)
+	int borderSize;		///< The AABB border size used to generate the source data from which the contours were derived.
 };
 
-rcContourSet* mallocContourSet();
-void freeContourSet(rcContourSet* cset);
-
-
-// Polymesh store a connected mesh of polygons.
-// The polygons are store in an array where each polygons takes
-// 'nvp*2' elements. The first 'nvp' elements are indices to vertices
-// and the second 'nvp' elements are indices to neighbour polygons.
-// If a polygon has less than 'bvp' vertices, the remaining indices
-// are set to RC_MESH_NULL_IDX. If an polygon edge does not have a neighbour
-// the neighbour index is set to RC_MESH_NULL_IDX.
-// Vertices can be transformed into world space as follows:
-//   x = bmin[0] + verts[i*3+0]*cs;
-//   y = bmin[1] + verts[i*3+1]*ch;
-//   z = bmin[2] + verts[i*3+2]*cs;
+/// Represents a polygon mesh suitable for use in building a navigation mesh.
+/// @ingroup recast
 struct rcPolyMesh
-{	
-	unsigned short* verts;	// Vertices of the mesh, 3 elements per vertex.
-	unsigned short* polys;	// Polygons of the mesh, nvp*2 elements per polygon.
-	unsigned short* regs;	// Region ID of the polygons.
-	unsigned short* flags;	// Per polygon flags.
-	unsigned char* areas;	// Area ID of polygons.
-	int nverts;				// Number of vertices.
-	int npolys;				// Number of polygons.
-	int maxpolys;			// Number of allocated polygons.
-	int nvp;				// Max number of vertices per polygon.
-	float bmin[3], bmax[3];	// Bounding box of the mesh.
-	float cs, ch;			// Cell size and height.
+{
+	unsigned short* verts;	///< The mesh vertices. [Form: (x, y, z) * #nverts]
+	unsigned short* polys;	///< Polygon and neighbor data. [Length: #maxpolys * 2 * #nvp]
+	unsigned short* regs;	///< The region id assigned to each polygon. [Length: #maxpolys]
+	unsigned short* flags;	///< The user defined flags for each polygon. [Length: #maxpolys]
+	unsigned char* areas;	///< The area id assigned to each polygon. [Length: #maxpolys]
+	int nverts;				///< The number of vertices.
+	int npolys;				///< The number of polygons.
+	int maxpolys;			///< The number of allocated polygons.
+	int nvp;				///< The maximum number of vertices per polygon.
+	float bmin[3];			///< The minimum bounds in world space. [(x, y, z)]
+	float bmax[3];			///< The maximum bounds in world space. [(x, y, z)]
+	float cs;				///< The size of each cell. (On the xz-plane.)
+	float ch;				///< The height of each cell. (The minimum increment along the y-axis.)
+	int borderSize;			///< The AABB border size used to generate the source data from which the mesh was derived.
 };
 
-rcPolyMesh* mallocPolyMesh();
-void freePolyMesh(rcPolyMesh* pmesh);
-
-
-// Detail mesh generated from a rcPolyMesh.
-// Each submesh represents a polygon in the polymesh and they are stored in
-// exactly same order. Each submesh is described as 4 values:
-// base vertex, vertex count, base triangle, triangle count. That is,
-//   const unsigned char* t = &dmesh.tris[(tbase+i)*3]; and
-//   const float* v = &dmesh.verts[(vbase+t[j])*3];
-// If the input polygon has 'n' vertices, those vertices are first in the
-// submesh vertex list. This allows to compres the mesh by not storing the
-// first vertices and using the polymesh vertices instead.
-// Max number of vertices per submesh is 127 and
-// max number of triangles per submesh is 255.
-
+/// Contains triangle meshes that represent detailed height data associated
+/// with the polygons in its associated polygon mesh object.
+/// @ingroup recast
 struct rcPolyMeshDetail
 {
-	unsigned int* meshes;	// Pointer to all mesh data.
-	float* verts;			// Pointer to all vertex data.
-	unsigned char* tris;	// Pointer to all triangle data.
-	int nmeshes;			// Number of meshes.
-	int nverts;				// Number of total vertices.
-	int ntris;				// Number of triangles.
+	unsigned int* meshes;	///< The sub-mesh data. [Size: 4*#nmeshes]
+	float* verts;			///< The mesh vertices. [Size: 3*#nverts]
+	unsigned char* tris;	///< The mesh triangles. [Size: 4*#ntris]
+	int nmeshes;			///< The number of sub-meshes defined by #meshes.
+	int nverts;				///< The number of vertices in #verts.
+	int ntris;				///< The number of triangles in #tris.
 };
 
+/// @name Allocation Functions
+/// Functions used to allocate and de-allocate Recast objects.
+/// @see mallocSetCustom
+/// @{
+
+/// Allocates a heightfield object using the Recast allocator.
+///  @return A heightfield that is ready for initialization, or null on failure.
+///  @ingroup recast
+///  @see rcCreateHeightfield, freeHeightField
+rcHeightfield* mallocHeightfield();
+
+/// Frees the specified heightfield object using the Recast allocator.
+///  @param[in]		hf	A heightfield allocated using #mallocHeightfield
+///  @ingroup recast
+///  @see mallocHeightfield
+void freeHeightField(rcHeightfield* hf);
+
+/// Allocates a compact heightfield object using the Recast allocator.
+///  @return A compact heightfield that is ready for initialization, or null on failure.
+///  @ingroup recast
+///  @see rcBuildCompactHeightfield, freeCompactHeightfield
+rcCompactHeightfield* mallocCompactHeightfield();
+
+/// Frees the specified compact heightfield object using the Recast allocator.
+///  @param[in]		chf		A compact heightfield allocated using #mallocCompactHeightfield
+///  @ingroup recast
+///  @see mallocCompactHeightfield
+void freeCompactHeightfield(rcCompactHeightfield* chf);
+
+/// Allocates a heightfield layer set using the Recast allocator.
+///  @return A heightfield layer set that is ready for initialization, or null on failure.
+///  @ingroup recast
+///  @see rcBuildHeightfieldLayers, freeHeightfieldLayerSet
+rcHeightfieldLayerSet* mallocHeightfieldLayerSet();
+
+/// Frees the specified heightfield layer set using the Recast allocator.
+///  @param[in]		lset	A heightfield layer set allocated using #mallocHeightfieldLayerSet
+///  @ingroup recast
+///  @see mallocHeightfieldLayerSet
+void freeHeightfieldLayerSet(rcHeightfieldLayerSet* lset);
+
+/// Allocates a contour set object using the Recast allocator.
+///  @return A contour set that is ready for initialization, or null on failure.
+///  @ingroup recast
+///  @see rcBuildContours, freeContourSet
+rcContourSet* mallocContourSet();
+
+/// Frees the specified contour set using the Recast allocator.
+///  @param[in]		cset	A contour set allocated using #mallocContourSet
+///  @ingroup recast
+///  @see mallocContourSet
+void freeContourSet(rcContourSet* cset);
+
+/// Allocates a polygon mesh object using the Recast allocator.
+///  @return A polygon mesh that is ready for initialization, or null on failure.
+///  @ingroup recast
+///  @see rcBuildPolyMesh, freePolyMesh
+rcPolyMesh* mallocPolyMesh();
+
+/// Frees the specified polygon mesh using the Recast allocator.
+///  @param[in]		pmesh	A polygon mesh allocated using #mallocPolyMesh
+///  @ingroup recast
+///  @see mallocPolyMesh
+void freePolyMesh(rcPolyMesh* pmesh);
+
+/// Allocates a detail mesh object using the Recast allocator.
+///  @return A detail mesh that is ready for initialization, or null on failure.
+///  @ingroup recast
+///  @see rcBuildPolyMeshDetail, freePolyMeshDetail
 rcPolyMeshDetail* mallocPolyMeshDetail();
+
+/// Frees the specified detail mesh using the Recast allocator.
+///  @param[in]		dmesh	A detail mesh allocated using #mallocPolyMeshDetail
+///  @ingroup recast
+///  @see mallocPolyMeshDetail
 void freePolyMeshDetail(rcPolyMeshDetail* dmesh);
 
+/// @}
 
-// If heightfield region ID has the following bit set, the region is on border area
-// and excluded from many calculations.
+/// Heighfield border flag.
+/// If a heightfield region ID has this bit set, then the region is a border
+/// region and its spans are considered unwalkable.
+/// (Used during the region and contour build process.)
+/// @see rcCompactSpan::reg
 static const unsigned short RC_BORDER_REG = 0x8000;
 
-// If contour region ID has the following bit set, the vertex will be later
-// removed in order to match the segments and vertices at tile boundaries.
+/// Border vertex flag.
+/// If a region ID has this bit set, then the associated element lies on
+/// a tile border. If a contour vertex's region ID has this bit set, the
+/// vertex will later be removed in order to match the segments and vertices
+/// at tile boundaries.
+/// (Used during the build process.)
+/// @see rcCompactSpan::reg, #rcContour::verts, #rcContour::rverts
 static const int RC_BORDER_VERTEX = 0x10000;
 
+/// Area border flag.
+/// If a region ID has this bit set, then the associated element lies on
+/// the border of an area.
+/// (Used during the region and contour build process.)
+/// @see rcCompactSpan::reg, #rcContour::verts, #rcContour::rverts
 static const int RC_AREA_BORDER = 0x20000;
 
+/// Contour build flags.
+/// @see rcBuildContours
 enum rcBuildContoursFlags
 {
-	RC_CONTOUR_TESS_WALL_EDGES = 0x01,	// Tessellate wall edges
-	RC_CONTOUR_TESS_AREA_EDGES = 0x02,	// Tessellate edges between areas.
+	RC_CONTOUR_TESS_WALL_EDGES = 0x01,	///< Tessellate solid (impassable) edges during contour simplification.
+	RC_CONTOUR_TESS_AREA_EDGES = 0x02,	///< Tessellate edges between areas during contour simplification.
 };
 
-// Mask used with contours to extract region id.
+/// Applied to the region id field of contour vertices in order to extract the region id.
+/// The region id field of a vertex may have several flags applied to it.  So the
+/// fields value can't be used directly.
+/// @see rcContour::verts, rcContour::rverts
 static const int RC_CONTOUR_REG_MASK = 0xffff;
 
-// Null index which is used with meshes to mark unset or invalid indices.
+/// An value which indicates an invalid index within a mesh.
+/// @note This does not necessarily indicate an error.
+/// @see rcPolyMesh::polys
 static const unsigned short RC_MESH_NULL_IDX = 0xffff;
 
-// Area ID that is considered empty.
+/// Represents the null area.
+/// When a data element is given this value it is considered to no longer be
+/// assigned to a usable area.  (E.g. It is unwalkable.)
 static const unsigned char RC_NULL_AREA = 0;
 
-// Area ID that is considered generally walkable.
+/// The default area id used to indicate a walkable polygon.
+/// This is also the maximum allowed area id, and the only non-null area id
+/// recognized by some steps in the build process.
 static const unsigned char RC_WALKABLE_AREA = 63;
 
-// Value returned by rcGetCon() if the direction is not connected.
+/// The value returned by #rcGetCon if the specified direction is not connected
+/// to another span. (Has no neighbor.)
 static const int RC_NOT_CONNECTED = 0x3f;
 
-// Compact span neighbour helpers.
-inline void rcSetCon(rcCompactSpan& s, int dir, int i)
-{
-	const unsigned int shift = (unsigned int)dir*6;
-	unsigned int con = s.con;
-	s.con = (con & ~(0x3f << shift)) | (((unsigned int)i & 0x3f) << shift);
-}
+/// @name General helper functions
+/// @{
 
-inline int rcGetCon(const rcCompactSpan& s, int dir)
-{
-	const unsigned int shift = (unsigned int)dir*6;
-	return (s.con >> shift) & 0x3f;
-}
+/// Swaps the values of the two parameters.
+///  @param[in,out]	a	Value A
+///  @param[in,out]	b	Value B
+template<class T> inline void rcSwap(T& a, T& b) { T t = a; a = b; b = t; }
 
-inline int rcGetDirOffsetX(int dir)
-{
-	const int offset[4] = { -1, 0, 1, 0, };
-	return offset[dir&0x03];
-}
+/// Returns the minimum of two values.
+///  @param[in]		a	Value A
+///  @param[in]		b	Value B
+///  @return The minimum of the two values.
+template<class T> inline T rcMin(T a, T b) { return a < b ? a : b; }
 
-inline int rcGetDirOffsetY(int dir)
-{
-	const int offset[4] = { 0, 1, 0, -1 };
-	return offset[dir&0x03];
-}
+/// Returns the maximum of two values.
+///  @param[in]		a	Value A
+///  @param[in]		b	Value B
+///  @return The maximum of the two values.
+template<class T> inline T rcMax(T a, T b) { return a > b ? a : b; }
 
-// Common helper functions
-template<class T> inline void rcSwap(T& a, T& b) { T t = a; a = b; b = t; }
-template<class T> inline T rcMin(T a, T b) { return a < b ? a : b; }
-template<class T> inline T rcMax(T a, T b) { return a > b ? a : b; }
+/// Returns the absolute value.
+///  @param[in]		a	The value.
+///  @return The absolute value of the specified value.
 template<class T> inline T rcAbs(T a) { return a < 0 ? -a : a; }
+
+/// Returns the square of the value.
+///  @param[in]		a	The value.
+///  @return The square of the value.
 template<class T> inline T rcSqr(T a) { return a*a; }
+
+/// Clamps the value to the specified range.
+///  @param[in]		v	The value to clamp.
+///  @param[in]		mn	The minimum permitted return value.
+///  @param[in]		mx	The maximum permitted return value.
+///  @return The value, clamped to the specified range.
 template<class T> inline T rcClamp(T v, T mn, T mx) { return v < mn ? mn : (v > mx ? mx : v); }
+
+/// Returns the square root of the value.
+///  @param[in]		x	The value.
+///  @return The square root of the vlaue.
 float rcSqrt(float x);
 
-// Common vector helper functions.
+/// @}
+/// @name Vector helper functions.
+/// @{
+
+/// Derives the cross product of two vectors. (@p v1 x @p v2)
+///  @param[out]	dest	The cross product. [(x, y, z)]
+///  @param[in]		v1		A Vector [(x, y, z)]
+///  @param[in]		v2		A vector [(x, y, z)]
 inline void rcVcross(float* dest, const float* v1, const float* v2)
 {
 	dest[0] = v1[1]*v2[2] - v1[2]*v2[1];
@@ -378,11 +667,20 @@
 	dest[2] = v1[0]*v2[1] - v1[1]*v2[0];
 }
 
+/// Derives the dot product of two vectors. (@p v1 . @p v2)
+///  @param[in]		v1	A Vector [(x, y, z)]
+///  @param[in]		v2	A vector [(x, y, z)]
+/// @return The dot product.
 inline float rcVdot(const float* v1, const float* v2)
 {
 	return v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];
 }
 
+/// Performs a scaled vector addition. (@p v1 + (@p v2 * @p s))
+///  @param[out]	dest	The result vector. [(x, y, z)]
+///  @param[in]		v1		The base vector. [(x, y, z)]
+///  @param[in]		v2		The vector to scale and add to @p v1. [(x, y, z)]
+///  @param[in]		s		The amount to scale @p v2 by before adding to @p v1.
 inline void rcVmad(float* dest, const float* v1, const float* v2, const float s)
 {
 	dest[0] = v1[0]+v2[0]*s;
@@ -390,6 +688,10 @@
 	dest[2] = v1[2]+v2[2]*s;
 }
 
+/// Performs a vector addition. (@p v1 + @p v2)
+///  @param[out]	dest	The result vector. [(x, y, z)]
+///  @param[in]		v1		The base vector. [(x, y, z)]
+///  @param[in]		v2		The vector to add to @p v1. [(x, y, z)]
 inline void rcVadd(float* dest, const float* v1, const float* v2)
 {
 	dest[0] = v1[0]+v2[0];
@@ -397,6 +699,10 @@
 	dest[2] = v1[2]+v2[2];
 }
 
+/// Performs a vector subtraction. (@p v1 - @p v2)
+///  @param[out]	dest	The result vector. [(x, y, z)]
+///  @param[in]		v1		The base vector. [(x, y, z)]
+///  @param[in]		v2		The vector to subtract from @p v1. [(x, y, z)]
 inline void rcVsub(float* dest, const float* v1, const float* v2)
 {
 	dest[0] = v1[0]-v2[0];
@@ -404,6 +710,9 @@
 	dest[2] = v1[2]-v2[2];
 }
 
+/// Selects the minimum value of each element from the specified vectors.
+///  @param[in,out]	mn	A vector.  (Will be updated with the result.) [(x, y, z)]
+///  @param[in]		v	A vector. [(x, y, z)]
 inline void rcVmin(float* mn, const float* v)
 {
 	mn[0] = rcMin(mn[0], v[0]);
@@ -411,6 +720,9 @@
 	mn[2] = rcMin(mn[2], v[2]);
 }
 
+/// Selects the maximum value of each element from the specified vectors.
+///  @param[in,out]	mx	A vector.  (Will be updated with the result.) [(x, y, z)]
+///  @param[in]		v	A vector. [(x, y, z)]
 inline void rcVmax(float* mx, const float* v)
 {
 	mx[0] = rcMax(mx[0], v[0]);
@@ -418,6 +730,9 @@
 	mx[2] = rcMax(mx[2], v[2]);
 }
 
+/// Performs a vector copy.
+///  @param[out]	dest	The result. [(x, y, z)]
+///  @param[in]		v		The vector to copy. [(x, y, z)]
 inline void rcVcopy(float* dest, const float* v)
 {
 	dest[0] = v[0];
@@ -425,6 +740,10 @@
 	dest[2] = v[2];
 }
 
+/// Returns the distance between two points.
+///  @param[in]		v1	A point. [(x, y, z)]
+///  @param[in]		v2	A point. [(x, y, z)]
+/// @return The distance between the two points.
 inline float rcVdist(const float* v1, const float* v2)
 {
 	float dx = v2[0] - v1[0];
@@ -433,6 +752,10 @@
 	return rcSqrt(dx*dx + dy*dy + dz*dz);
 }
 
+/// Returns the square of the distance between two points.
+///  @param[in]		v1	A point. [(x, y, z)]
+///  @param[in]		v2	A point. [(x, y, z)]
+/// @return The square of the distance between the two points.
 inline float rcVdistSqr(const float* v1, const float* v2)
 {
 	float dx = v2[0] - v1[0];
@@ -441,6 +764,8 @@
 	return dx*dx + dy*dy + dz*dz;
 }
 
+/// Normalizes the vector.
+///  @param[in,out]	v	The vector to normalize. [(x, y, z)]
 inline void rcVnormalize(float* v)
 {
 	float d = 1.0f / rcSqrt(rcSqr(v[0]) + rcSqr(v[1]) + rcSqr(v[2]));
@@ -449,271 +774,403 @@
 	v[2] *= d;
 }
 
-inline bool rcVequal(const float* p0, const float* p1)
-{
-	static const float thr = rcSqr(1.0f/16384.0f);
-	const float d = rcVdistSqr(p0, p1);
-	return d < thr;
-}
+/// @}
+/// @name Heightfield Functions
+/// @see rcHeightfield
+/// @{
 
-// Calculated bounding box of array of vertices.
-// Params:
-//	verts - (in) array of vertices
-//	nv - (in) vertex count
-//	bmin, bmax - (out) bounding box
+/// Calculates the bounding box of an array of vertices.
+///  @ingroup recast
+///  @param[in]		verts	An array of vertices. [(x, y, z) * @p nv]
+///  @param[in]		nv		The number of vertices in the @p verts array.
+///  @param[out]	bmin	The minimum bounds of the AABB. [(x, y, z)] [Units: wu]
+///  @param[out]	bmax	The maximum bounds of the AABB. [(x, y, z)] [Units: wu]
 void rcCalcBounds(const float* verts, int nv, float* bmin, float* bmax);
 
-// Calculates grid size based on bounding box and grid cell size.
-// Params:
-//	bmin, bmax - (in) bounding box
-//	cs - (in) grid cell size
-//	w - (out) grid width
-//	h - (out) grid height
+/// Calculates the grid size based on the bounding box and grid cell size.
+///  @ingroup recast
+///  @param[in]		bmin	The minimum bounds of the AABB. [(x, y, z)] [Units: wu]
+///  @param[in]		bmax	The maximum bounds of the AABB. [(x, y, z)] [Units: wu]
+///  @param[in]		cs		The xz-plane cell size. [Limit: > 0] [Units: wu]
+///  @param[out]	w		The width along the x-axis. [Limit: >= 0] [Units: vx]
+///  @param[out]	h		The height along the z-axis. [Limit: >= 0] [Units: vx]
 void rcCalcGridSize(const float* bmin, const float* bmax, float cs, int* w, int* h);
 
-// Creates and initializes new heightfield.
-// Params:
-//	hf - (in/out) heightfield to initialize.
-//	width - (in) width of the heightfield.
-//	height - (in) height of the heightfield.
-//	bmin, bmax - (in) bounding box of the heightfield
-//	cs - (in) grid cell size
-//	ch - (in) grid cell height
+/// Initializes a new heightfield.
+///  @ingroup recast
+///  @param[in,out]	ctx		The build context to use during the operation.
+///  @param[in,out]	hf		The allocated heightfield to initialize.
+///  @param[in]		width	The width of the field along the x-axis. [Limit: >= 0] [Units: vx]
+///  @param[in]		height	The height of the field along the z-axis. [Limit: >= 0] [Units: vx]
+///  @param[in]		bmin	The minimum bounds of the field's AABB. [(x, y, z)] [Units: wu]
+///  @param[in]		bmax	The maximum bounds of the field's AABB. [(x, y, z)] [Units: wu]
+///  @param[in]		cs		The xz-plane cell size to use for the field. [Limit: > 0] [Units: wu]
+///  @param[in]		ch		The y-axis cell size to use for field. [Limit: > 0] [Units: wu]
 bool rcCreateHeightfield(rcContext* ctx, rcHeightfield& hf, int width, int height,
 						 const float* bmin, const float* bmax,
 						 float cs, float ch);
 
-// Sets the RC_WALKABLE_AREA for every triangle whose slope is below
-// the maximum walkable slope angle.
-// Params:
-//	walkableSlopeAngle - (in) maximum slope angle in degrees.
-//	verts - (in) array of vertices
-//	nv - (in) vertex count
-//	tris - (in) array of triangle vertex indices
-//	nt - (in) triangle count
-//	areas - (out) array of triangle area types
+/// Sets the area id of all triangles with a slope below the specified value
+/// to #RC_WALKABLE_AREA.
+///  @ingroup recast
+///  @param[in,out]	ctx					The build context to use during the operation.
+///  @param[in]		walkableSlopeAngle	The maximum slope that is considered walkable.
+///  									[Limits: 0 <= value < 90] [Units: Degrees]
+///  @param[in]		verts				The vertices. [(x, y, z) * @p nv]
+///  @param[in]		nv					The number of vertices.
+///  @param[in]		tris				The triangle vertex indices. [(vertA, vertB, vertC) * @p nt]
+///  @param[in]		nt					The number of triangles.
+///  @param[out]	areas				The triangle area ids. [Length: >= @p nt]
 void rcMarkWalkableTriangles(rcContext* ctx, const float walkableSlopeAngle, const float* verts, int nv,
-							 const int* tris, int nt, unsigned char* areas); 
+							 const int* tris, int nt, unsigned char* areas);
 
-// Sets the RC_NULL_AREA for every triangle whose slope is steeper than
-// the maximum walkable slope angle.
-// Params:
-//	walkableSlopeAngle - (in) maximum slope angle in degrees.
-//	verts - (in) array of vertices
-//	nv - (in) vertex count
-//	tris - (in) array of triangle vertex indices
-//	nt - (in) triangle count
-//	areas - (out) array of triangle are types
+/// Sets the area id of all triangles with a slope greater than or equal to the specified value to #RC_NULL_AREA.
+///  @ingroup recast
+///  @param[in,out]	ctx					The build context to use during the operation.
+///  @param[in]		walkableSlopeAngle	The maximum slope that is considered walkable.
+///  									[Limits: 0 <= value < 90] [Units: Degrees]
+///  @param[in]		verts				The vertices. [(x, y, z) * @p nv]
+///  @param[in]		nv					The number of vertices.
+///  @param[in]		tris				The triangle vertex indices. [(vertA, vertB, vertC) * @p nt]
+///  @param[in]		nt					The number of triangles.
+///  @param[out]	areas				The triangle area ids. [Length: >= @p nt]
 void rcClearUnwalkableTriangles(rcContext* ctx, const float walkableSlopeAngle, const float* verts, int nv,
-								const int* tris, int nt, unsigned char* areas); 
+								const int* tris, int nt, unsigned char* areas);
 
-// Adds span to heightfield.
-// The span addition can set to favor flags. If the span is merged to
-// another span and the new smax is within 'flagMergeThr' units away
-// from the existing span the span flags are merged and stored.
-// Params:
-//	solid - (in) heightfield where the spans is added to
-//  x,y - (in) location on the heightfield where the span is added
-//  smin,smax - (in) spans min/max height
-//  flags - (in) span flags (zero or WALKABLE)
-//  flagMergeThr - (in) merge threshold.
-void rcAddSpan(rcContext* ctx, rcHeightfield& solid, const int x, const int y,
+/// Adds a span to the specified heightfield.
+///  @ingroup recast
+///  @param[in,out]	ctx				The build context to use during the operation.
+///  @param[in,out]	hf				An initialized heightfield.
+///  @param[in]		x				The width index where the span is to be added.
+///  								[Limits: 0 <= value < rcHeightfield::width]
+///  @param[in]		y				The height index where the span is to be added.
+///  								[Limits: 0 <= value < rcHeightfield::height]
+///  @param[in]		smin			The minimum height of the span. [Limit: < @p smax] [Units: vx]
+///  @param[in]		smax			The maximum height of the span. [Limit: <= #RC_SPAN_MAX_HEIGHT] [Units: vx]
+///  @param[in]		area			The area id of the span. [Limit: <= #RC_WALKABLE_AREA)
+///  @param[in]		flagMergeThr	The merge theshold. [Limit: >= 0] [Units: vx]
+void rcAddSpan(rcContext* ctx, rcHeightfield& hf, const int x, const int y,
 			   const unsigned short smin, const unsigned short smax,
-			   const unsigned short area, const int flagMergeThr);
+			   const unsigned char area, const int flagMergeThr);
 
-// Rasterizes a triangle into heightfield spans.
-// Params:
-//	v0,v1,v2 - (in) the vertices of the triangle.
-//	area - (in) area type of the triangle.
-//	solid - (in) heightfield where the triangle is rasterized
-//  flagMergeThr - (in) distance in voxel where walkable flag is favored over non-walkable.
+/// Rasterizes a triangle into the specified heightfield.
+///  @ingroup recast
+///  @param[in,out]	ctx				The build context to use during the operation.
+///  @param[in]		v0				Triangle vertex 0 [(x, y, z)]
+///  @param[in]		v1				Triangle vertex 1 [(x, y, z)]
+///  @param[in]		v2				Triangle vertex 2 [(x, y, z)]
+///  @param[in]		area			The area id of the triangle. [Limit: <= #RC_WALKABLE_AREA]
+///  @param[in,out]	solid			An initialized heightfield.
+///  @param[in]		flagMergeThr	The distance where the walkable flag is favored over the non-walkable flag.
+///  								[Limit: >= 0] [Units: vx]
 void rcRasterizeTriangle(rcContext* ctx, const float* v0, const float* v1, const float* v2,
 						 const unsigned char area, rcHeightfield& solid,
 						 const int flagMergeThr = 1);
 
-// Rasterizes indexed triangle mesh into heightfield spans.
-// Params:
-//	verts - (in) array of vertices
-//	nv - (in) vertex count
-//	tris - (in) array of triangle vertex indices
-//	area - (in) array of triangle area types.
-//	nt - (in) triangle count
-//	solid - (in) heightfield where the triangles are rasterized
-//  flagMergeThr - (in) distance in voxel where walkable flag is favored over non-walkable.
+/// Rasterizes an indexed triangle mesh into the specified heightfield.
+///  @ingroup recast
+///  @param[in,out]	ctx				The build context to use during the operation.
+///  @param[in]		verts			The vertices. [(x, y, z) * @p nv]
+///  @param[in]		nv				The number of vertices.
+///  @param[in]		tris			The triangle indices. [(vertA, vertB, vertC) * @p nt]
+///  @param[in]		areas			The area id's of the triangles. [Limit: <= #RC_WALKABLE_AREA] [Size: @p nt]
+///  @param[in]		nt				The number of triangles.
+///  @param[in,out]	solid			An initialized heightfield.
+///  @param[in]		flagMergeThr	The distance where the walkable flag is favored over the non-walkable flag.
+///  								[Limit: >= 0] [Units: vx]
 void rcRasterizeTriangles(rcContext* ctx, const float* verts, const int nv,
 						  const int* tris, const unsigned char* areas, const int nt,
 						  rcHeightfield& solid, const int flagMergeThr = 1);
 
-// Rasterizes indexed triangle mesh into heightfield spans.
-// Params:
-//	verts - (in) array of vertices
-//	nv - (in) vertex count
-//	tris - (in) array of triangle vertex indices
-//	area - (in) array of triangle area types.
-//	nt - (in) triangle count
-//	solid - (in) heightfield where the triangles are rasterized
-//  flagMergeThr - (in) distance in voxel where walkable flag is favored over non-walkable.
+/// Rasterizes an indexed triangle mesh into the specified heightfield.
+///  @ingroup recast
+///  @param[in,out]	ctx			The build context to use during the operation.
+///  @param[in]		verts		The vertices. [(x, y, z) * @p nv]
+///  @param[in]		nv			The number of vertices.
+///  @param[in]		tris		The triangle indices. [(vertA, vertB, vertC) * @p nt]
+///  @param[in]		areas		The area id's of the triangles. [Limit: <= #RC_WALKABLE_AREA] [Size: @p nt]
+///  @param[in]		nt			The number of triangles.
+///  @param[in,out]	solid		An initialized heightfield.
+///  @param[in]		flagMergeThr	The distance where the walkable flag is favored over the non-walkable flag.
+///  							[Limit: >= 0] [Units: vx]
 void rcRasterizeTriangles(rcContext* ctx, const float* verts, const int nv,
 						  const unsigned short* tris, const unsigned char* areas, const int nt,
 						  rcHeightfield& solid, const int flagMergeThr = 1);
 
-// Rasterizes the triangles into heightfield spans.
-// Params:
-//	verts - (in) array of vertices
-//	area - (in) array of triangle area types.
-//	nt - (in) triangle count
-//	solid - (in) heightfield where the triangles are rasterized
+/// Rasterizes triangles into the specified heightfield.
+///  @ingroup recast
+///  @param[in,out]	ctx				The build context to use during the operation.
+///  @param[in]		verts			The triangle vertices. [(ax, ay, az, bx, by, bz, cx, by, cx) * @p nt]
+///  @param[in]		areas			The area id's of the triangles. [Limit: <= #RC_WALKABLE_AREA] [Size: @p nt]
+///  @param[in]		nt				The number of triangles.
+///  @param[in,out]	solid			An initialized heightfield.
+///  @param[in]		flagMergeThr	The distance where the walkable flag is favored over the non-walkable flag.
+///  								[Limit: >= 0] [Units: vx]
 void rcRasterizeTriangles(rcContext* ctx, const float* verts, const unsigned char* areas, const int nt,
 						  rcHeightfield& solid, const int flagMergeThr = 1);
 
-// Marks non-walkable low obstacles as walkable if they are closer than walkableClimb
-// from a walkable surface. Applying this filter allows to step over low hanging
-// low obstacles.
-// Params:
-//	walkableHeight - (in) minimum height where the agent can still walk
-//	solid - (in/out) heightfield describing the solid space
-// TODO: Missuses ledge flag, must be called before rcFilterLedgeSpans!
+/// Marks non-walkable spans as walkable if their maximum is within @p walkableClimp of a walkable neihbor.
+///  @ingroup recast
+///  @param[in,out]	ctx				The build context to use during the operation.
+///  @param[in]		walkableClimb	Maximum ledge height that is considered to still be traversable.
+///  								[Limit: >=0] [Units: vx]
+///  @param[in,out]	solid			A fully built heightfield.  (All spans have been added.)
 void rcFilterLowHangingWalkableObstacles(rcContext* ctx, const int walkableClimb, rcHeightfield& solid);
 
-// Removes WALKABLE flag from all spans that are at ledges. This filtering
-// removes possible overestimation of the conservative voxelization so that
-// the resulting mesh will not have regions hanging in air over ledges.
-// Params:
-//	walkableHeight - (in) minimum height where the agent can still walk
-//	walkableClimb - (in) maximum height between grid cells the agent can climb
-//	solid - (in/out) heightfield describing the solid space
+/// Marks spans that are ledges as not-walkable.
+///  @ingroup recast
+///  @param[in,out]	ctx				The build context to use during the operation.
+///  @param[in]		walkableHeight	Minimum floor to 'ceiling' height that will still allow the floor area to
+///  								be considered walkable. [Limit: >= 3] [Units: vx]
+///  @param[in]		walkableClimb	Maximum ledge height that is considered to still be traversable.
+///  								[Limit: >=0] [Units: vx]
+///  @param[in,out]	solid			A fully built heightfield.  (All spans have been added.)
 void rcFilterLedgeSpans(rcContext* ctx, const int walkableHeight,
 						const int walkableClimb, rcHeightfield& solid);
 
-// Removes WALKABLE flag from all spans which have smaller than
-// 'walkableHeight' clearance above them.
-// Params:
-//	walkableHeight - (in) minimum height where the agent can still walk
-//	solid - (in/out) heightfield describing the solid space
+/// Marks walkable spans as not walkable if the clearence above the span is less than the specified height.
+///  @ingroup recast
+///  @param[in,out]	ctx				The build context to use during the operation.
+///  @param[in]		walkableHeight	Minimum floor to 'ceiling' height that will still allow the floor area to
+///  								be considered walkable. [Limit: >= 3] [Units: vx]
+///  @param[in,out]	solid			A fully built heightfield.  (All spans have been added.)
 void rcFilterWalkableLowHeightSpans(rcContext* ctx, int walkableHeight, rcHeightfield& solid);
 
-// Returns number of spans contained in a heightfield.
-// Params:
-//	hf - (in) heightfield to be compacted
-// Returns number of spans.
+/// Returns the number of spans contained in the specified heightfield.
+///  @ingroup recast
+///  @param[in,out]	ctx		The build context to use during the operation.
+///  @param[in]		hf		An initialized heightfield.
+///  @returns The number of spans in the heightfield.
 int rcGetHeightFieldSpanCount(rcContext* ctx, rcHeightfield& hf);
 
-// Builds compact representation of the heightfield.
-// Params:
-//	walkableHeight - (in) minimum height where the agent can still walk
-//	walkableClimb - (in) maximum height between grid cells the agent can climb
-//  flags - (in) require flags for a cell to be included in the compact heightfield.
-//	hf - (in) heightfield to be compacted
-//	chf - (out) compact heightfield representing the open space.
-// Returns false if operation ran out of memory.
+/// @}
+/// @name Compact Heightfield Functions
+/// @see rcCompactHeightfield
+/// @{
+
+/// Builds a compact heightfield representing open space, from a heightfield representing solid space.
+///  @ingroup recast
+///  @param[in,out]	ctx				The build context to use during the operation.
+///  @param[in]		walkableHeight	Minimum floor to 'ceiling' height that will still allow the floor area
+///  								to be considered walkable. [Limit: >= 3] [Units: vx]
+///  @param[in]		walkableClimb	Maximum ledge height that is considered to still be traversable.
+///  								[Limit: >=0] [Units: vx]
+///  @param[in]		hf				The heightfield to be compacted.
+///  @param[out]	chf				The resulting compact heightfield. (Must be pre-allocated.)
+///  @returns True if the operation completed successfully.
 bool rcBuildCompactHeightfield(rcContext* ctx, const int walkableHeight, const int walkableClimb,
 							   rcHeightfield& hf, rcCompactHeightfield& chf);
 
-// Erodes walkable area.
-// Params:
-//  radius - (in) radius of erosion (max 255).
-//	chf - (in/out) compact heightfield to erode.
-// Returns false if operation ran out of memory.
+/// Erodes the walkable area within the heightfield by the specified radius.
+///  @ingroup recast
+///  @param[in,out]	ctx		The build context to use during the operation.
+///  @param[in]		radius	The radius of erosion. [Limits: 0 < value < 255] [Units: vx]
+///  @param[in,out]	chf		The populated compact heightfield to erode.
+///  @returns True if the operation completed successfully.
 bool rcErodeWalkableArea(rcContext* ctx, int radius, rcCompactHeightfield& chf);
 
-// Applies median filter to walkable area types, removing noise.
-// Params:
-//	chf - (in/out) compact heightfield to erode.
-// Returns false if operation ran out of memory.
+/// Applies a median filter to walkable area types (based on area id), removing noise.
+///  @ingroup recast
+///  @param[in,out]	ctx		The build context to use during the operation.
+///  @param[in,out]	chf		A populated compact heightfield.
+///  @returns True if the operation completed successfully.
 bool rcMedianFilterWalkableArea(rcContext* ctx, rcCompactHeightfield& chf);
 
-// Marks the area of the convex polygon into the area type of the compact heightfield.
-// Params:
-//  bmin/bmax - (in) bounds of the axis aligned box.
-//  areaId - (in) area ID to mark.
-//	chf - (in/out) compact heightfield to mark.
+/// Applies an area id to all spans within the specified bounding box. (AABB)
+///  @ingroup recast
+///  @param[in,out]	ctx		The build context to use during the operation.
+///  @param[in]		bmin	The minimum of the bounding box. [(x, y, z)]
+///  @param[in]		bmax	The maximum of the bounding box. [(x, y, z)]
+///  @param[in]		areaId	The area id to apply. [Limit: <= #RC_WALKABLE_AREA]
+///  @param[in,out]	chf		A populated compact heightfield.
 void rcMarkBoxArea(rcContext* ctx, const float* bmin, const float* bmax, unsigned char areaId,
 				   rcCompactHeightfield& chf);
 
-// Marks the area of the convex polygon into the area type of the compact heightfield.
-// Params:
-//  verts - (in) vertices of the convex polygon.
-//  nverts - (in) number of vertices in the polygon.
-//  hmin/hmax - (in) min and max height of the polygon.
-//  areaId - (in) area ID to mark.
-//	chf - (in/out) compact heightfield to mark.
+/// Applies the area id to the all spans within the specified convex polygon.
+///  @ingroup recast
+///  @param[in,out]	ctx		The build context to use during the operation.
+///  @param[in]		verts	The vertices of the polygon [Fomr: (x, y, z) * @p nverts]
+///  @param[in]		nverts	The number of vertices in the polygon.
+///  @param[in]		hmin	The height of the base of the polygon.
+///  @param[in]		hmax	The height of the top of the polygon.
+///  @param[in]		areaId	The area id to apply. [Limit: <= #RC_WALKABLE_AREA]
+///  @param[in,out]	chf		A populated compact heightfield.
 void rcMarkConvexPolyArea(rcContext* ctx, const float* verts, const int nverts,
 						  const float hmin, const float hmax, unsigned char areaId,
 						  rcCompactHeightfield& chf);
 
-// Builds distance field and stores it into the combat heightfield.
-// Params:
-//	chf - (in/out) compact heightfield representing the open space.
-// Returns false if operation ran out of memory.
+/// Applies the area id to all spans within the specified cylinder.
+///  @ingroup recast
+///  @param[in,out]	ctx		The build context to use during the operation.
+///  @param[in]		pos		The center of the base of the cylinder. [Form: (x, y, z)]
+///  @param[in]		r		The radius of the cylinder.
+///  @param[in]		h		The height of the cylinder.
+///  @param[in]		areaId	The area id to apply. [Limit: <= #RC_WALKABLE_AREA]
+///  @param[in,out]	chf	A populated compact heightfield.
+void rcMarkCylinderArea(rcContext* ctx, const float* pos,
+						const float r, const float h, unsigned char areaId,
+						rcCompactHeightfield& chf);
+
+/// Builds the distance field for the specified compact heightfield.
+///  @ingroup recast
+///  @param[in,out]	ctx		The build context to use during the operation.
+///  @param[in,out]	chf		A populated compact heightfield.
+///  @returns True if the operation completed successfully.
 bool rcBuildDistanceField(rcContext* ctx, rcCompactHeightfield& chf);
 
-// Divides the walkable heighfied into simple regions using watershed partitioning.
-// Each region has only one contour and no overlaps.
-// The regions are stored in the compact heightfield 'reg' field.
-// The process sometimes creates small regions. If the area of a regions is
-// smaller than 'mergeRegionArea' then the region will be merged with a neighbour
-// region if possible. If multiple regions form an area which is smaller than
-// 'minRegionArea' all the regions belonging to that area will be removed.
-// Here area means the count of spans in an area.
-// Params:
-//	chf - (in/out) compact heightfield representing the open space.
-//	minRegionArea - (in) the smallest allowed region area.
-//	maxMergeRegionArea - (in) the largest allowed region area which can be merged.
-// Returns false if operation ran out of memory.
+/// Builds region data for the heightfield using watershed partitioning.
+///  @ingroup recast
+///  @param[in,out]	ctx				The build context to use during the operation.
+///  @param[in,out]	chf				A populated compact heightfield.
+///  @param[in]		borderSize		The size of the non-navigable border around the heightfield.
+///  								[Limit: >=0] [Units: vx]
+///  @param[in]		minRegionArea	The minimum number of cells allowed to form isolated island areas.
+///  								[Limit: >=0] [Units: vx].
+///  @param[in]		mergeRegionArea		Any regions with a span count smaller than this value will, if possible,
+///  								be merged with larger regions. [Limit: >=0] [Units: vx]
+///  @returns True if the operation completed successfully.
 bool rcBuildRegions(rcContext* ctx, rcCompactHeightfield& chf,
 					const int borderSize, const int minRegionArea, const int mergeRegionArea);
 
-// Divides the walkable heighfied into simple regions using simple monotone partitioning.
-// Each region has only one contour and no overlaps.
-// The regions are stored in the compact heightfield 'reg' field.
-// The process sometimes creates small regions. If the area of a regions is
-// smaller than 'mergeRegionArea' then the region will be merged with a neighbour
-// region if possible. If multiple regions form an area which is smaller than
-// 'minRegionArea' all the regions belonging to that area will be removed.
-// Here area means the count of spans in an area.
-// Params:
-//	chf - (in/out) compact heightfield representing the open space.
-//	minRegionArea - (in) the smallest allowed regions size.
-//	maxMergeRegionArea - (in) the largest allowed regions size which can be merged.
-// Returns false if operation ran out of memory.
+/// Builds region data for the heightfield using simple monotone partitioning.
+///  @ingroup recast
+///  @param[in,out]	ctx				The build context to use during the operation.
+///  @param[in,out]	chf				A populated compact heightfield.
+///  @param[in]		borderSize		The size of the non-navigable border around the heightfield.
+///  								[Limit: >=0] [Units: vx]
+///  @param[in]		minRegionArea	The minimum number of cells allowed to form isolated island areas.
+///  								[Limit: >=0] [Units: vx].
+///  @param[in]		mergeRegionArea	Any regions with a span count smaller than this value will, if possible,
+///  								be merged with larger regions. [Limit: >=0] [Units: vx]
+///  @returns True if the operation completed successfully.
 bool rcBuildRegionsMonotone(rcContext* ctx, rcCompactHeightfield& chf,
 							const int borderSize, const int minRegionArea, const int mergeRegionArea);
 
-// Builds simplified contours from the regions outlines.
-// Params:
-//	chf - (in) compact heightfield which has regions set.
-//	maxError - (in) maximum allowed distance between simplified contour and cells.
-//	maxEdgeLen - (in) maximum allowed contour edge length in cells.
-//	cset - (out) Resulting contour set.
-//	flags - (in) build flags, see rcBuildContoursFlags.
-// Returns false if operation ran out of memory.
+
+/// Sets the neighbor connection data for the specified direction.
+///  @param[in]		s		The span to update.
+///  @param[in]		dir		The direction to set. [Limits: 0 <= value < 4]
+///  @param[in]		i		The index of the neighbor span.
+inline void rcSetCon(rcCompactSpan& s, int dir, int i)
+{
+	const unsigned int shift = (unsigned int)dir*6;
+	unsigned int con = s.con;
+	s.con = (con & ~(0x3f << shift)) | (((unsigned int)i & 0x3f) << shift);
+}
+
+/// Gets neighbor connection data for the specified direction.
+///  @param[in]		s		The span to check.
+///  @param[in]		dir		The direction to check. [Limits: 0 <= value < 4]
+///  @return The neighbor connection data for the specified direction,
+///  	or #RC_NOT_CONNECTED if there is no connection.
+inline int rcGetCon(const rcCompactSpan& s, int dir)
+{
+	const unsigned int shift = (unsigned int)dir*6;
+	return (s.con >> shift) & 0x3f;
+}
+
+/// Gets the standard width (x-axis) offset for the specified direction.
+///  @param[in]		dir		The direction. [Limits: 0 <= value < 4]
+///  @return The width offset to apply to the current cell position to move
+///  	in the direction.
+inline int rcGetDirOffsetX(int dir)
+{
+	const int offset[4] = { -1, 0, 1, 0, };
+	return offset[dir&0x03];
+}
+
+/// Gets the standard height (z-axis) offset for the specified direction.
+///  @param[in]		dir		The direction. [Limits: 0 <= value < 4]
+///  @return The height offset to apply to the current cell position to move
+///  	in the direction.
+inline int rcGetDirOffsetY(int dir)
+{
+	const int offset[4] = { 0, 1, 0, -1 };
+	return offset[dir&0x03];
+}
+
+/// @}
+/// @name Layer, Contour, Polymesh, and Detail Mesh Functions
+/// @see rcHeightfieldLayer, rcContourSet, rcPolyMesh, rcPolyMeshDetail
+/// @{
+
+/// Builds a layer set from the specified compact heightfield.
+///  @ingroup recast
+///  @param[in,out]	ctx			The build context to use during the operation.
+///  @param[in]		chf			A fully built compact heightfield.
+///  @param[in]		borderSize	The size of the non-navigable border around the heightfield. [Limit: >=0]
+///  							[Units: vx]
+///  @param[in]		walkableHeight	Minimum floor to 'ceiling' height that will still allow the floor area
+///  							to be considered walkable. [Limit: >= 3] [Units: vx]
+///  @param[out]	lset		The resulting layer set. (Must be pre-allocated.)
+///  @returns True if the operation completed successfully.
+bool rcBuildHeightfieldLayers(rcContext* ctx, rcCompactHeightfield& chf,
+							  const int borderSize, const int walkableHeight,
+							  rcHeightfieldLayerSet& lset);
+
+/// Builds a contour set from the region outlines in the provided compact heightfield.
+///  @ingroup recast
+///  @param[in,out]	ctx			The build context to use during the operation.
+///  @param[in]		chf			A fully built compact heightfield.
+///  @param[in]		maxError	The maximum distance a simplfied contour's border edges should deviate
+///  							the original raw contour. [Limit: >=0] [Units: wu]
+///  @param[in]		maxEdgeLen	The maximum allowed length for contour edges along the border of the mesh.
+///  							[Limit: >=0] [Units: vx]
+///  @param[out]	cset		The resulting contour set. (Must be pre-allocated.)
+///  @param[in]		buildFlags	The build flags. (See: #rcBuildContoursFlags)
+///  @returns True if the operation completed successfully.
 bool rcBuildContours(rcContext* ctx, rcCompactHeightfield& chf,
 					 const float maxError, const int maxEdgeLen,
 					 rcContourSet& cset, const int flags = RC_CONTOUR_TESS_WALL_EDGES);
 
-// Builds connected convex polygon mesh from contour polygons.
-// Params:
-//	cset - (in) contour set.
-//	nvp - (in) maximum number of vertices per polygon.
-//	mesh - (out) poly mesh.
-// Returns false if operation ran out of memory.
-bool rcBuildPolyMesh(rcContext* ctx, rcContourSet& cset, int nvp, rcPolyMesh& mesh);
+/// Builds a polygon mesh from the provided contours.
+///  @ingroup recast
+///  @param[in,out]	ctx		The build context to use during the operation.
+///  @param[in]		cset	A fully built contour set.
+///  @param[in]		nvp		The maximum number of vertices allowed for polygons generated during the
+///  						contour to polygon conversion process. [Limit: >= 3]
+///  @param[out]	mesh	The resulting polygon mesh. (Must be re-allocated.)
+///  @returns True if the operation completed successfully.
+bool rcBuildPolyMesh(rcContext* ctx, rcContourSet& cset, const int nvp, rcPolyMesh& mesh);
 
+/// Merges multiple polygon meshes into a single mesh.
+///  @ingroup recast
+///  @param[in,out]	ctx		The build context to use during the operation.
+///  @param[in]		meshes	An array of polygon meshes to merge. [Size: @p nmeshes]
+///  @param[in]		nmeshes	The number of polygon meshes in the meshes array.
+///  @param[in]		mesh	The resulting polygon mesh. (Must be pre-allocated.)
+///  @returns True if the operation completed successfully.
 bool rcMergePolyMeshes(rcContext* ctx, rcPolyMesh** meshes, const int nmeshes, rcPolyMesh& mesh);
 
-// Builds detail triangle mesh for each polygon in the poly mesh.
-// Params:
-//	mesh - (in) poly mesh to detail.
-//	chf - (in) compact height field, used to query height for new vertices.
-//  sampleDist - (in) spacing between height samples used to generate more detail into mesh.
-//  sampleMaxError - (in) maximum allowed distance between simplified detail mesh and height sample.
-//	pmdtl - (out) detail mesh.
-// Returns false if operation ran out of memory.
+/// Builds a detail mesh from the provided polygon mesh.
+///  @ingroup recast
+///  @param[in,out]	ctx				The build context to use during the operation.
+///  @param[in]		mesh			A fully built polygon mesh.
+///  @param[in]		chf				The compact heightfield used to build the polygon mesh.
+///  @param[in]		sampleDist		Sets the distance to use when samping the heightfield. [Limit: >=0] [Units: wu]
+///  @param[in]		sampleMaxError	The maximum distance the detail mesh surface should deviate from
+///  								heightfield data. [Limit: >=0] [Units: wu]
+///  @param[out]	dmesh			The resulting detail mesh.  (Must be pre-allocated.)
+///  @returns True if the operation completed successfully.
 bool rcBuildPolyMeshDetail(rcContext* ctx, const rcPolyMesh& mesh, const rcCompactHeightfield& chf,
 						   const float sampleDist, const float sampleMaxError,
 						   rcPolyMeshDetail& dmesh);
 
+/// Merges multiple detail meshes into a single detail mesh.
+///  @ingroup recast
+///  @param[in,out]	ctx		The build context to use during the operation.
+///  @param[in]		meshes	An array of detail meshes to merge. [Size: @p nmeshes]
+///  @param[in]		nmeshes	The number of detail meshes in the meshes array.
+///  @param[out]	mesh	The resulting detail mesh. (Must be pre-allocated.)
+///  @returns True if the operation completed successfully.
 bool rcMergePolyMeshDetails(rcContext* ctx, rcPolyMeshDetail** meshes, const int nmeshes, rcPolyMeshDetail& mesh);
 
+/// @}
 
 #endif // RECAST_H
+
+///////////////////////////////////////////////////////////////////////////
+
+// Due to the large amount of detail documentation for this file,
+// the content normally located at the end of the header file has been separated
+// out to a file in /Docs/Extern.
Index: src/hearthstone-shared/Pathfinding/Recast/RecastArea.cpp
===================================================================
--- src/hearthstone-shared/Pathfinding/Recast/RecastArea.cpp	(revision 1490)
+++ src/hearthstone-shared/Pathfinding/Recast/RecastArea.cpp	(working copy)
@@ -18,25 +18,33 @@
 
 #include "../../Common.h"
 
+/// @par
+///
+/// Basically, any spans that are closer to a boundary or obstruction than the specified radius
+/// are marked as unwalkable.
+///
+/// This method is usually called immediately after the heightfield has been built.
+///
+/// @see rcCompactHeightfield, rcBuildCompactHeightfield, rcConfig::walkableRadius
 bool rcErodeWalkableArea(rcContext* ctx, int radius, rcCompactHeightfield& chf)
 {
 	ASSERT(ctx);
-	
+
 	const int w = chf.width;
 	const int h = chf.height;
-	
+
 	ctx->startTimer(RC_TIMER_ERODE_AREA);
-	
+
 	unsigned char* dist = (unsigned char*)malloc(sizeof(unsigned char)*chf.spanCount);
 	if (!dist)
 	{
 		ctx->log(RC_LOG_ERROR, "erodeWalkableArea: Out of memory 'dist' (%d).", chf.spanCount);
 		return false;
 	}
-	
+
 	// Init distance.
 	memset(dist, 0xff, sizeof(unsigned char)*chf.spanCount);
-	
+
 	// Mark boundary cells.
 	for (int y = 0; y < h; ++y)
 	{
@@ -45,14 +53,26 @@
 			const rcCompactCell& c = chf.cells[x+y*w];
 			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)
 			{
-				if (chf.areas[i] != RC_NULL_AREA)
+				if (chf.areas[i] == RC_NULL_AREA)
 				{
+					dist[i] = 0;
+				}
+				else
+				{
 					const rcCompactSpan& s = chf.spans[i];
 					int nc = 0;
 					for (int dir = 0; dir < 4; ++dir)
 					{
 						if (rcGetCon(s, dir) != RC_NOT_CONNECTED)
-							nc++;
+						{
+							const int nx = x + rcGetDirOffsetX(dir);
+							const int ny = y + rcGetDirOffsetY(dir);
+							const int ni = (int)chf.cells[nx+ny*w].index + rcGetCon(s, dir);
+							if (chf.areas[ni] != RC_NULL_AREA)
+							{
+								nc++;
+							}
+						}
 					}
 					// At least one missing neighbour.
 					if (nc != 4)
@@ -61,9 +81,9 @@
 			}
 		}
 	}
-	
+
 	unsigned char nd;
-	
+
 	// Pass 1
 	for (int y = 0; y < h; ++y)
 	{
@@ -73,7 +93,7 @@
 			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)
 			{
 				const rcCompactSpan& s = chf.spans[i];
-				
+
 				if (rcGetCon(s, 0) != RC_NOT_CONNECTED)
 				{
 					// (-1,0)
@@ -84,7 +104,7 @@
 					nd = (unsigned char)rcMin((int)dist[ai]+2, 255);
 					if (nd < dist[i])
 						dist[i] = nd;
-					
+
 					// (-1,-1)
 					if (rcGetCon(as, 3) != RC_NOT_CONNECTED)
 					{
@@ -106,7 +126,7 @@
 					nd = (unsigned char)rcMin((int)dist[ai]+2, 255);
 					if (nd < dist[i])
 						dist[i] = nd;
-					
+
 					// (1,-1)
 					if (rcGetCon(as, 2) != RC_NOT_CONNECTED)
 					{
@@ -121,7 +141,7 @@
 			}
 		}
 	}
-	
+
 	// Pass 2
 	for (int y = h-1; y >= 0; --y)
 	{
@@ -131,7 +151,7 @@
 			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)
 			{
 				const rcCompactSpan& s = chf.spans[i];
-				
+
 				if (rcGetCon(s, 2) != RC_NOT_CONNECTED)
 				{
 					// (1,0)
@@ -142,7 +162,7 @@
 					nd = (unsigned char)rcMin((int)dist[ai]+2, 255);
 					if (nd < dist[i])
 						dist[i] = nd;
-					
+
 					// (1,1)
 					if (rcGetCon(as, 1) != RC_NOT_CONNECTED)
 					{
@@ -164,7 +184,7 @@
 					nd = (unsigned char)rcMin((int)dist[ai]+2, 255);
 					if (nd < dist[i])
 						dist[i] = nd;
-					
+
 					// (-1,1)
 					if (rcGetCon(as, 0) != RC_NOT_CONNECTED)
 					{
@@ -179,16 +199,16 @@
 			}
 		}
 	}
-	
+
 	const unsigned char thr = (unsigned char)(radius*2);
 	for (int i = 0; i < chf.spanCount; ++i)
 		if (dist[i] < thr)
 			chf.areas[i] = RC_NULL_AREA;
-	
+
 	free(dist);
-	
+
 	ctx->stopTimer(RC_TIMER_ERODE_AREA);
-	
+
 	return true;
 }
 
@@ -204,26 +224,31 @@
 	}
 }
 
-
+/// @par
+///
+/// This filter is usually applied after applying area id's using functions
+/// such as #rcMarkBoxArea, #rcMarkConvexPolyArea, and #rcMarkCylinderArea.
+///
+/// @see rcCompactHeightfield
 bool rcMedianFilterWalkableArea(rcContext* ctx, rcCompactHeightfield& chf)
 {
 	ASSERT(ctx);
-	
+
 	const int w = chf.width;
 	const int h = chf.height;
-	
+
 	ctx->startTimer(RC_TIMER_MEDIAN_AREA);
-	
+
 	unsigned char* areas = (unsigned char*)malloc(sizeof(unsigned char)*chf.spanCount);
 	if (!areas)
 	{
 		ctx->log(RC_LOG_ERROR, "medianFilterWalkableArea: Out of memory 'areas' (%d).", chf.spanCount);
 		return false;
 	}
-	
+
 	// Init distance.
 	memset(areas, 0xff, sizeof(unsigned char)*chf.spanCount);
-	
+
 	for (int y = 0; y < h; ++y)
 	{
 		for (int x = 0; x < w; ++x)
@@ -237,11 +262,11 @@
 					areas[i] = chf.areas[i];
 					continue;
 				}
-				
+
 				unsigned char nei[9];
 				for (int j = 0; j < 9; ++j)
 					nei[j] = chf.areas[i];
-				
+
 				for (int dir = 0; dir < 4; ++dir)
 				{
 					if (rcGetCon(s, dir) != RC_NOT_CONNECTED)
@@ -251,7 +276,7 @@
 						const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, dir);
 						if (chf.areas[ai] != RC_NULL_AREA)
 							nei[dir*2+0] = chf.areas[ai];
-						
+
 						const rcCompactSpan& as = chf.spans[ai];
 						const int dir2 = (dir+1) & 0x3;
 						if (rcGetCon(as, dir2) != RC_NOT_CONNECTED)
@@ -269,21 +294,26 @@
 			}
 		}
 	}
-	
+
 	memcpy(chf.areas, areas, sizeof(unsigned char)*chf.spanCount);
-	
+
 	free(areas);
 
 	ctx->stopTimer(RC_TIMER_MEDIAN_AREA);
-	
+
 	return true;
 }
 
+/// @par
+///
+/// The value of spacial parameters are in world units.
+///
+/// @see rcCompactHeightfield, rcMedianFilterWalkableArea
 void rcMarkBoxArea(rcContext* ctx, const float* bmin, const float* bmax, unsigned char areaId,
 				   rcCompactHeightfield& chf)
 {
 	ASSERT(ctx);
-	
+
 	ctx->startTimer(RC_TIMER_MARK_BOX_AREA);
 
 	int minx = (int)((bmin[0]-chf.bmin[0])/chf.cs);
@@ -292,7 +322,7 @@
 	int maxx = (int)((bmax[0]-chf.bmin[0])/chf.cs);
 	int maxy = (int)((bmax[1]-chf.bmin[1])/chf.ch);
 	int maxz = (int)((bmax[2]-chf.bmin[2])/chf.cs);
-	
+
 	if (maxx < 0) return;
 	if (minx >= chf.width) return;
 	if (maxz < 0) return;
@@ -301,8 +331,8 @@
 	if (minx < 0) minx = 0;
 	if (maxx >= chf.width) maxx = chf.width-1;
 	if (minz < 0) minz = 0;
-	if (maxz >= chf.height) maxz = chf.height-1;	
-	
+	if (maxz >= chf.height) maxz = chf.height-1;
+
 	for (int z = minz; z <= maxz; ++z)
 	{
 		for (int x = minx; x <= maxx; ++x)
@@ -313,7 +343,8 @@
 				rcCompactSpan& s = chf.spans[i];
 				if ((int)s.y >= miny && (int)s.y <= maxy)
 				{
-					chf.areas[i] = areaId;
+					if (chf.areas[i] != RC_NULL_AREA)
+						chf.areas[i] = areaId;
 				}
 			}
 		}
@@ -338,12 +369,20 @@
 	return c;
 }
 
+/// @par
+///
+/// The value of spacial parameters are in world units.
+///
+/// The y-values of the polygon vertices are ignored. So the polygon is effectively
+/// projected onto the xz-plane at @p hmin, then extruded to @p hmax.
+///
+/// @see rcCompactHeightfield, rcMedianFilterWalkableArea
 void rcMarkConvexPolyArea(rcContext* ctx, const float* verts, const int nverts,
 						  const float hmin, const float hmax, unsigned char areaId,
 						  rcCompactHeightfield& chf)
 {
 	ASSERT(ctx);
-	
+
 	ctx->startTimer(RC_TIMER_MARK_CONVEXPOLY_AREA);
 
 	float bmin[3], bmax[3];
@@ -363,18 +402,18 @@
 	int maxx = (int)((bmax[0]-chf.bmin[0])/chf.cs);
 	int maxy = (int)((bmax[1]-chf.bmin[1])/chf.ch);
 	int maxz = (int)((bmax[2]-chf.bmin[2])/chf.cs);
-	
+
 	if (maxx < 0) return;
 	if (minx >= chf.width) return;
 	if (maxz < 0) return;
 	if (minz >= chf.height) return;
-	
+
 	if (minx < 0) minx = 0;
 	if (maxx >= chf.width) maxx = chf.width-1;
 	if (minz < 0) minz = 0;
-	if (maxz >= chf.height) maxz = chf.height-1;	
-	
-	
+	if (maxz >= chf.height) maxz = chf.height-1;
+
+
 	// TODO: Optimize.
 	for (int z = minz; z <= maxz; ++z)
 	{
@@ -384,12 +423,14 @@
 			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)
 			{
 				rcCompactSpan& s = chf.spans[i];
+				if (chf.areas[i] == RC_NULL_AREA)
+					continue;
 				if ((int)s.y >= miny && (int)s.y <= maxy)
 				{
 					float p[3];
-					p[0] = chf.bmin[0] + (x+0.5f)*chf.cs; 
+					p[0] = chf.bmin[0] + (x+0.5f)*chf.cs;
 					p[1] = 0;
-					p[2] = chf.bmin[2] + (z+0.5f)*chf.cs; 
+					p[2] = chf.bmin[2] + (z+0.5f)*chf.cs;
 
 					if (pointInPoly(nverts, verts, p))
 					{
@@ -402,3 +443,74 @@
 
 	ctx->stopTimer(RC_TIMER_MARK_CONVEXPOLY_AREA);
 }
+
+/// @par
+///
+/// The value of spacial parameters are in world units.
+///
+/// @see rcCompactHeightfield, rcMedianFilterWalkableArea
+void rcMarkCylinderArea(rcContext* ctx, const float* pos,
+						const float r, const float h, unsigned char areaId,
+						rcCompactHeightfield& chf)
+{
+	ASSERT(ctx);
+
+	ctx->startTimer(RC_TIMER_MARK_CYLINDER_AREA);
+
+	float bmin[3], bmax[3];
+	bmin[0] = pos[0] - r;
+	bmin[1] = pos[1];
+	bmin[2] = pos[2] - r;
+	bmax[0] = pos[0] + r;
+	bmax[1] = pos[1] + h;
+	bmax[2] = pos[2] + r;
+	const float r2 = r*r;
+
+	int minx = (int)((bmin[0]-chf.bmin[0])/chf.cs);
+	int miny = (int)((bmin[1]-chf.bmin[1])/chf.ch);
+	int minz = (int)((bmin[2]-chf.bmin[2])/chf.cs);
+	int maxx = (int)((bmax[0]-chf.bmin[0])/chf.cs);
+	int maxy = (int)((bmax[1]-chf.bmin[1])/chf.ch);
+	int maxz = (int)((bmax[2]-chf.bmin[2])/chf.cs);
+
+	if (maxx < 0) return;
+	if (minx >= chf.width) return;
+	if (maxz < 0) return;
+	if (minz >= chf.height) return;
+
+	if (minx < 0) minx = 0;
+	if (maxx >= chf.width) maxx = chf.width-1;
+	if (minz < 0) minz = 0;
+	if (maxz >= chf.height) maxz = chf.height-1;
+
+
+	for (int z = minz; z <= maxz; ++z)
+	{
+		for (int x = minx; x <= maxx; ++x)
+		{
+			const rcCompactCell& c = chf.cells[x+z*chf.width];
+			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)
+			{
+				rcCompactSpan& s = chf.spans[i];
+
+				if (chf.areas[i] == RC_NULL_AREA)
+					continue;
+
+				if ((int)s.y >= miny && (int)s.y <= maxy)
+				{
+					const float sx = chf.bmin[0] + (x+0.5f)*chf.cs;
+					const float sz = chf.bmin[2] + (z+0.5f)*chf.cs;
+					const float dx = sx - pos[0];
+					const float dz = sz - pos[2];
+
+					if (dx*dx + dz*dz < r2)
+					{
+						chf.areas[i] = areaId;
+					}
+				}
+			}
+		}
+	}
+
+	ctx->stopTimer(RC_TIMER_MARK_CYLINDER_AREA);
+}
Index: src/hearthstone-shared/Pathfinding/Recast/RecastContour.cpp
===================================================================
--- src/hearthstone-shared/Pathfinding/Recast/RecastContour.cpp	(revision 1490)
+++ src/hearthstone-shared/Pathfinding/Recast/RecastContour.cpp	(working copy)
@@ -25,13 +25,13 @@
 	const rcCompactSpan& s = chf.spans[i];
 	int ch = (int)s.y;
 	int dirp = (dir+1) & 0x3;
-	
+
 	unsigned int regs[4] = {0,0,0,0};
-	
+
 	// Combine region and area codes in order to prevent
-	// border vertices which are in between two areas to be removed. 
+	// border vertices which are in between two areas to be removed.
 	regs[0] = chf.spans[i].reg | (chf.areas[i] << 16);
-	
+
 	if (rcGetCon(s, dir) != RC_NOT_CONNECTED)
 	{
 		const int ax = x + rcGetDirOffsetX(dir);
@@ -76,7 +76,7 @@
 		const int b = (j+1) & 0x3;
 		const int c = (j+2) & 0x3;
 		const int d = (j+3) & 0x3;
-		
+
 		// The vertex is a border vertex there are two same exterior cells in a row,
 		// followed by two interior cells and none of the regions are out of bounds.
 		const bool twoSameExts = (regs[a] & regs[b] & RC_BORDER_REG) != 0 && regs[a] == regs[b];
@@ -89,7 +89,7 @@
 			break;
 		}
 	}
-	
+
 	return ch;
 }
 
@@ -101,12 +101,12 @@
 	unsigned char dir = 0;
 	while ((flags[i] & (1 << dir)) == 0)
 		dir++;
-	
+
 	unsigned char startDir = dir;
 	int starti = i;
-	
+
 	const unsigned char area = chf.areas[i];
-	
+
 	int iter = 0;
 	while (++iter < 40000)
 	{
@@ -143,7 +143,7 @@
 			points.push(py);
 			points.push(pz);
 			points.push(r);
-			
+
 			flags[i] &= ~(1 << dir); // Remove visited edges
 			dir = (dir+1) & 0x3;  // Rotate CW
 		}
@@ -168,7 +168,7 @@
 			i = ni;
 			dir = (dir+3) & 0x3;	// Rotate CCW
 		}
-		
+
 		if (starti == i && startDir == dir)
 		{
 			break;
@@ -194,11 +194,11 @@
 		t = 0;
 	else if (t > 1)
 		t = 1;
-	
+
 	dx = px + t*pqx - x;
 	dy = py + t*pqy - y;
 	dz = pz + t*pqz - z;
-	
+
 	return dx*dx + dy*dy + dz*dz;*/
 
 	float pqx = (float)(qx - px);
@@ -213,10 +213,10 @@
 		t = 0;
 	else if (t > 1)
 		t = 1;
-	
+
 	dx = px + t*pqx - x;
 	dz = pz + t*pqz - z;
-	
+
 	return dx*dx + dz*dz;
 }
 
@@ -233,7 +233,7 @@
 			break;
 		}
 	}
-	
+
 	if (hasConnections)
 	{
 		// The contour has some portals to other regions.
@@ -250,13 +250,13 @@
 				simplified.push(points[i*4+2]);
 				simplified.push(i);
 			}
-		}       
+		}
 	}
-	
+
 	if (simplified.size() == 0)
 	{
 		// If there is no connections at all,
-		// create some initial points for the simplification process. 
+		// create some initial points for the simplification process.
 		// Find lower-left and upper-right vertices of the contour.
 		int llx = points[0];
 		int lly = points[1];
@@ -290,24 +290,24 @@
 		simplified.push(lly);
 		simplified.push(llz);
 		simplified.push(lli);
-		
+
 		simplified.push(urx);
 		simplified.push(ury);
 		simplified.push(urz);
 		simplified.push(uri);
 	}
-	
+
 	// Add points until all raw points are within
 	// error tolerance to the simplified shape.
 	const int pn = points.size()/4;
 	for (int i = 0; i < simplified.size()/4; )
 	{
 		int ii = (i+1) % (simplified.size()/4);
-		
+
 		const int ax = simplified[i*4+0];
 		const int az = simplified[i*4+2];
 		const int ai = simplified[i*4+3];
-		
+
 		const int bx = simplified[ii*4+0];
 		const int bz = simplified[ii*4+2];
 		const int bi = simplified[ii*4+3];
@@ -316,7 +316,7 @@
 		float maxd = 0;
 		int maxi = -1;
 		int ci, cinc, endi;
-		
+
 		// Traverse the segment in lexilogical order so that the
 		// max deviation is calculated similarly when traversing
 		// opposite segments.
@@ -332,8 +332,8 @@
 			ci = (bi+cinc) % pn;
 			endi = ai;
 		}
-		
-		// Tessellate only outer edges oredges between areas.
+
+		// Tessellate only outer edges or edges between areas.
 		if ((points[ci*4+3] & RC_CONTOUR_REG_MASK) == 0 ||
 			(points[ci*4+3] & RC_AREA_BORDER))
 		{
@@ -348,8 +348,8 @@
 				ci = (ci+cinc) % pn;
 			}
 		}
-		
-		
+
+
 		// If the max deviation is larger than accepted error,
 		// add new point, else continue to next segment.
 		if (maxi != -1 && maxd > (maxError*maxError))
@@ -375,18 +375,18 @@
 			++i;
 		}
 	}
-	
+
 	// Split too long edges.
 	if (maxEdgeLen > 0 && (buildFlags & (RC_CONTOUR_TESS_WALL_EDGES|RC_CONTOUR_TESS_AREA_EDGES)) != 0)
 	{
 		for (int i = 0; i < simplified.size()/4; )
 		{
 			const int ii = (i+1) % (simplified.size()/4);
-			
+
 			const int ax = simplified[i*4+0];
 			const int az = simplified[i*4+2];
 			const int ai = simplified[i*4+3];
-			
+
 			const int bx = simplified[ii*4+0];
 			const int bz = simplified[ii*4+2];
 			const int bi = simplified[ii*4+3];
@@ -403,7 +403,7 @@
 			// Edges between areas.
 			if ((buildFlags & RC_CONTOUR_TESS_AREA_EDGES) && (points[ci*4+3] & RC_AREA_BORDER))
 				tess = true;
-			
+
 			if (tess)
 			{
 				int dx = bx - ax;
@@ -425,7 +425,7 @@
 					}
 				}
 			}
-			
+
 			// If the max deviation is larger than accepted error,
 			// add new point, else continue to next segment.
 			if (maxi != -1)
@@ -452,7 +452,7 @@
 			}
 		}
 	}
-	
+
 	for (int i = 0; i < simplified.size()/4; ++i)
 	{
 		// The edge vertex flag is take from the current raw point,
@@ -461,7 +461,7 @@
 		const int bi = simplified[i*4+3];
 		simplified[i*4+3] = (points[ai*4+3] & RC_CONTOUR_REG_MASK) | (points[bi*4+3] & RC_BORDER_VERTEX);
 	}
-	
+
 }
 
 static void removeDegenerateSegments(rcIntArray& simplified)
@@ -473,7 +473,7 @@
 		int ni = i+1;
 		if (ni >= (simplified.size()/4))
 			ni = 0;
-			
+
 		if (simplified[i*4+0] == simplified[ni*4+0] &&
 			simplified[i*4+2] == simplified[ni*4+2])
 		{
@@ -520,7 +520,7 @@
 		const int* va = &vertsa[i*4];
 		const int* van = &vertsa[in*4];
 		const int* vap = &vertsa[ip*4];
-		
+
 		for (int j = 0; j < nvertsb; ++j)
 		{
 			const int* vb = &vertsb[j*4];
@@ -573,7 +573,7 @@
 		dst[3] = src[3];
 		nv++;
 	}
-	
+
 	free(ca.verts);
 	ca.verts = verts;
 	ca.nverts = nv;
@@ -581,41 +581,67 @@
 	free(cb.verts);
 	cb.verts = 0;
 	cb.nverts = 0;
-	
+
 	return true;
 }
 
+/// @par
+///
+/// The raw contours will match the region outlines exactly. The @p maxError and @p maxEdgeLen
+/// parameters control how closely the simplified contours will match the raw contours.
+///
+/// Simplified contours are generated such that the vertices for portals between areas match up.
+/// (They are considered mandatory vertices.)
+///
+/// Setting @p maxEdgeLength to zero will disabled the edge length feature.
+///
+/// See the #rcConfig documentation for more information on the configuration parameters.
+///
+/// @see mallocContourSet, rcCompactHeightfield, rcContourSet, rcConfig
 bool rcBuildContours(rcContext* ctx, rcCompactHeightfield& chf,
 					 const float maxError, const int maxEdgeLen,
 					 rcContourSet& cset, const int buildFlags)
 {
 	ASSERT(ctx);
-	
+
 	const int w = chf.width;
 	const int h = chf.height;
-	
+	const int borderSize = chf.borderSize;
+
 	ctx->startTimer(RC_TIMER_BUILD_CONTOURS);
-	
+
 	rcVcopy(cset.bmin, chf.bmin);
 	rcVcopy(cset.bmax, chf.bmax);
+	if (borderSize > 0)
+	{
+		// If the heightfield was build with bordersize, remove the offset.
+		const float pad = borderSize*chf.cs;
+		cset.bmin[0] += pad;
+		cset.bmin[2] += pad;
+		cset.bmax[0] -= pad;
+		cset.bmax[2] -= pad;
+	}
 	cset.cs = chf.cs;
 	cset.ch = chf.ch;
-	
+	cset.width = chf.width - chf.borderSize*2;
+	cset.height = chf.height - chf.borderSize*2;
+	cset.borderSize = chf.borderSize;
+
 	int maxContours = rcMax((int)chf.maxRegions, 8);
 	cset.conts = (rcContour*)malloc(sizeof(rcContour)*maxContours);
 	if (!cset.conts)
 		return false;
 	cset.nconts = 0;
-	
+
 	rcScopedDelete<unsigned char> flags = (unsigned char*)malloc(sizeof(unsigned char)*chf.spanCount);
 	if (!flags)
 	{
 		ctx->log(RC_LOG_ERROR, "rcBuildContours: Out of memory 'flags' (%d).", chf.spanCount);
 		return false;
 	}
-	
+
 	ctx->startTimer(RC_TIMER_BUILD_CONTOURS_TRACE);
-	
+
 	// Mark boundaries.
 	for (int y = 0; y < h; ++y)
 	{
@@ -648,14 +674,12 @@
 			}
 		}
 	}
-	
+
 	ctx->stopTimer(RC_TIMER_BUILD_CONTOURS_TRACE);
-	
-	ctx->startTimer(RC_TIMER_BUILD_CONTOURS_SIMPLIFY);
-	
+
 	rcIntArray verts(256);
 	rcIntArray simplified(64);
-	
+
 	for (int y = 0; y < h; ++y)
 	{
 		for (int x = 0; x < w; ++x)
@@ -672,13 +696,20 @@
 				if (!reg || (reg & RC_BORDER_REG))
 					continue;
 				const unsigned char area = chf.areas[i];
-				
+
 				verts.resize(0);
 				simplified.resize(0);
+
+				ctx->startTimer(RC_TIMER_BUILD_CONTOURS_TRACE);
 				walkContour(x, y, i, chf, flags, verts);
+				ctx->stopTimer(RC_TIMER_BUILD_CONTOURS_TRACE);
+
+				ctx->startTimer(RC_TIMER_BUILD_CONTOURS_SIMPLIFY);
 				simplifyContour(verts, simplified, maxError, maxEdgeLen, buildFlags);
 				removeDegenerateSegments(simplified);
-				
+				ctx->stopTimer(RC_TIMER_BUILD_CONTOURS_SIMPLIFY);
+
+
 				// Store region->contour remap info.
 				// Create contour.
 				if (simplified.size()/4 >= 3)
@@ -699,12 +730,12 @@
 						}
 						free(cset.conts);
 						cset.conts = newConts;
-					
+
 						ctx->log(RC_LOG_WARNING, "rcBuildContours: Expanding max contours from %d to %d.", oldMax, maxContours);
 					}
-						
+
 					rcContour* cont = &cset.conts[cset.nconts++];
-					
+
 					cont->nverts = simplified.size()/4;
 					cont->verts = (int*)malloc(sizeof(int)*cont->nverts*4);
 					if (!cont->verts)
@@ -713,7 +744,17 @@
 						return false;
 					}
 					memcpy(cont->verts, &simplified[0], sizeof(int)*cont->nverts*4);
-					
+					if (borderSize > 0)
+					{
+						// If the heightfield was build with bordersize, remove the offset.
+						for (int i = 0; i < cont->nverts; ++i)
+						{
+							int* v = &cont->verts[i*4];
+							v[0] -= borderSize;
+							v[2] -= borderSize;
+						}
+					}
+
 					cont->nrverts = verts.size()/4;
 					cont->rverts = (int*)malloc(sizeof(int)*cont->nrverts*4);
 					if (!cont->rverts)
@@ -722,7 +763,17 @@
 						return false;
 					}
 					memcpy(cont->rverts, &verts[0], sizeof(int)*cont->nrverts*4);
-					
+					if (borderSize > 0)
+					{
+						// If the heightfield was build with bordersize, remove the offset.
+						for (int i = 0; i < cont->nrverts; ++i)
+						{
+							int* v = &cont->rverts[i*4];
+							v[0] -= borderSize;
+							v[2] -= borderSize;
+						}
+					}
+
 /*					cont->cx = cont->cy = cont->cz = 0;
 					for (int i = 0; i < cont->nverts; ++i)
 					{
@@ -733,14 +784,14 @@
 					cont->cx /= cont->nverts;
 					cont->cy /= cont->nverts;
 					cont->cz /= cont->nverts;*/
-					
+
 					cont->reg = reg;
 					cont->area = area;
 				}
 			}
 		}
 	}
-	
+
 	// Check and merge droppings.
 	// Sometimes the previous algorithms can fail and create several contours
 	// per area. This pass will try to merge the holes into the main region.
@@ -788,10 +839,8 @@
 			}
 		}
 	}
-	
-	ctx->stopTimer(RC_TIMER_BUILD_CONTOURS_SIMPLIFY);
-	
+
 	ctx->stopTimer(RC_TIMER_BUILD_CONTOURS);
-	
+
 	return true;
 }
Index: src/hearthstone-shared/Pathfinding/Recast/RecastFilter.cpp
===================================================================
--- src/hearthstone-shared/Pathfinding/Recast/RecastFilter.cpp	(revision 1490)
+++ src/hearthstone-shared/Pathfinding/Recast/RecastFilter.cpp	(working copy)
@@ -18,22 +18,34 @@
 
 #include "../../Common.h"
 
+/// @par
+///
+/// Allows the formation of walkable regions that will flow over low lying
+/// objects such as curbs, and up structures such as stairways.
+///
+/// Two neighboring spans are walkable if: <tt>rcAbs(currentSpan.smax - neighborSpan.smax) < waklableClimb</tt>
+///
+/// @warning Will override the effect of #rcFilterLedgeSpans.  So if both filters are used, call
+/// #rcFilterLedgeSpans after calling this filter.
+///
+/// @see rcHeightfield, rcConfig
 void rcFilterLowHangingWalkableObstacles(rcContext* ctx, const int walkableClimb, rcHeightfield& solid)
 {
 	ASSERT(ctx);
 
 	ctx->startTimer(RC_TIMER_FILTER_LOW_OBSTACLES);
-	
+
 	const int w = solid.width;
 	const int h = solid.height;
-	
+
 	for (int y = 0; y < h; ++y)
 	{
 		for (int x = 0; x < w; ++x)
 		{
 			rcSpan* ps = 0;
 			bool previousWalkable = false;
-			
+			unsigned char previousArea = RC_NULL_AREA;
+
 			for (rcSpan* s = solid.spans[x + y*w]; s; ps = s, s = s->next)
 			{
 				const bool walkable = s->area != RC_NULL_AREA;
@@ -42,29 +54,40 @@
 				if (!walkable && previousWalkable)
 				{
 					if (rcAbs((int)s->smax - (int)ps->smax) <= walkableClimb)
-						s->area = RC_NULL_AREA;
+						s->area = previousArea;
 				}
 				// Copy walkable flag so that it cannot propagate
 				// past multiple non-walkable objects.
 				previousWalkable = walkable;
+				previousArea = s->area;
 			}
 		}
 	}
 
 	ctx->stopTimer(RC_TIMER_FILTER_LOW_OBSTACLES);
 }
-	
+
+/// @par
+///
+/// A ledge is a span with one or more neighbors whose maximum is further away than @p walkableClimb
+/// from the current span's maximum.
+/// This method removes the impact of the overestimation of conservative voxelization
+/// so the resulting mesh will not have regions hanging in the air over ledges.
+///
+/// A span is a ledge if: <tt>rcAbs(currentSpan.smax - neighborSpan.smax) > walkableClimb</tt>
+///
+/// @see rcHeightfield, rcConfig
 void rcFilterLedgeSpans(rcContext* ctx, const int walkableHeight, const int walkableClimb,
 						rcHeightfield& solid)
 {
 	ASSERT(ctx);
-	
+
 	ctx->startTimer(RC_TIMER_FILTER_BORDER);
 
 	const int w = solid.width;
 	const int h = solid.height;
 	const int MAX_HEIGHT = 0xffff;
-	
+
 	// Mark border spans.
 	for (int y = 0; y < h; ++y)
 	{
@@ -75,10 +98,10 @@
 				// Skip non walkable spans.
 				if (s->area == RC_NULL_AREA)
 					continue;
-				
+
 				const int bot = (int)(s->smax);
 				const int top = s->next ? (int)(s->next->smin) : MAX_HEIGHT;
-				
+
 				// Find neighbours minimum height.
 				int minh = MAX_HEIGHT;
 
@@ -104,7 +127,7 @@
 					// Skip neightbour if the gap between the spans is too small.
 					if (rcMin(top,ntop) - rcMax(bot,nbot) > walkableHeight)
 						minh = rcMin(minh, nbot - bot);
-					
+
 					// Rest of the spans.
 					for (ns = solid.spans[dx + dy*w]; ns; ns = ns->next)
 					{
@@ -114,23 +137,23 @@
 						if (rcMin(top,ntop) - rcMax(bot,nbot) > walkableHeight)
 						{
 							minh = rcMin(minh, nbot - bot);
-						
-							// Find min/max accessible neighbour height. 
+
+							// Find min/max accessible neighbour height.
 							if (rcAbs(nbot - bot) <= walkableClimb)
 							{
 								if (nbot < asmin) asmin = nbot;
 								if (nbot > asmax) asmax = nbot;
 							}
-							
+
 						}
 					}
 				}
-				
+
 				// The current span is close to a ledge if the drop to any
 				// neighbour span is less than the walkableClimb.
 				if (minh < -walkableClimb)
 					s->area = RC_NULL_AREA;
-					
+
 				// If the difference between all neighbours is too large,
 				// we are at steep slope, mark the span as ledge.
 				if ((asmax - asmin) > walkableClimb)
@@ -140,20 +163,26 @@
 			}
 		}
 	}
-	
+
 	ctx->stopTimer(RC_TIMER_FILTER_BORDER);
-}	
+}
 
+/// @par
+///
+/// For this filter, the clearance above the span is the distance from the span's
+/// maximum to the next higher span's minimum. (Same grid column.)
+///
+/// @see rcHeightfield, rcConfig
 void rcFilterWalkableLowHeightSpans(rcContext* ctx, int walkableHeight, rcHeightfield& solid)
 {
 	ASSERT(ctx);
-	
+
 	ctx->startTimer(RC_TIMER_FILTER_WALKABLE);
-	
+
 	const int w = solid.width;
 	const int h = solid.height;
 	const int MAX_HEIGHT = 0xffff;
-	
+
 	// Remove walkable flag from spans which do not have enough
 	// space above them for the agent to stand there.
 	for (int y = 0; y < h; ++y)
@@ -169,6 +198,6 @@
 			}
 		}
 	}
-	
+
 	ctx->stopTimer(RC_TIMER_FILTER_WALKABLE);
 }
Index: src/hearthstone-shared/Pathfinding/Recast/RecastMesh.cpp
===================================================================
--- src/hearthstone-shared/Pathfinding/Recast/RecastMesh.cpp	(revision 1490)
+++ src/hearthstone-shared/Pathfinding/Recast/RecastMesh.cpp	(working copy)
@@ -30,29 +30,32 @@
 {
 	// Based on code by Eric Lengyel from:
 	// http://www.terathon.com/code/edges.php
-	
+
 	int maxEdgeCount = npolys*vertsPerPoly;
 	unsigned short* firstEdge = (unsigned short*)malloc(sizeof(unsigned short)*(nverts + maxEdgeCount));
 	if (!firstEdge)
 		return false;
 	unsigned short* nextEdge = firstEdge + nverts;
 	int edgeCount = 0;
-	
+
 	rcEdge* edges = (rcEdge*)malloc(sizeof(rcEdge)*maxEdgeCount);
 	if (!edges)
 	{
 		free(firstEdge);
 		return false;
 	}
-	
+
 	for (int i = 0; i < nverts; i++)
 		firstEdge[i] = RC_MESH_NULL_IDX;
-	
+
 	for (int i = 0; i < npolys; ++i)
 	{
 		unsigned short* t = &polys[i*vertsPerPoly*2];
 		for (int j = 0; j < vertsPerPoly; ++j)
 		{
+			if (t[j] == RC_MESH_NULL_IDX)
+				break;
+
 			unsigned short v0 = t[j];
 			unsigned short v1 = (j+1 >= vertsPerPoly || t[j+1] == RC_MESH_NULL_IDX) ? t[0] : t[j+1];
 			if (v0 < v1)
@@ -71,12 +74,15 @@
 			}
 		}
 	}
-	
+
 	for (int i = 0; i < npolys; ++i)
 	{
 		unsigned short* t = &polys[i*vertsPerPoly*2];
 		for (int j = 0; j < vertsPerPoly; ++j)
 		{
+			if (t[j] == RC_MESH_NULL_IDX)
+				break;
+
 			unsigned short v0 = t[j];
 			unsigned short v1 = (j+1 >= vertsPerPoly || t[j+1] == RC_MESH_NULL_IDX) ? t[0] : t[j+1];
 			if (v0 > v1)
@@ -94,7 +100,7 @@
 			}
 		}
 	}
-	
+
 	// Store adjacency
 	for (int i = 0; i < edgeCount; ++i)
 	{
@@ -107,10 +113,10 @@
 			p1[vertsPerPoly + e.polyEdge[1]] = e.poly[0];
 		}
 	}
-	
+
 	free(firstEdge);
 	free(edges);
-	
+
 	return true;
 }
 
@@ -131,7 +137,7 @@
 {
 	int bucket = computeVertexHash(x, 0, z);
 	int i = firstVert[bucket];
-	
+
 	while (i != -1)
 	{
 		const unsigned short* v = &verts[i*3];
@@ -139,7 +145,7 @@
 			return (unsigned short)i;
 		i = nextVert[i]; // next
 	}
-	
+
 	// Could not find, create new.
 	i = nv; nv++;
 	unsigned short* v = &verts[i*3];
@@ -148,7 +154,7 @@
 	v[2] = z;
 	nextVert[i] = firstVert[bucket];
 	firstVert[bucket] = i;
-	
+
 	return (unsigned short)i;
 }
 
@@ -189,17 +195,17 @@
 //	Returns true iff ab properly intersects cd: they share
 //	a point interior to both segments.  The properness of the
 //	intersection is ensured by using strict leftness.
-bool intersectProp(const int* a, const int* b, const int* c, const int* d)
+static bool intersectProp(const int* a, const int* b, const int* c, const int* d)
 {
 	// Eliminate improper cases.
 	if (collinear(a,b,c) || collinear(a,b,d) ||
 		collinear(c,d,a) || collinear(c,d,b))
 		return false;
-	
+
 	return xorb(left(a,b,c), left(a,b,d)) && xorb(left(c,d,a), left(c,d,b));
 }
 
-// Returns T iff (a,b,c) are collinear and point c lies 
+// Returns T iff (a,b,c) are collinear and point c lies
 // on the closed segement ab.
 static bool between(const int* a, const int* b, const int* c)
 {
@@ -235,7 +241,7 @@
 {
 	const int* d0 = &verts[(indices[i] & 0x0fffffff) * 4];
 	const int* d1 = &verts[(indices[j] & 0x0fffffff) * 4];
-	
+
 	// For each edge (k,k+1) of P
 	for (int k = 0; k < n; k++)
 	{
@@ -248,7 +254,7 @@
 
 			if (vequal(d0, p0) || vequal(d1, p0) || vequal(d0, p1) || vequal(d1, p1))
 				continue;
-			
+
 			if (intersect(d0, d1, p0, p1))
 				return false;
 		}
@@ -256,7 +262,7 @@
 	return true;
 }
 
-// Returns true iff the diagonal (i,j) is strictly internal to the 
+// Returns true iff the diagonal (i,j) is strictly internal to the
 // polygon P in the neighborhood of the i endpoint.
 static bool	inCone(int i, int j, int n, const int* verts, int* indices)
 {
@@ -284,7 +290,7 @@
 {
 	int ntris = 0;
 	int* dst = tris;
-	
+
 	// The last bit of the index is used to indicate if the vertex can be removed.
 	for (int i = 0; i < n; i++)
 	{
@@ -293,7 +299,7 @@
 		if (diagonal(i, i2, n, verts, indices))
 			indices[i1] |= 0x80000000;
 	}
-	
+
 	while (n > 3)
 	{
 		int minLen = -1;
@@ -305,11 +311,11 @@
 			{
 				const int* p0 = &verts[(indices[i] & 0x0fffffff) * 4];
 				const int* p2 = &verts[(indices[next(i1, n)] & 0x0fffffff) * 4];
-				
+
 				int dx = p2[0] - p0[0];
 				int dy = p2[2] - p0[2];
 				int len = dx*dx + dy*dy;
-				
+
 				if (minLen < 0 || len < minLen)
 				{
 					minLen = len;
@@ -317,7 +323,7 @@
 				}
 			}
 		}
-		
+
 		if (mini == -1)
 		{
 			// Should not happen.
@@ -329,21 +335,21 @@
 			printf("\n");*/
 			return -ntris;
 		}
-		
+
 		int i = mini;
 		int i1 = next(i, n);
 		int i2 = next(i1, n);
-		
+
 		*dst++ = indices[i] & 0x0fffffff;
 		*dst++ = indices[i1] & 0x0fffffff;
 		*dst++ = indices[i2] & 0x0fffffff;
 		ntris++;
-		
+
 		// Removes P[i1] by copying P[i+1]...P[n-1] left one index.
 		n--;
 		for (int k = i1; k < n; k++)
 			indices[k] = indices[k+1];
-		
+
 		if (i1 >= n) i1 = 0;
 		i = prev(i1,n);
 		// Update diagonal flags.
@@ -351,19 +357,19 @@
 			indices[i] |= 0x80000000;
 		else
 			indices[i] &= 0x0fffffff;
-		
+
 		if (diagonal(i, next(i1, n), n, verts, indices))
 			indices[i1] |= 0x80000000;
 		else
 			indices[i1] &= 0x0fffffff;
 	}
-	
+
 	// Append the remaining triangle.
 	*dst++ = indices[0] & 0x0fffffff;
 	*dst++ = indices[1] & 0x0fffffff;
 	*dst++ = indices[2] & 0x0fffffff;
 	ntris++;
-	
+
 	return ntris;
 }
 
@@ -387,15 +393,15 @@
 {
 	const int na = countPolyVerts(pa, nvp);
 	const int nb = countPolyVerts(pb, nvp);
-	
+
 	// If the merged polygon would be too big, do not merge.
 	if (na+nb-2 > nvp)
 		return -1;
-	
+
 	// Check if the polygons share an edge.
 	ea = -1;
 	eb = -1;
-	
+
 	for (int i = 0; i < na; ++i)
 	{
 		unsigned short va0 = pa[i];
@@ -416,32 +422,32 @@
 			}
 		}
 	}
-	
+
 	// No common edge, cannot merge.
 	if (ea == -1 || eb == -1)
 		return -1;
-	
+
 	// Check to see if the merged polygon would be convex.
 	unsigned short va, vb, vc;
-	
+
 	va = pa[(ea+na-1) % na];
 	vb = pa[ea];
 	vc = pb[(eb+2) % nb];
 	if (!uleft(&verts[va*3], &verts[vb*3], &verts[vc*3]))
 		return -1;
-	
+
 	va = pb[(eb+nb-1) % nb];
 	vb = pb[eb];
 	vc = pa[(ea+2) % na];
 	if (!uleft(&verts[va*3], &verts[vb*3], &verts[vc*3]))
 		return -1;
-	
+
 	va = pa[ea];
 	vb = pa[(ea+1)%na];
-	
+
 	int dx = (int)verts[va*3+0] - (int)verts[vb*3+0];
 	int dy = (int)verts[va*3+2] - (int)verts[vb*3+2];
-	
+
 	return dx*dx + dy*dy;
 }
 
@@ -450,7 +456,7 @@
 {
 	const int na = countPolyVerts(pa, nvp);
 	const int nb = countPolyVerts(pb, nvp);
-	
+
 	// Merge polygons.
 	memset(tmp, 0xff, sizeof(unsigned short)*nvp);
 	int n = 0;
@@ -460,10 +466,11 @@
 	// Add pb
 	for (int i = 0; i < nb-1; ++i)
 		tmp[n++] = pb[(eb+1+i) % nb];
-	
+
 	memcpy(pa, tmp, sizeof(unsigned short)*nvp);
 }
 
+
 static void pushFront(int v, int* arr, int& an)
 {
 	an++;
@@ -480,7 +487,7 @@
 static bool canRemoveVertex(rcContext* ctx, rcPolyMesh& mesh, const unsigned short rem)
 {
 	const int nvp = mesh.nvp;
-	
+
 	// Count number of polygons to remove.
 	int numRemovedVerts = 0;
 	int numTouchedVerts = 0;
@@ -506,14 +513,14 @@
 			numRemainingEdges += numVerts-(numRemoved+1);
 		}
 	}
-	
+
 	// There would be too few edges remaining to create a polygon.
 	// This can happen for example when a tip of a triangle is marked
 	// as deletion, but there are no other polys that share the vertex.
 	// In this case, the vertex should not be removed.
 	if (numRemainingEdges <= 2)
 		return false;
-	
+
 	// Find edges which share the removed vertex.
 	const int maxEdges = numTouchedVerts*2;
 	int nedges = 0;
@@ -523,7 +530,7 @@
 		ctx->log(RC_LOG_WARNING, "canRemoveVertex: Out of memory 'edges' (%d).", maxEdges*3);
 		return false;
 	}
-		
+
 	for (int i = 0; i < mesh.npolys; ++i)
 	{
 		unsigned short* p = &mesh.polys[i*nvp*2];
@@ -538,7 +545,7 @@
 				int a = p[j], b = p[k];
 				if (b == rem)
 					rcSwap(a,b);
-					
+
 				// Check if the edge exists
 				bool exists = false;
 				for (int k = 0; k < nedges; ++k)
@@ -575,7 +582,7 @@
 	}
 	if (numOpenEdges > 2)
 		return false;
-	
+
 	return true;
 }
 
@@ -595,7 +602,7 @@
 				numRemovedVerts++;
 		}
 	}
-	
+
 	int nedges = 0;
 	rcScopedDelete<int> edges = (int*)malloc(sizeof(int)*numRemovedVerts*nvp*4);
 	if (!edges)
@@ -611,7 +618,7 @@
 		ctx->log(RC_LOG_WARNING, "removeVertex: Out of memory 'hole' (%d).", numRemovedVerts*nvp);
 		return false;
 	}
-	
+
 	int nhreg = 0;
 	rcScopedDelete<int> hreg = (int*)malloc(sizeof(int)*numRemovedVerts*nvp);
 	if (!hreg)
@@ -627,7 +634,7 @@
 		ctx->log(RC_LOG_WARNING, "removeVertex: Out of memory 'harea' (%d).", numRemovedVerts*nvp);
 		return false;
 	}
-	
+
 	for (int i = 0; i < mesh.npolys; ++i)
 	{
 		unsigned short* p = &mesh.polys[i*nvp*2];
@@ -660,7 +667,7 @@
 			--i;
 		}
 	}
-	
+
 	// Remove vertex.
 	for (int i = (int)rem; i < mesh.nverts; ++i)
 	{
@@ -692,11 +699,11 @@
 	pushBack(edges[0], hole, nhole);
 	pushBack(edges[2], hreg, nhreg);
 	pushBack(edges[3], harea, nharea);
-	
+
 	while (nedges)
 	{
 		bool match = false;
-		
+
 		for (int i = 0; i < nedges; ++i)
 		{
 			const int ea = edges[i*4+0];
@@ -732,7 +739,7 @@
 				--i;
 			}
 		}
-		
+
 		if (!match)
 			break;
 	}
@@ -776,7 +783,7 @@
 		ntris = -ntris;
 		ctx->log(RC_LOG_WARNING, "removeVertex: triangulate() returned bad results.");
 	}
-	
+
 	// Merge the hole triangles back to polygons.
 	rcScopedDelete<unsigned short> polys = (unsigned short*)malloc(sizeof(unsigned short)*(ntris+1)*nvp);
 	if (!polys)
@@ -796,9 +803,9 @@
 		ctx->log(RC_LOG_ERROR, "removeVertex: Out of memory 'pareas' (%d).", ntris);
 		return false;
 	}
-	
+
 	unsigned short* tmpPoly = &polys[ntris*nvp];
-			
+
 	// Build initial polygons.
 	int npolys = 0;
 	memset(polys, 0xff, ntris*nvp*sizeof(unsigned short));
@@ -817,7 +824,7 @@
 	}
 	if (!npolys)
 		return true;
-	
+
 	// Merge polygons.
 	if (nvp > 3)
 	{
@@ -826,7 +833,7 @@
 			// Find best polygons to merge.
 			int bestMergeVal = 0;
 			int bestPa = 0, bestPb = 0, bestEa = 0, bestEb = 0;
-			
+
 			for (int j = 0; j < npolys-1; ++j)
 			{
 				unsigned short* pj = &polys[j*nvp];
@@ -845,7 +852,7 @@
 					}
 				}
 			}
-			
+
 			if (bestMergeVal > 0)
 			{
 				// Found best, merge.
@@ -864,7 +871,7 @@
 			}
 		}
 	}
-	
+
 	// Store polygons.
 	for (int i = 0; i < npolys; ++i)
 	{
@@ -882,22 +889,28 @@
 			return false;
 		}
 	}
-	
+
 	return true;
 }
 
-
-bool rcBuildPolyMesh(rcContext* ctx, rcContourSet& cset, int nvp, rcPolyMesh& mesh)
+/// @par
+///
+/// @note If the mesh data is to be used to construct a Detour navigation mesh, then the upper
+/// limit must be retricted to <= #DT_VERTS_PER_POLYGON.
+///
+/// @see mallocPolyMesh, rcContourSet, rcPolyMesh, rcConfig
+bool rcBuildPolyMesh(rcContext* ctx, rcContourSet& cset, const int nvp, rcPolyMesh& mesh)
 {
 	ASSERT(ctx);
-	
+
 	ctx->startTimer(RC_TIMER_BUILD_POLYMESH);
 
 	rcVcopy(mesh.bmin, cset.bmin);
 	rcVcopy(mesh.bmax, cset.bmax);
 	mesh.cs = cset.cs;
 	mesh.ch = cset.ch;
-	
+	mesh.borderSize = cset.borderSize;
+
 	int maxVertices = 0;
 	int maxTris = 0;
 	int maxVertsPerCont = 0;
@@ -909,13 +922,13 @@
 		maxTris += cset.conts[i].nverts - 2;
 		maxVertsPerCont = rcMax(maxVertsPerCont, cset.conts[i].nverts);
 	}
-	
+
 	if (maxVertices >= 0xfffe)
 	{
 		ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: Too many vertices %d.", maxVertices);
 		return false;
 	}
-		
+
 	rcScopedDelete<unsigned char> vflags = (unsigned char*)malloc(sizeof(unsigned char)*maxVertices);
 	if (!vflags)
 	{
@@ -923,14 +936,14 @@
 		return false;
 	}
 	memset(vflags, 0, maxVertices);
-	
+
 	mesh.verts = (unsigned short*)malloc(sizeof(unsigned short)*maxVertices*3);
 	if (!mesh.verts)
 	{
 		ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: Out of memory 'mesh.verts' (%d).", maxVertices);
 		return false;
 	}
-	mesh.polys = (unsigned short*)malloc(sizeof(unsigned short)*maxTris*nvp*2*2);
+	mesh.polys = (unsigned short*)malloc(sizeof(unsigned short)*maxTris*nvp*2);
 	if (!mesh.polys)
 	{
 		ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: Out of memory 'mesh.polys' (%d).", maxTris*nvp*2);
@@ -948,17 +961,17 @@
 		ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: Out of memory 'mesh.areas' (%d).", maxTris);
 		return false;
 	}
-	
+
 	mesh.nverts = 0;
 	mesh.npolys = 0;
 	mesh.nvp = nvp;
 	mesh.maxpolys = maxTris;
-	
+
 	memset(mesh.verts, 0, sizeof(unsigned short)*maxVertices*3);
 	memset(mesh.polys, 0xff, sizeof(unsigned short)*maxTris*nvp*2);
 	memset(mesh.regs, 0, sizeof(unsigned short)*maxTris);
 	memset(mesh.areas, 0, sizeof(unsigned char)*maxTris);
-	
+
 	rcScopedDelete<int> nextVert = (int*)malloc(sizeof(int)*maxVertices);
 	if (!nextVert)
 	{
@@ -966,7 +979,7 @@
 		return false;
 	}
 	memset(nextVert, 0, sizeof(int)*maxVertices);
-	
+
 	rcScopedDelete<int> firstVert = (int*)malloc(sizeof(int)*VERTEX_BUCKET_COUNT);
 	if (!firstVert)
 	{
@@ -975,7 +988,7 @@
 	}
 	for (int i = 0; i < VERTEX_BUCKET_COUNT; ++i)
 		firstVert[i] = -1;
-	
+
 	rcScopedDelete<int> indices = (int*)malloc(sizeof(int)*maxVertsPerCont);
 	if (!indices)
 	{
@@ -999,15 +1012,15 @@
 	for (int i = 0; i < cset.nconts; ++i)
 	{
 		rcContour& cont = cset.conts[i];
-		
+
 		// Skip null contours.
 		if (cont.nverts < 3)
 			continue;
-		
+
 		// Triangulate contour
 		for (int j = 0; j < cont.nverts; ++j)
 			indices[j] = j;
-			
+
 		int ntris = triangulate(cont.nverts, cont.verts, &indices[0], &tris[0]);
 		if (ntris <= 0)
 		{
@@ -1025,7 +1038,7 @@
 			ctx->log(RC_LOG_WARNING, "rcBuildPolyMesh: Bad triangulation Contour %d.", i);
 			ntris = -ntris;
 		}
-				
+
 		// Add and merge vertices.
 		for (int j = 0; j < cont.nverts; ++j)
 		{
@@ -1038,7 +1051,7 @@
 				vflags[indices[j]] = 1;
 			}
 		}
-		
+
 		// Build initial polygons.
 		int npolys = 0;
 		memset(polys, 0xff, maxVertsPerCont*nvp*sizeof(unsigned short));
@@ -1055,7 +1068,7 @@
 		}
 		if (!npolys)
 			continue;
-		
+
 		// Merge polygons.
 		if (nvp > 3)
 		{
@@ -1064,7 +1077,7 @@
 				// Find best polygons to merge.
 				int bestMergeVal = 0;
 				int bestPa = 0, bestPb = 0, bestEa = 0, bestEb = 0;
-				
+
 				for (int j = 0; j < npolys-1; ++j)
 				{
 					unsigned short* pj = &polys[j*nvp];
@@ -1083,7 +1096,7 @@
 						}
 					}
 				}
-				
+
 				if (bestMergeVal > 0)
 				{
 					// Found best, merge.
@@ -1100,7 +1113,7 @@
 				}
 			}
 		}
-		
+
 		// Store polygons.
 		for (int j = 0; j < npolys; ++j)
 		{
@@ -1118,8 +1131,8 @@
 			}
 		}
 	}
-	
-	
+
+
 	// Remove edge vertices.
 	for (int i = 0; i < mesh.nverts; ++i)
 	{
@@ -1140,7 +1153,7 @@
 			--i;
 		}
 	}
-	
+
 	// Calculate adjacency.
 	if (!buildMeshAdjacency(mesh.polys, mesh.npolys, mesh.nverts, nvp))
 	{
@@ -1148,6 +1161,37 @@
 		return false;
 	}
 
+	// Find portal edges
+	if (mesh.borderSize > 0)
+	{
+		const int w = cset.width;
+		const int h = cset.height;
+		for (int i = 0; i < mesh.npolys; ++i)
+		{
+			unsigned short* p = &mesh.polys[i*2*nvp];
+			for (int j = 0; j < nvp; ++j)
+			{
+				if (p[j] == RC_MESH_NULL_IDX) break;
+				// Skip connected edges.
+				if (p[nvp+j] != RC_MESH_NULL_IDX)
+					continue;
+				int nj = j+1;
+				if (nj >= nvp || p[nj] == RC_MESH_NULL_IDX) nj = 0;
+				const unsigned short* va = &mesh.verts[p[j]*3];
+				const unsigned short* vb = &mesh.verts[p[nj]*3];
+
+				if ((int)va[0] == 0 && (int)vb[0] == 0)
+					p[nvp+j] = 0x8000 | 0;
+				else if ((int)va[2] == h && (int)vb[2] == h)
+					p[nvp+j] = 0x8000 | 1;
+				else if ((int)va[0] == w && (int)vb[0] == w)
+					p[nvp+j] = 0x8000 | 2;
+				else if ((int)va[2] == 0 && (int)vb[2] == 0)
+					p[nvp+j] = 0x8000 | 3;
+			}
+		}
+	}
+
 	// Just allocate the mesh flags array. The user is resposible to fill it.
 	mesh.flags = (unsigned short*)malloc(sizeof(unsigned short)*mesh.npolys);
 	if (!mesh.flags)
@@ -1156,25 +1200,26 @@
 		return false;
 	}
 	memset(mesh.flags, 0, sizeof(unsigned short) * mesh.npolys);
-	
+
 	if (mesh.nverts > 0xffff)
 	{
-		ctx->log(RC_LOG_ERROR, "rcMergePolyMeshes: The resulting mesh has too many vertices %d (max %d). Data can be corrupted.", mesh.nverts, 0xffff);
+		ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: The resulting mesh has too many vertices %d (max %d). Data can be corrupted.", mesh.nverts, 0xffff);
 	}
 	if (mesh.npolys > 0xffff)
 	{
-		ctx->log(RC_LOG_ERROR, "rcMergePolyMeshes: The resulting mesh has too many polygons %d (max %d). Data can be corrupted.", mesh.npolys, 0xffff);
+		ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: The resulting mesh has too many polygons %d (max %d). Data can be corrupted.", mesh.npolys, 0xffff);
 	}
-	
+
 	ctx->stopTimer(RC_TIMER_BUILD_POLYMESH);
-	
+
 	return true;
 }
 
+/// @see mallocPolyMesh, rcPolyMesh
 bool rcMergePolyMeshes(rcContext* ctx, rcPolyMesh** meshes, const int nmeshes, rcPolyMesh& mesh)
 {
 	ASSERT(ctx);
-	
+
 	if (!nmeshes || !meshes)
 		return true;
 
@@ -1197,7 +1242,7 @@
 		maxVerts += meshes[i]->nverts;
 		maxPolys += meshes[i]->npolys;
 	}
-	
+
 	mesh.nverts = 0;
 	mesh.verts = (unsigned short*)malloc(sizeof(unsigned short)*maxVerts*3);
 	if (!mesh.verts)
@@ -1238,7 +1283,7 @@
 		return false;
 	}
 	memset(mesh.flags, 0, sizeof(unsigned short)*maxPolys);
-	
+
 	rcScopedDelete<int> nextVert = (int*)malloc(sizeof(int)*maxVerts);
 	if (!nextVert)
 	{
@@ -1246,7 +1291,7 @@
 		return false;
 	}
 	memset(nextVert, 0, sizeof(int)*maxVerts);
-	
+
 	rcScopedDelete<int> firstVert = (int*)malloc(sizeof(int)*VERTEX_BUCKET_COUNT);
 	if (!firstVert)
 	{
@@ -1263,21 +1308,21 @@
 		return false;
 	}
 	memset(nextVert, 0, sizeof(int)*maxVerts);
-	
+
 	for (int i = 0; i < nmeshes; ++i)
 	{
 		const rcPolyMesh* pmesh = meshes[i];
-		
+
 		const unsigned short ox = (unsigned short)floorf((pmesh->bmin[0]-mesh.bmin[0])/mesh.cs+0.5f);
 		const unsigned short oz = (unsigned short)floorf((pmesh->bmin[2]-mesh.bmin[2])/mesh.cs+0.5f);
-		
+
 		for (int j = 0; j < pmesh->nverts; ++j)
 		{
 			unsigned short* v = &pmesh->verts[j*3];
 			vremap[j] = addVertex(v[0]+ox, v[1], v[2]+oz,
 								  mesh.verts, firstVert, nextVert, mesh.nverts);
 		}
-		
+
 		for (int j = 0; j < pmesh->npolys; ++j)
 		{
 			unsigned short* tgt = &mesh.polys[mesh.npolys*2*mesh.nvp];
@@ -1309,8 +1354,8 @@
 	{
 		ctx->log(RC_LOG_ERROR, "rcMergePolyMeshes: The resulting mesh has too many polygons %d (max %d). Data can be corrupted.", mesh.npolys, 0xffff);
 	}
-	
+
 	ctx->stopTimer(RC_TIMER_MERGE_POLYMESH);
-	
+
 	return true;
 }
Index: src/hearthstone-shared/Pathfinding/Recast/RecastMeshDetail.cpp
===================================================================
--- src/hearthstone-shared/Pathfinding/Recast/RecastMeshDetail.cpp	(revision 1490)
+++ src/hearthstone-shared/Pathfinding/Recast/RecastMeshDetail.cpp	(working copy)
@@ -47,7 +47,7 @@
 }
 
 inline float vcross2(const float* p1, const float* p2, const float* p3)
-{ 
+{
 	const float u1 = p2[0] - p1[0];
 	const float v1 = p2[2] - p1[2];
 	const float u2 = p3[0] - p1[0];
@@ -59,7 +59,7 @@
 						 float* c, float& r)
 {
 	static const float EPS = 1e-6f;
-	
+
 	const float cp = vcross2(p1, p2, p3);
 	if (fabsf(cp) > EPS)
 	{
@@ -90,12 +90,12 @@
 	const float dot02 = vdot2(v0, v2);
 	const float dot11 = vdot2(v1, v1);
 	const float dot12 = vdot2(v1, v2);
-	
+
 	// Compute barycentric coordinates
 	const float invDenom = 1.0f / (dot00 * dot11 - dot01 * dot01);
 	const float u = (dot11 * dot02 - dot01 * dot12) * invDenom;
 	float v = (dot00 * dot12 - dot01 * dot02) * invDenom;
-	
+
 	// If point lies inside the triangle, return interpolated y-coord.
 	static const float EPS = 1e-4f;
 	if (u >= -EPS && v >= -EPS && (u+v) <= 1+EPS)
@@ -122,11 +122,11 @@
 		t = 0;
 	else if (t > 1)
 		t = 1;
-	
+
 	dx = p[0] + t*pqx - pt[0];
 	dy = p[1] + t*pqy - pt[1];
 	dz = p[2] + t*pqz - pt[2];
-	
+
 	return dx*dx + dy*dy + dz*dz;
 }
 
@@ -144,10 +144,10 @@
 		t = 0;
 	else if (t > 1)
 		t = 1;
-	
+
 	dx = p[0] + t*pqx - pt[0];
 	dz = p[2] + t*pqz - pt[2];
-	
+
 	return dx*dx + dz*dz;
 }
 
@@ -214,8 +214,8 @@
 				h = nh;
 				dmin = d;
 			}
-			
-/*			const float dx = (nx+0.5f)*cs - fx; 
+
+/*			const float dx = (nx+0.5f)*cs - fx;
 			const float dz = (nz+0.5f)*cs - fz;
 			const float d = dx*dx+dz*dz;
 			if (d < dmin)
@@ -253,8 +253,8 @@
 		ctx->log(RC_LOG_ERROR, "addEdge: Too many edges (%d/%d).", nedges, maxEdges);
 		return UNDEF;
 	}
-	
-	// Add edge if not already in the triangulation. 
+
+	// Add edge if not already in the triangulation.
 	int e = findEdge(edges, nedges, s, t);
 	if (e == UNDEF)
 	{
@@ -277,7 +277,7 @@
 		e[2] = f;
 	else if (e[1] == s && e[0] == t && e[3] == UNDEF)
 		e[3] = f;
-}	
+}
 
 static int overlapSegSeg2d(const float* a, const float* b, const float* c, const float* d)
 {
@@ -289,7 +289,7 @@
 		float a4 = a3 + a2 - a1;
 		if (a3 * a4 < 0.0f)
 			return 1;
-	}	
+	}
 	return 0;
 }
 
@@ -313,7 +313,7 @@
 	static const float EPS = 1e-5f;
 
 	int* edge = &edges[e*4];
-	
+
 	// Cache s and t.
 	int s,t;
 	if (edge[2] == UNDEF)
@@ -328,11 +328,11 @@
 	}
 	else
 	{
-	    // Edge already completed. 
+	    // Edge already completed.
 	    return;
 	}
-    
-	// Find best point on left of edge. 
+
+	// Find best point on left of edge.
 	int pt = npts;
 	float c[3] = {0,0,0};
 	float r = -1;
@@ -375,27 +375,27 @@
 			}
 		}
 	}
-	
-	// Add new triangle or update edge info if s-t is on hull. 
+
+	// Add new triangle or update edge info if s-t is on hull.
 	if (pt < npts)
 	{
-		// Update face information of edge being completed. 
+		// Update face information of edge being completed.
 		updateLeftFace(&edges[e*4], s, t, nfaces);
-		
-		// Add new edge or update face info of old edge. 
+
+		// Add new edge or update face info of old edge.
 		e = findEdge(edges, nedges, pt, s);
 		if (e == UNDEF)
 		    addEdge(ctx, edges, nedges, maxEdges, pt, s, nfaces, UNDEF);
 		else
 		    updateLeftFace(&edges[e*4], pt, s, nfaces);
-		
-		// Add new edge or update face info of old edge. 
+
+		// Add new edge or update face info of old edge.
 		e = findEdge(edges, nedges, t, pt);
 		if (e == UNDEF)
 		    addEdge(ctx, edges, nedges, maxEdges, t, pt, nfaces, UNDEF);
 		else
 		    updateLeftFace(&edges[e*4], t, pt, nfaces);
-		
+
 		nfaces++;
 	}
 	else
@@ -412,10 +412,10 @@
 	int nedges = 0;
 	const int maxEdges = npts*10;
 	edges.resize(maxEdges*4);
-	
+
 	for (int i = 0, j = nhull-1; i < nhull; j=i++)
 		addEdge(ctx, &edges[0], nedges, maxEdges, hull[j],hull[i], HULL, UNDEF);
-	
+
 	int currentEdge = 0;
 	while (currentEdge < nedges)
 	{
@@ -430,7 +430,7 @@
 	tris.resize(nfaces*4);
 	for (int i = 0; i < nfaces*4; ++i)
 		tris[i] = -1;
-	
+
 	for (int i = 0; i < nedges; ++i)
 	{
 		const int* e = &edges[i*4];
@@ -463,7 +463,7 @@
 				t[2] = e[0];
 		}
 	}
-	
+
 	for (int i = 0; i < tris.size()/4; ++i)
 	{
 		int* t = &tris[i*4];
@@ -509,10 +509,10 @@
 	for (int i = 0; i < nin; ++i)
 		rcVcopy(&verts[i*3], &in[i*3]);
 	nverts = nin;
-	
+
 	const float cs = chf.cs;
 	const float ics = 1.0f/cs;
-	
+
 	// Tessellate outlines.
 	// This is done in separate pass in order to ensure
 	// seamless height values across the ply boundaries.
@@ -550,7 +550,7 @@
 			if (nn >= MAX_VERTS_PER_EDGE) nn = MAX_VERTS_PER_EDGE-1;
 			if (nverts+nn >= MAX_VERTS)
 				nn = MAX_VERTS-1-nverts;
-			
+
 			for (int k = 0; k <= nn; ++k)
 			{
 				float u = (float)k/(float)nn;
@@ -595,7 +595,7 @@
 					++k;
 				}
 			}
-			
+
 			hull[nhull++] = j;
 			// Add new vertices.
 			if (swapped)
@@ -618,14 +618,14 @@
 			}
 		}
 	}
-	
 
+
 	// Tessellate the base mesh.
 	edges.resize(0);
 	tris.resize(0);
 
 	delaunayHull(ctx, nverts, verts, nhull, hull, tris, edges);
-	
+
 	if (tris.size() == 0)
 	{
 		// Could not triangulate the poly, make sure there is some valid data there.
@@ -672,7 +672,7 @@
 				samples.push(0); // Not added
 			}
 		}
-				
+
 		// Add the samples starting from the one that has the most
 		// error. The procedure stops when all samples are added
 		// or when the max error is within treshold.
@@ -713,13 +713,13 @@
 			// Add the new sample point.
 			rcVcopy(&verts[nverts*3],bestpt);
 			nverts++;
-			
+
 			// Create new triangulation.
 			// TODO: Incremental add instead of full rebuild.
 			edges.resize(0);
 			tris.resize(0);
 			delaunayHull(ctx, nverts, verts, nhull, hull, tris, edges);
-		}		
+		}
 	}
 
 	const int ntris = tris.size()/4;
@@ -734,21 +734,24 @@
 
 static void getHeightData(const rcCompactHeightfield& chf,
 						  const unsigned short* poly, const int npoly,
-						  const unsigned short* verts,
+						  const unsigned short* verts, const int bs,
 						  rcHeightPatch& hp, rcIntArray& stack)
 {
 	// Floodfill the heightfield to get 2D height data,
 	// starting at vertex locations as seeds.
-	
+
+	// Note: Reads to the compact heightfield are offset by border size (bs)
+	// since border size offset is already removed from the polymesh vertices.
+
 	memset(hp.data, 0, sizeof(unsigned short)*hp.width*hp.height);
-	
+
 	stack.resize(0);
-	
+
 	static const int offset[9*2] =
 	{
 		0,0, -1,-1, 0,-1, 1,-1, 1,0, 1,1, 0,1, -1,1, -1,0,
 	};
-	
+
 	// Use poly vertices as seed points for the flood fill.
 	for (int j = 0; j < npoly; ++j)
 	{
@@ -762,8 +765,8 @@
 			if (ax < hp.xmin || ax >= hp.xmin+hp.width ||
 				az < hp.ymin || az >= hp.ymin+hp.height)
 				continue;
-			
-			const rcCompactCell& c = chf.cells[ax+az*chf.width];
+
+			const rcCompactCell& c = chf.cells[(ax+bs)+(az+bs)*chf.width];
 			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)
 			{
 				const rcCompactSpan& s = chf.spans[i];
@@ -784,7 +787,7 @@
 			stack.push(ci);
 		}
 	}
-	
+
 	// Find center of the polygon using flood fill.
 	int pcx = 0, pcz = 0;
 	for (int j = 0; j < npoly; ++j)
@@ -794,7 +797,7 @@
 	}
 	pcx /= npoly;
 	pcz /= npoly;
-	
+
 	for (int i = 0; i < stack.size(); i += 3)
 	{
 		int cx = stack[i+0];
@@ -802,13 +805,13 @@
 		int idx = cx-hp.xmin+(cy-hp.ymin)*hp.width;
 		hp.data[idx] = 1;
 	}
-	
+
 	while (stack.size() > 0)
 	{
 		int ci = stack.pop();
 		int cy = stack.pop();
 		int cx = stack.pop();
-		
+
 		// Check if close to center of the polygon.
 		if (rcAbs(cx-pcx) <= 1 && rcAbs(cy-pcz) <= 1)
 		{
@@ -818,28 +821,28 @@
 			stack.push(ci);
 			break;
 		}
-		
+
 		const rcCompactSpan& cs = chf.spans[ci];
-		
+
 		for (int dir = 0; dir < 4; ++dir)
 		{
 			if (rcGetCon(cs, dir) == RC_NOT_CONNECTED) continue;
-			
+
 			const int ax = cx + rcGetDirOffsetX(dir);
 			const int ay = cy + rcGetDirOffsetY(dir);
-			
+
 			if (ax < hp.xmin || ax >= (hp.xmin+hp.width) ||
 				ay < hp.ymin || ay >= (hp.ymin+hp.height))
 				continue;
-			
+
 			if (hp.data[ax-hp.xmin+(ay-hp.ymin)*hp.width] != 0)
 				continue;
-			
-			const int ai = (int)chf.cells[ax+ay*chf.width].index + rcGetCon(cs, dir);
 
+			const int ai = (int)chf.cells[(ax+bs)+(ay+bs)*chf.width].index + rcGetCon(cs, dir);
+
 			int idx = ax-hp.xmin+(ay-hp.ymin)*hp.width;
 			hp.data[idx] = 1;
-			
+
 			stack.push(ax);
 			stack.push(ay);
 			stack.push(ai);
@@ -858,10 +861,10 @@
 		const rcCompactSpan& cs = chf.spans[ci];
 		hp.data[idx] = cs.y;
 	}
-	
+
 	static const int RETRACT_SIZE = 256;
 	int head = 0;
-	
+
 	while (head*3 < stack.size())
 	{
 		int cx = stack[head*3+0];
@@ -880,19 +883,19 @@
 		for (int dir = 0; dir < 4; ++dir)
 		{
 			if (rcGetCon(cs, dir) == RC_NOT_CONNECTED) continue;
-			
+
 			const int ax = cx + rcGetDirOffsetX(dir);
 			const int ay = cy + rcGetDirOffsetY(dir);
-			
+
 			if (ax < hp.xmin || ax >= (hp.xmin+hp.width) ||
 				ay < hp.ymin || ay >= (hp.ymin+hp.height))
 				continue;
-			
+
 			if (hp.data[ax-hp.xmin+(ay-hp.ymin)*hp.width] != RC_UNSET_HEIGHT)
 				continue;
-			
-			const int ai = (int)chf.cells[ax+ay*chf.width].index + rcGetCon(cs, dir);
-			
+
+			const int ai = (int)chf.cells[(ax+bs)+(ay+bs)*chf.width].index + rcGetCon(cs, dir);
+
 			const rcCompactSpan& as = chf.spans[ai];
 			int idx = ax-hp.xmin+(ay-hp.ymin)*hp.width;
 			hp.data[idx] = as.y;
@@ -902,7 +905,7 @@
 			stack.push(ai);
 		}
 	}
-	
+
 }
 
 static unsigned char getEdgeFlags(const float* va, const float* vb,
@@ -912,7 +915,7 @@
 	static const float thrSqr = rcSqr(0.001f);
 	for (int i = 0, j = npoly-1; i < npoly; j=i++)
 	{
-		if (distancePtSeg2d(va, &vpoly[j*3], &vpoly[i*3]) < thrSqr && 
+		if (distancePtSeg2d(va, &vpoly[j*3], &vpoly[i*3]) < thrSqr &&
 			distancePtSeg2d(vb, &vpoly[j*3], &vpoly[i*3]) < thrSqr)
 			return 1;
 	}
@@ -929,24 +932,28 @@
 	return flags;
 }
 
-
-
+/// @par
+///
+/// See the #rcConfig documentation for more information on the configuration parameters.
+///
+/// @see mallocPolyMeshDetail, rcPolyMesh, rcCompactHeightfield, rcPolyMeshDetail, rcConfig
 bool rcBuildPolyMeshDetail(rcContext* ctx, const rcPolyMesh& mesh, const rcCompactHeightfield& chf,
 						   const float sampleDist, const float sampleMaxError,
 						   rcPolyMeshDetail& dmesh)
 {
 	ASSERT(ctx);
-	
+
 	ctx->startTimer(RC_TIMER_BUILD_POLYMESHDETAIL);
 
 	if (mesh.nverts == 0 || mesh.npolys == 0)
 		return true;
-	
+
 	const int nvp = mesh.nvp;
 	const float cs = mesh.cs;
 	const float ch = mesh.ch;
 	const float* orig = mesh.bmin;
-	
+	const int borderSize = mesh.borderSize;
+
 	rcIntArray edges(64);
 	rcIntArray tris(512);
 	rcIntArray stack(512);
@@ -955,7 +962,7 @@
 	rcHeightPatch hp;
 	int nPolyVerts = 0;
 	int maxhw = 0, maxhh = 0;
-	
+
 	rcScopedDelete<int> bounds = (int*)malloc(sizeof(int)*mesh.npolys*4);
 	if (!bounds)
 	{
@@ -968,7 +975,7 @@
 		ctx->log(RC_LOG_ERROR, "rcBuildPolyMeshDetail: Out of memory 'poly' (%d).", nvp*3);
 		return false;
 	}
-	
+
 	// Find max size for a polygon area.
 	for (int i = 0; i < mesh.npolys; ++i)
 	{
@@ -999,14 +1006,14 @@
 		maxhw = rcMax(maxhw, xmax-xmin);
 		maxhh = rcMax(maxhh, ymax-ymin);
 	}
-	
+
 	hp.data = (unsigned short*)malloc(sizeof(unsigned short)*maxhw*maxhh);
 	if (!hp.data)
 	{
 		ctx->log(RC_LOG_ERROR, "rcBuildPolyMeshDetail: Out of memory 'hp.data' (%d).", maxhw*maxhh);
 		return false;
 	}
-	
+
 	dmesh.nmeshes = mesh.npolys;
 	dmesh.nverts = 0;
 	dmesh.ntris = 0;
@@ -1034,11 +1041,11 @@
 		ctx->log(RC_LOG_ERROR, "rcBuildPolyMeshDetail: Out of memory 'dmesh.tris' (%d).", tcap*4);
 		return false;
 	}
-	
+
 	for (int i = 0; i < mesh.npolys; ++i)
 	{
 		const unsigned short* p = &mesh.polys[i*nvp*2];
-		
+
 		// Store polygon vertices for processing.
 		int npoly = 0;
 		for (int j = 0; j < nvp; ++j)
@@ -1050,14 +1057,14 @@
 			poly[j*3+2] = v[2]*cs;
 			npoly++;
 		}
-		
+
 		// Get the height data from the area of the polygon.
 		hp.xmin = bounds[i*4+0];
 		hp.ymin = bounds[i*4+2];
 		hp.width = bounds[i*4+1]-bounds[i*4+0];
 		hp.height = bounds[i*4+3]-bounds[i*4+2];
-		getHeightData(chf, p, npoly, mesh.verts, hp, stack);
-		
+		getHeightData(chf, p, npoly, mesh.verts, borderSize, hp, stack);
+
 		// Build detail mesh.
 		int nverts = 0;
 		if (!buildPolyDetail(ctx, poly, npoly,
@@ -1082,21 +1089,21 @@
 			poly[j*3+1] += orig[1];
 			poly[j*3+2] += orig[2];
 		}
-	
+
 		// Store detail submesh.
 		const int ntris = tris.size()/4;
 
 		dmesh.meshes[i*4+0] = (unsigned int)dmesh.nverts;
 		dmesh.meshes[i*4+1] = (unsigned int)nverts;
 		dmesh.meshes[i*4+2] = (unsigned int)dmesh.ntris;
-		dmesh.meshes[i*4+3] = (unsigned int)ntris;		
-		
+		dmesh.meshes[i*4+3] = (unsigned int)ntris;
+
 		// Store vertices, allocate more memory if necessary.
 		if (dmesh.nverts+nverts > vcap)
 		{
 			while (dmesh.nverts+nverts > vcap)
 				vcap += 256;
-				
+
 			float* newv = (float*)malloc(sizeof(float)*vcap*3);
 			if (!newv)
 			{
@@ -1115,7 +1122,7 @@
 			dmesh.verts[dmesh.nverts*3+2] = verts[j*3+2];
 			dmesh.nverts++;
 		}
-		
+
 		// Store triangles, allocate more memory if necessary.
 		if (dmesh.ntris+ntris > tcap)
 		{
@@ -1142,16 +1149,17 @@
 			dmesh.ntris++;
 		}
 	}
-		
+
 	ctx->stopTimer(RC_TIMER_BUILD_POLYMESHDETAIL);
 
 	return true;
 }
 
+/// @see mallocPolyMeshDetail, rcPolyMeshDetail
 bool rcMergePolyMeshDetails(rcContext* ctx, rcPolyMeshDetail** meshes, const int nmeshes, rcPolyMeshDetail& mesh)
 {
 	ASSERT(ctx);
-	
+
 	ctx->startTimer(RC_TIMER_MERGE_POLYMESHDETAIL);
 
 	int maxVerts = 0;
@@ -1189,7 +1197,7 @@
 		ctx->log(RC_LOG_ERROR, "rcBuildPolyMeshDetail: Out of memory 'dmesh.verts' (%d).", maxVerts*3);
 		return false;
 	}
-	
+
 	// Merge datas.
 	for (int i = 0; i < nmeshes; ++i)
 	{
@@ -1205,7 +1213,7 @@
 			dst[3] = src[3];
 			mesh.nmeshes++;
 		}
-			
+
 		for (int k = 0; k < dm->nverts; ++k)
 		{
 			rcVcopy(&mesh.verts[mesh.nverts*3], &dm->verts[k*3]);
@@ -1222,7 +1230,7 @@
 	}
 
 	ctx->stopTimer(RC_TIMER_MERGE_POLYMESHDETAIL);
-	
+
 	return true;
 }
 
Index: src/hearthstone-shared/Pathfinding/Recast/RecastRasterization.cpp
===================================================================
--- src/hearthstone-shared/Pathfinding/Recast/RecastRasterization.cpp	(revision 1490)
+++ src/hearthstone-shared/Pathfinding/Recast/RecastRasterization.cpp	(working copy)
@@ -62,7 +62,7 @@
 		while (it != head);
 		hf.freelist = it;
 	}
-	
+
 	// Pop item from in front of the free list.
 	rcSpan* it = hf.freelist;
 	hf.freelist = hf.freelist->next;
@@ -81,15 +81,15 @@
 					const unsigned short smin, const unsigned short smax,
 					const unsigned char area, const int flagMergeThr)
 {
-	
+
 	int idx = x + y*hf.width;
-	
+
 	rcSpan* s = allocSpan(hf);
 	s->smin = smin;
 	s->smax = smax;
 	s->area = area;
 	s->next = 0;
-	
+
 	// Empty cell, add he first span.
 	if (!hf.spans[idx])
 	{
@@ -98,7 +98,7 @@
 	}
 	rcSpan* prev = 0;
 	rcSpan* cur = hf.spans[idx];
-	
+
 	// Insert and merge spans.
 	while (cur)
 	{
@@ -120,11 +120,11 @@
 				s->smin = cur->smin;
 			if (cur->smax > s->smax)
 				s->smax = cur->smax;
-			
+
 			// Merge flags.
 			if (rcAbs((int)s->smax - (int)cur->smax) <= flagMergeThr)
 				s->area = rcMax(s->area, cur->area);
-			
+
 			// Remove current span.
 			rcSpan* next = cur->next;
 			freeSpan(hf, cur);
@@ -135,7 +135,7 @@
 			cur = next;
 		}
 	}
-	
+
 	// Insert new span.
 	if (prev)
 	{
@@ -149,6 +149,13 @@
 	}
 }
 
+/// @par
+///
+/// The span addition can be set to favor flags. If the span is merged to
+/// another span and the new @p smax is within @p flagMergeThr units
+/// from the existing span, the span flags are merged.
+///
+/// @see rcHeightfield, rcSpan.
 void rcAddSpan(rcContext* /*ctx*/, rcHeightfield& hf, const int x, const int y,
 			   const unsigned short smin, const unsigned short smax,
 			   const unsigned char area, const int flagMergeThr)
@@ -162,7 +169,7 @@
 	float d[12];
 	for (int i = 0; i < n; ++i)
 		d[i] = pnx*in[i*3+0] + pnz*in[i*3+2] + pd;
-	
+
 	int m = 0;
 	for (int i = 0, j = n-1; i < n; j=i, ++i)
 	{
@@ -197,7 +204,7 @@
 	const int h = hf.height;
 	float tmin[3], tmax[3];
 	const float by = bmax[1] - bmin[1];
-	
+
 	// Calculate the bounding box of the triangle.
 	rcVcopy(tmin, v0);
 	rcVcopy(tmax, v0);
@@ -205,11 +212,11 @@
 	rcVmin(tmin, v2);
 	rcVmax(tmax, v1);
 	rcVmax(tmax, v2);
-	
+
 	// If the triangle does not touch the bbox of the heightfield, skip the triagle.
 	if (!overlapBounds(bmin, bmax, tmin, tmax))
 		return;
-	
+
 	// Calculate the footpring of the triangle on the grid.
 	int x0 = (int)((tmin[0] - bmin[0])*ics);
 	int y0 = (int)((tmin[2] - bmin[2])*ics);
@@ -219,10 +226,10 @@
 	y0 = rcClamp(y0, 0, h-1);
 	x1 = rcClamp(x1, 0, w-1);
 	y1 = rcClamp(y1, 0, h-1);
-	
+
 	// Clip the triangle into all grid cells it touches.
 	float in[7*3], out[7*3], inrow[7*3];
-	
+
 	for (int y = y0; y <= y1; ++y)
 	{
 		// Clip polygon to row.
@@ -235,7 +242,7 @@
 		if (nvrow < 3) continue;
 		nvrow = clipPoly(out, nvrow, inrow, 0, -1, cz+cs);
 		if (nvrow < 3) continue;
-		
+
 		for (int x = x0; x <= x1; ++x)
 		{
 			// Clip polygon to column.
@@ -245,7 +252,7 @@
 			if (nv < 3) continue;
 			nv = clipPoly(out, nv, in, -1, 0, cx+cs);
 			if (nv < 3) continue;
-			
+
 			// Calculate min and max of the span.
 			float smin = in[1], smax = in[1];
 			for (int i = 1; i < nv; ++i)
@@ -261,16 +268,21 @@
 			// Clamp the span to the heightfield bbox.
 			if (smin < 0.0f) smin = 0;
 			if (smax > by) smax = by;
-			
+
 			// Snap the span to the heightfield height grid.
 			unsigned short ismin = (unsigned short)rcClamp((int)floorf(smin * ich), 0, RC_SPAN_MAX_HEIGHT);
 			unsigned short ismax = (unsigned short)rcClamp((int)ceilf(smax * ich), (int)ismin+1, RC_SPAN_MAX_HEIGHT);
-			
+
 			addSpan(hf, x, y, ismin, ismax, area, flagMergeThr);
 		}
 	}
 }
 
+/// @par
+///
+/// No spans will be added if the triangle does not overlap the heightfield grid.
+///
+/// @see rcHeightfield
 void rcRasterizeTriangle(rcContext* ctx, const float* v0, const float* v1, const float* v2,
 						 const unsigned char area, rcHeightfield& solid,
 						 const int flagMergeThr)
@@ -286,6 +298,11 @@
 	ctx->stopTimer(RC_TIMER_RASTERIZE_TRIANGLES);
 }
 
+/// @par
+///
+/// Spans will only be added for triangles that overlap the heightfield grid.
+///
+/// @see rcHeightfield
 void rcRasterizeTriangles(rcContext* ctx, const float* verts, const int /*nv*/,
 						  const int* tris, const unsigned char* areas, const int nt,
 						  rcHeightfield& solid, const int flagMergeThr)
@@ -293,7 +310,7 @@
 	ASSERT(ctx);
 
 	ctx->startTimer(RC_TIMER_RASTERIZE_TRIANGLES);
-	
+
 	const float ics = 1.0f/solid.cs;
 	const float ich = 1.0f/solid.ch;
 	// Rasterize triangles.
@@ -305,10 +322,15 @@
 		// Rasterize.
 		rasterizeTri(v0, v1, v2, areas[i], solid, solid.bmin, solid.bmax, solid.cs, ics, ich, flagMergeThr);
 	}
-	
+
 	ctx->stopTimer(RC_TIMER_RASTERIZE_TRIANGLES);
 }
 
+/// @par
+///
+/// Spans will only be added for triangles that overlap the heightfield grid.
+///
+/// @see rcHeightfield
 void rcRasterizeTriangles(rcContext* ctx, const float* verts, const int /*nv*/,
 						  const unsigned short* tris, const unsigned char* areas, const int nt,
 						  rcHeightfield& solid, const int flagMergeThr)
@@ -316,7 +338,7 @@
 	ASSERT(ctx);
 
 	ctx->startTimer(RC_TIMER_RASTERIZE_TRIANGLES);
-	
+
 	const float ics = 1.0f/solid.cs;
 	const float ich = 1.0f/solid.ch;
 	// Rasterize triangles.
@@ -328,17 +350,22 @@
 		// Rasterize.
 		rasterizeTri(v0, v1, v2, areas[i], solid, solid.bmin, solid.bmax, solid.cs, ics, ich, flagMergeThr);
 	}
-	
+
 	ctx->stopTimer(RC_TIMER_RASTERIZE_TRIANGLES);
 }
 
+/// @par
+///
+/// Spans will only be added for triangles that overlap the heightfield grid.
+///
+/// @see rcHeightfield
 void rcRasterizeTriangles(rcContext* ctx, const float* verts, const unsigned char* areas, const int nt,
 						  rcHeightfield& solid, const int flagMergeThr)
 {
 	ASSERT(ctx);
-	
+
 	ctx->startTimer(RC_TIMER_RASTERIZE_TRIANGLES);
-	
+
 	const float ics = 1.0f/solid.cs;
 	const float ich = 1.0f/solid.ch;
 	// Rasterize triangles.
@@ -350,6 +377,6 @@
 		// Rasterize.
 		rasterizeTri(v0, v1, v2, areas[i], solid, solid.bmin, solid.bmax, solid.cs, ics, ich, flagMergeThr);
 	}
-	
+
 	ctx->stopTimer(RC_TIMER_RASTERIZE_TRIANGLES);
 }
Index: src/hearthstone-shared/Pathfinding/Recast/RecastRegion.cpp
===================================================================
--- src/hearthstone-shared/Pathfinding/Recast/RecastRegion.cpp	(revision 1490)
+++ src/hearthstone-shared/Pathfinding/Recast/RecastRegion.cpp	(working copy)
@@ -22,11 +22,11 @@
 {
 	const int w = chf.width;
 	const int h = chf.height;
-	
+
 	// Init distance and points.
 	for (int i = 0; i < chf.spanCount; ++i)
 		src[i] = 0xffff;
-	
+
 	// Mark boundary cells.
 	for (int y = 0; y < h; ++y)
 	{
@@ -37,7 +37,7 @@
 			{
 				const rcCompactSpan& s = chf.spans[i];
 				const unsigned char area = chf.areas[i];
-				
+
 				int nc = 0;
 				for (int dir = 0; dir < 4; ++dir)
 				{
@@ -55,8 +55,8 @@
 			}
 		}
 	}
-	
-			
+
+
 	// Pass 1
 	for (int y = 0; y < h; ++y)
 	{
@@ -66,7 +66,7 @@
 			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)
 			{
 				const rcCompactSpan& s = chf.spans[i];
-				
+
 				if (rcGetCon(s, 0) != RC_NOT_CONNECTED)
 				{
 					// (-1,0)
@@ -76,7 +76,7 @@
 					const rcCompactSpan& as = chf.spans[ai];
 					if (src[ai]+2 < src[i])
 						src[i] = src[ai]+2;
-					
+
 					// (-1,-1)
 					if (rcGetCon(as, 3) != RC_NOT_CONNECTED)
 					{
@@ -96,7 +96,7 @@
 					const rcCompactSpan& as = chf.spans[ai];
 					if (src[ai]+2 < src[i])
 						src[i] = src[ai]+2;
-					
+
 					// (1,-1)
 					if (rcGetCon(as, 2) != RC_NOT_CONNECTED)
 					{
@@ -110,7 +110,7 @@
 			}
 		}
 	}
-	
+
 	// Pass 2
 	for (int y = h-1; y >= 0; --y)
 	{
@@ -120,7 +120,7 @@
 			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)
 			{
 				const rcCompactSpan& s = chf.spans[i];
-				
+
 				if (rcGetCon(s, 2) != RC_NOT_CONNECTED)
 				{
 					// (1,0)
@@ -130,7 +130,7 @@
 					const rcCompactSpan& as = chf.spans[ai];
 					if (src[ai]+2 < src[i])
 						src[i] = src[ai]+2;
-					
+
 					// (1,1)
 					if (rcGetCon(as, 1) != RC_NOT_CONNECTED)
 					{
@@ -150,7 +150,7 @@
 					const rcCompactSpan& as = chf.spans[ai];
 					if (src[ai]+2 < src[i])
 						src[i] = src[ai]+2;
-					
+
 					// (-1,1)
 					if (rcGetCon(as, 0) != RC_NOT_CONNECTED)
 					{
@@ -163,12 +163,12 @@
 				}
 			}
 		}
-	}	
-	
+	}
+
 	maxDist = 0;
 	for (int i = 0; i < chf.spanCount; ++i)
 		maxDist = rcMax(src[i], maxDist);
-	
+
 }
 
 static unsigned short* boxBlur(rcCompactHeightfield& chf, int thr,
@@ -176,9 +176,9 @@
 {
 	const int w = chf.width;
 	const int h = chf.height;
-	
+
 	thr *= 2;
-	
+
 	for (int y = 0; y < h; ++y)
 	{
 		for (int x = 0; x < w; ++x)
@@ -203,7 +203,7 @@
 						const int ay = y + rcGetDirOffsetY(dir);
 						const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(s, dir);
 						d += (int)src[ai];
-						
+
 						const rcCompactSpan& as = chf.spans[ai];
 						const int dir2 = (dir+1) & 0x3;
 						if (rcGetCon(as, dir2) != RC_NOT_CONNECTED)
@@ -238,9 +238,9 @@
 						rcIntArray& stack)
 {
 	const int w = chf.width;
-	
+
 	const unsigned char area = chf.areas[i];
-	
+
 	// Flood fill mark region.
 	stack.resize(0);
 	stack.push((int)x);
@@ -248,18 +248,18 @@
 	stack.push((int)i);
 	srcReg[i] = r;
 	srcDist[i] = 0;
-	
+
 	unsigned short lev = level >= 2 ? level-2 : 0;
 	int count = 0;
-	
+
 	while (stack.size() > 0)
 	{
 		int ci = stack.pop();
 		int cy = stack.pop();
 		int cx = stack.pop();
-		
+
 		const rcCompactSpan& cs = chf.spans[ci];
-		
+
 		// Check if any of the neighbours already have a valid region set.
 		unsigned short ar = 0;
 		for (int dir = 0; dir < 4; ++dir)
@@ -273,11 +273,13 @@
 				if (chf.areas[ai] != area)
 					continue;
 				unsigned short nr = srcReg[ai];
+				if (nr & RC_BORDER_REG) // Do not take borders into account.
+					continue;
 				if (nr != 0 && nr != r)
 					ar = nr;
-				
+
 				const rcCompactSpan& as = chf.spans[ai];
-				
+
 				const int dir2 = (dir+1) & 0x3;
 				if (rcGetCon(as, dir2) != RC_NOT_CONNECTED)
 				{
@@ -289,7 +291,7 @@
 					unsigned short nr = srcReg[ai2];
 					if (nr != 0 && nr != r)
 						ar = nr;
-				}				
+				}
 			}
 		}
 		if (ar != 0)
@@ -298,7 +300,7 @@
 			continue;
 		}
 		count++;
-		
+
 		// Expand neighbours.
 		for (int dir = 0; dir < 4; ++dir)
 		{
@@ -309,28 +311,25 @@
 				const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(cs, dir);
 				if (chf.areas[ai] != area)
 					continue;
-				if (chf.dist[ai] >= lev)
+				if (chf.dist[ai] >= lev && srcReg[ai] == 0)
 				{
-					if (srcReg[ai] == 0)
-					{
-						srcReg[ai] = r;
-						srcDist[ai] = 0;
-						stack.push(ax);
-						stack.push(ay);
-						stack.push(ai);
-					}
+					srcReg[ai] = r;
+					srcDist[ai] = 0;
+					stack.push(ax);
+					stack.push(ay);
+					stack.push(ai);
 				}
 			}
 		}
 	}
-	
+
 	return count > 0;
 }
 
 static unsigned short* expandRegions(int maxIter, unsigned short level,
 									 rcCompactHeightfield& chf,
 									 unsigned short* srcReg, unsigned short* srcDist,
-									 unsigned short* dstReg, unsigned short* dstDist, 
+									 unsigned short* dstReg, unsigned short* dstDist,
 									 rcIntArray& stack)
 {
 	const int w = chf.width;
@@ -354,15 +353,15 @@
 			}
 		}
 	}
-	
+
 	int iter = 0;
 	while (stack.size() > 0)
 	{
 		int failed = 0;
-		
+
 		memcpy(dstReg, srcReg, sizeof(unsigned short)*chf.spanCount);
 		memcpy(dstDist, srcDist, sizeof(unsigned short)*chf.spanCount);
-		
+
 		for (int j = 0; j < stack.size(); j += 3)
 		{
 			int x = stack[j+0];
@@ -373,7 +372,7 @@
 				failed++;
 				continue;
 			}
-			
+
 			unsigned short r = srcReg[i];
 			unsigned short d2 = 0xffff;
 			const unsigned char area = chf.areas[i];
@@ -405,14 +404,14 @@
 				failed++;
 			}
 		}
-		
+
 		// rcSwap source and dest.
 		rcSwap(srcReg, dstReg);
 		rcSwap(srcDist, dstDist);
-		
+
 		if (failed*3 == stack.size())
 			break;
-		
+
 		if (level > 0)
 		{
 			++iter;
@@ -420,7 +419,7 @@
 				break;
 		}
 	}
-	
+
 	return srcReg;
 }
 
@@ -434,7 +433,7 @@
 		remap(false),
 		visited(false)
 	{}
-	
+
 	int spanCount;					// Number of spans belonging to this region
 	unsigned short id;				// ID of the region
 	unsigned char areaType;			// Are type.
@@ -514,14 +513,14 @@
 {
 	unsigned short aid = rega.id;
 	unsigned short bid = regb.id;
-	
+
 	// Duplicate current neighbourhood.
 	rcIntArray acon;
 	acon.resize(rega.connections.size());
 	for (int i = 0; i < rega.connections.size(); ++i)
 		acon[i] = rega.connections[i];
 	rcIntArray& bcon = regb.connections;
-	
+
 	// Find insertion point on A.
 	int insa = -1;
 	for (int i = 0; i < acon.size(); ++i)
@@ -534,7 +533,7 @@
 	}
 	if (insa == -1)
 		return false;
-	
+
 	// Find insertion point on B.
 	int insb = -1;
 	for (int i = 0; i < bcon.size(); ++i)
@@ -547,17 +546,17 @@
 	}
 	if (insb == -1)
 		return false;
-	
+
 	// Merge neighbours.
 	rega.connections.resize(0);
 	for (int i = 0, ni = acon.size(); i < ni-1; ++i)
 		rega.connections.push(acon[(insa+1+i) % ni]);
-		
+
 	for (int i = 0, ni = bcon.size(); i < ni-1; ++i)
 		rega.connections.push(bcon[(insb+1+i) % ni]);
-	
+
 	removeAdjacentNeighbours(rega);
-	
+
 	for (int j = 0; j < regb.floors.size(); ++j)
 		addUniqueFloorRegion(rega, regb.floors[j]);
 	rega.spanCount += regb.spanCount;
@@ -614,12 +613,12 @@
 		curReg = srcReg[ai];
 	}
 	cont.push(curReg);
-			
+
 	int iter = 0;
 	while (++iter < 40000)
 	{
 		const rcCompactSpan& s = chf.spans[i];
-		
+
 		if (isSolidEdge(chf, srcReg, x, y, i, dir))
 		{
 			// Choose the edge corner
@@ -636,7 +635,7 @@
 				curReg = r;
 				cont.push(curReg);
 			}
-			
+
 			dir = (dir+1) & 0x3;  // Rotate CW
 		}
 		else
@@ -659,7 +658,7 @@
 			i = ni;
 			dir = (dir+3) & 0x3;	// Rotate CCW
 		}
-		
+
 		if (starti == i && startDir == dir)
 		{
 			break;
@@ -691,7 +690,7 @@
 {
 	const int w = chf.width;
 	const int h = chf.height;
-	
+
 	const int nreg = maxRegionId+1;
 	rcRegion* regions = (rcRegion*)malloc(sizeof(rcRegion)*nreg);
 	if (!regions)
@@ -703,7 +702,7 @@
 	// Construct regions
 	for (int i = 0; i < nreg; ++i)
 		new(&regions[i]) rcRegion((unsigned short)i);
-	
+
 	// Find edge of a region and find connections around the contour.
 	for (int y = 0; y < h; ++y)
 	{
@@ -715,11 +714,11 @@
 				unsigned short r = srcReg[i];
 				if (r == 0 || r >= nreg)
 					continue;
-				
+
 				rcRegion& reg = regions[r];
 				reg.spanCount++;
-				
-				
+
+
 				// Update floors.
 				for (int j = (int)c.index; j < ni; ++j)
 				{
@@ -729,13 +728,13 @@
 						continue;
 					addUniqueFloorRegion(reg, floorId);
 				}
-				
+
 				// Have found contour
 				if (reg.connections.size() > 0)
 					continue;
-				
+
 				reg.areaType = chf.areas[i];
-				
+
 				// Check if this cell is next to a border.
 				int ndir = -1;
 				for (int dir = 0; dir < 4; ++dir)
@@ -746,7 +745,7 @@
 						break;
 					}
 				}
-				
+
 				if (ndir != -1)
 				{
 					// The cell is at border.
@@ -764,12 +763,12 @@
 	{
 		rcRegion& reg = regions[i];
 		if (reg.id == 0 || (reg.id & RC_BORDER_REG))
-			continue;                       
+			continue;
 		if (reg.spanCount == 0)
 			continue;
 		if (reg.visited)
 			continue;
-		
+
 		// Count the total size of all the connected regions.
 		// Also keep track of the regions connects to a tile border.
 		bool connectsToBorder = false;
@@ -779,12 +778,12 @@
 
 		reg.visited = true;
 		stack.push(i);
-		
+
 		while (stack.size())
 		{
 			// Pop
 			int ri = stack.pop();
-			
+
 			rcRegion& creg = regions[ri];
 
 			spanCount += creg.spanCount;
@@ -807,7 +806,7 @@
 				nreg.visited = true;
 			}
 		}
-		
+
 		// If the accumulated regions size is too small, remove it.
 		// Do not remove areas which connect to tile borders
 		// as their size cannot be estimated correctly and removing them
@@ -822,7 +821,7 @@
 			}
 		}
 	}
-		
+
 	// Merge too small regions to neighbour regions.
 	int mergeCount = 0 ;
 	do
@@ -832,14 +831,14 @@
 		{
 			rcRegion& reg = regions[i];
 			if (reg.id == 0 || (reg.id & RC_BORDER_REG))
-				continue;                       
+				continue;
 			if (reg.spanCount == 0)
 				continue;
-			
+
 			// Check to see if the region should be merged.
 			if (reg.spanCount > mergeRegionSize && isRegionConnectedToBorder(reg))
 				continue;
-			
+
 			// Small region with more than 1 connection.
 			// Or region which is not connected to a border at all.
 			// Find smallest neighbour region that connects to this one.
@@ -863,7 +862,7 @@
 			{
 				unsigned short oldId = reg.id;
 				rcRegion& target = regions[mergeId];
-				
+
 				// Merge neighbours.
 				if (mergeRegions(target, reg))
 				{
@@ -885,7 +884,7 @@
 		}
 	}
 	while (mergeCount > 0);
-	
+
 	// Compress region Ids.
 	for (int i = 0; i < nreg; ++i)
 	{
@@ -894,7 +893,7 @@
 		if (regions[i].id & RC_BORDER_REG) continue;    // Skip external regions.
 		regions[i].remap = true;
 	}
-	
+
 	unsigned short regIdGen = 0;
 	for (int i = 0; i < nreg; ++i)
 	{
@@ -912,34 +911,43 @@
 		}
 	}
 	maxRegionId = regIdGen;
-	
+
 	// Remap regions.
 	for (int i = 0; i < chf.spanCount; ++i)
 	{
 		if ((srcReg[i] & RC_BORDER_REG) == 0)
 			srcReg[i] = regions[srcReg[i]].id;
 	}
-	
+
 	for (int i = 0; i < nreg; ++i)
 		regions[i].~rcRegion();
 	free(regions);
-	
+
 	return true;
 }
 
-
+/// @par
+///
+/// This is usually the second to the last step in creating a fully built
+/// compact heightfield.  This step is required before regions are built
+/// using #rcBuildRegions or #rcBuildRegionsMonotone.
+///
+/// After this step, the distance data is available via the rcCompactHeightfield::maxDistance
+/// and rcCompactHeightfield::dist fields.
+///
+/// @see rcCompactHeightfield, rcBuildRegions, rcBuildRegionsMonotone
 bool rcBuildDistanceField(rcContext* ctx, rcCompactHeightfield& chf)
 {
 	ASSERT(ctx);
-	
+
 	ctx->startTimer(RC_TIMER_BUILD_DISTANCEFIELD);
-	
+
 	if (chf.dist)
 	{
 		free(chf.dist);
 		chf.dist = 0;
 	}
-	
+
 	unsigned short* src = (unsigned short*)malloc(sizeof(unsigned short)*chf.spanCount);
 	if (!src)
 	{
@@ -953,38 +961,38 @@
 		free(src);
 		return false;
 	}
-	
+
 	unsigned short maxDist = 0;
 
 	ctx->startTimer(RC_TIMER_BUILD_DISTANCEFIELD_DIST);
-	
+
 	calculateDistanceField(chf, src, maxDist);
 	chf.maxDistance = maxDist;
-	
+
 	ctx->stopTimer(RC_TIMER_BUILD_DISTANCEFIELD_DIST);
-	
+
 	ctx->startTimer(RC_TIMER_BUILD_DISTANCEFIELD_BLUR);
-	
+
 	// Blur
 	if (boxBlur(chf, 1, src, dst) != src)
 		rcSwap(src, dst);
-	
+
 	// Store distance.
 	chf.dist = src;
-	
+
 	ctx->stopTimer(RC_TIMER_BUILD_DISTANCEFIELD_BLUR);
 
 	ctx->stopTimer(RC_TIMER_BUILD_DISTANCEFIELD);
-	
+
 	free(dst);
-	
+
 	return true;
 }
 
 static void paintRectRegion(int minx, int maxx, int miny, int maxy, unsigned short regId,
 							rcCompactHeightfield& chf, unsigned short* srcReg)
 {
-	const int w = chf.width;	
+	const int w = chf.width;
 	for (int y = miny; y < maxy; ++y)
 	{
 		for (int x = minx; x < maxx; ++x)
@@ -1010,13 +1018,32 @@
 	unsigned short nei;	// neighbour id
 };
 
+/// @par
+///
+/// Non-null regions will consist of connected, non-overlapping walkable spans that form a single contour.
+/// Contours will form simple polygons.
+///
+/// If multiple regions form an area that is smaller than @p minRegionArea, then all spans will be
+/// re-assigned to the zero (null) region.
+///
+/// Partitioning can result in smaller than necessary regions. @p mergeRegionArea helps
+/// reduce unecessarily small regions.
+///
+/// See the #rcConfig documentation for more information on the configuration parameters.
+///
+/// The region data will be available via the rcCompactHeightfield::maxRegions
+/// and rcCompactSpan::reg fields.
+///
+/// @warning The distance field must be created using #rcBuildDistanceField before attempting to build regions.
+///
+/// @see rcCompactHeightfield, rcCompactSpan, rcBuildDistanceField, rcBuildRegionsMonotone, rcConfig
 bool rcBuildRegionsMonotone(rcContext* ctx, rcCompactHeightfield& chf,
 							const int borderSize, const int minRegionArea, const int mergeRegionArea)
 {
 	ASSERT(ctx);
-	
+
 	ctx->startTimer(RC_TIMER_BUILD_REGIONS);
-	
+
 	const int w = chf.width;
 	const int h = chf.height;
 	unsigned short id = 1;
@@ -1036,8 +1063,8 @@
 		ctx->log(RC_LOG_ERROR, "rcBuildRegionsMonotone: Out of memory 'sweeps' (%d).", nsweeps);
 		return false;
 	}
-	
-	
+
+
 	// Mark border regions.
 	if (borderSize > 0)
 	{
@@ -1049,8 +1076,10 @@
 		paintRectRegion(w-bw, w, 0, h, id|RC_BORDER_REG, chf, srcReg); id++;
 		paintRectRegion(0, w, 0, bh, id|RC_BORDER_REG, chf, srcReg); id++;
 		paintRectRegion(0, w, h-bh, h, id|RC_BORDER_REG, chf, srcReg); id++;
+
+		chf.borderSize = borderSize;
 	}
-	
+
 	rcIntArray prev(256);
 
 	// Sweep one line at a time.
@@ -1060,16 +1089,16 @@
 		prev.resize(id+1);
 		memset(&prev[0],0,sizeof(int)*id);
 		unsigned short rid = 1;
-		
+
 		for (int x = borderSize; x < w-borderSize; ++x)
 		{
 			const rcCompactCell& c = chf.cells[x+y*w];
-			
+
 			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)
 			{
 				const rcCompactSpan& s = chf.spans[i];
 				if (chf.areas[i] == RC_NULL_AREA) continue;
-				
+
 				// -x
 				unsigned short previd = 0;
 				if (rcGetCon(s, 0) != RC_NOT_CONNECTED)
@@ -1080,7 +1109,7 @@
 					if ((srcReg[ai] & RC_BORDER_REG) == 0 && chf.areas[i] == chf.areas[ai])
 						previd = srcReg[ai];
 				}
-				
+
 				if (!previd)
 				{
 					previd = rid++;
@@ -1114,7 +1143,7 @@
 				srcReg[i] = previd;
 			}
 		}
-		
+
 		// Create unique ID.
 		for (int i = 1; i < rid; ++i)
 		{
@@ -1128,12 +1157,12 @@
 				sweeps[i].id = id++;
 			}
 		}
-		
+
 		// Remap IDs
 		for (int x = borderSize; x < w-borderSize; ++x)
 		{
 			const rcCompactCell& c = chf.cells[x+y*w];
-			
+
 			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)
 			{
 				if (srcReg[i] > 0 && srcReg[i] < rid)
@@ -1150,78 +1179,105 @@
 		return false;
 
 	ctx->stopTimer(RC_TIMER_BUILD_REGIONS_FILTER);
-	
+
 	// Store the result out.
 	for (int i = 0; i < chf.spanCount; ++i)
 		chf.spans[i].reg = srcReg[i];
-	
+
 	ctx->stopTimer(RC_TIMER_BUILD_REGIONS);
 
 	return true;
 }
 
+/// @par
+///
+/// Non-null regions will consist of connected, non-overlapping walkable spans that form a single contour.
+/// Contours will form simple polygons.
+///
+/// If multiple regions form an area that is smaller than @p minRegionArea, then all spans will be
+/// re-assigned to the zero (null) region.
+///
+/// Watershed partitioning can result in smaller than necessary regions, especially in diagonal corridors.
+/// @p mergeRegionArea helps reduce unecessarily small regions.
+///
+/// See the #rcConfig documentation for more information on the configuration parameters.
+///
+/// The region data will be available via the rcCompactHeightfield::maxRegions
+/// and rcCompactSpan::reg fields.
+///
+/// @warning The distance field must be created using #rcBuildDistanceField before attempting to build regions.
+///
+/// @see rcCompactHeightfield, rcCompactSpan, rcBuildDistanceField, rcBuildRegionsMonotone, rcConfig
 bool rcBuildRegions(rcContext* ctx, rcCompactHeightfield& chf,
 					const int borderSize, const int minRegionArea, const int mergeRegionArea)
 {
 	ASSERT(ctx);
-	
+
 	ctx->startTimer(RC_TIMER_BUILD_REGIONS);
-	
+
 	const int w = chf.width;
 	const int h = chf.height;
-	
+
 	rcScopedDelete<unsigned short> buf = (unsigned short*)malloc(sizeof(unsigned short)*chf.spanCount*4);
 	if (!buf)
 	{
 		ctx->log(RC_LOG_ERROR, "rcBuildRegions: Out of memory 'tmp' (%d).", chf.spanCount*4);
 		return false;
 	}
-	
+
 	ctx->startTimer(RC_TIMER_BUILD_REGIONS_WATERSHED);
-	
+
 	rcIntArray stack(1024);
 	rcIntArray visited(1024);
-	
+
 	unsigned short* srcReg = buf;
 	unsigned short* srcDist = buf+chf.spanCount;
 	unsigned short* dstReg = buf+chf.spanCount*2;
 	unsigned short* dstDist = buf+chf.spanCount*3;
-	
+
 	memset(srcReg, 0, sizeof(unsigned short)*chf.spanCount);
 	memset(srcDist, 0, sizeof(unsigned short)*chf.spanCount);
-	
+
 	unsigned short regionId = 1;
 	unsigned short level = (chf.maxDistance+1) & ~1;
 
-	// TODO: Figure better formula, expandIters defines how much the 
+	// TODO: Figure better formula, expandIters defines how much the
 	// watershed "overflows" and simplifies the regions. Tying it to
 	// agent radius was usually good indication how greedy it could be.
 //	const int expandIters = 4 + walkableRadius * 2;
 	const int expandIters = 8;
 
-	// Mark border regions.
-	paintRectRegion(0, borderSize, 0, h, regionId|RC_BORDER_REG, chf, srcReg); regionId++;
-	paintRectRegion(w-borderSize, w, 0, h, regionId|RC_BORDER_REG, chf, srcReg); regionId++;
-	paintRectRegion(0, w, 0, borderSize, regionId|RC_BORDER_REG, chf, srcReg); regionId++;
-	paintRectRegion(0, w, h-borderSize, h, regionId|RC_BORDER_REG, chf, srcReg); regionId++;
-	
+	if (borderSize > 0)
+	{
+		// Make sure border will not overflow.
+		const int bw = rcMin(w, borderSize);
+		const int bh = rcMin(h, borderSize);
+		// Paint regions
+		paintRectRegion(0, bw, 0, h, regionId|RC_BORDER_REG, chf, srcReg); regionId++;
+		paintRectRegion(w-bw, w, 0, h, regionId|RC_BORDER_REG, chf, srcReg); regionId++;
+		paintRectRegion(0, w, 0, bh, regionId|RC_BORDER_REG, chf, srcReg); regionId++;
+		paintRectRegion(0, w, h-bh, h, regionId|RC_BORDER_REG, chf, srcReg); regionId++;
+
+		chf.borderSize = borderSize;
+	}
+
 	while (level > 0)
 	{
 		level = level >= 2 ? level-2 : 0;
-		
+
 		ctx->startTimer(RC_TIMER_BUILD_REGIONS_EXPAND);
-		
+
 		// Expand current regions until no empty connected cells found.
 		if (expandRegions(expandIters, level, chf, srcReg, srcDist, dstReg, dstDist, stack) != srcReg)
 		{
 			rcSwap(srcReg, dstReg);
 			rcSwap(srcDist, dstDist);
 		}
-		
+
 		ctx->stopTimer(RC_TIMER_BUILD_REGIONS_EXPAND);
-		
+
 		ctx->startTimer(RC_TIMER_BUILD_REGIONS_FLOOD);
-		
+
 		// Mark new regions with IDs.
 		for (int y = 0; y < h; ++y)
 		{
@@ -1232,41 +1288,39 @@
 				{
 					if (chf.dist[i] < level || srcReg[i] != 0 || chf.areas[i] == RC_NULL_AREA)
 						continue;
-					
 					if (floodRegion(x, y, i, level, regionId, chf, srcReg, srcDist, stack))
 						regionId++;
 				}
 			}
 		}
-		
+
 		ctx->stopTimer(RC_TIMER_BUILD_REGIONS_FLOOD);
-		
 	}
-	
+
 	// Expand current regions until no empty connected cells found.
 	if (expandRegions(expandIters*8, 0, chf, srcReg, srcDist, dstReg, dstDist, stack) != srcReg)
 	{
 		rcSwap(srcReg, dstReg);
 		rcSwap(srcDist, dstDist);
 	}
-	
+
 	ctx->stopTimer(RC_TIMER_BUILD_REGIONS_WATERSHED);
-	
+
 	ctx->startTimer(RC_TIMER_BUILD_REGIONS_FILTER);
-	
+
 	// Filter out small regions.
 	chf.maxRegions = regionId;
 	if (!filterSmallRegions(ctx, minRegionArea, mergeRegionArea, chf.maxRegions, chf, srcReg))
 		return false;
-	
+
 	ctx->stopTimer(RC_TIMER_BUILD_REGIONS_FILTER);
-		
+
 	// Write the result out.
 	for (int i = 0; i < chf.spanCount; ++i)
 		chf.spans[i].reg = srcReg[i];
-	
+
 	ctx->stopTimer(RC_TIMER_BUILD_REGIONS);
-	
+
 	return true;
 }
 
Index: src/hearthstone-world/AIInterface.cpp
===================================================================
--- src/hearthstone-world/AIInterface.cpp	(revision 1490)
+++ src/hearthstone-world/AIInterface.cpp	(working copy)
@@ -1937,9 +1937,7 @@
 
 	if(pathfinding)
 	{
-		LocationVector PathLocation = NavMeshInterface.getBestPositionOnPathToLocation(m_Unit->GetMapId(),
-			m_sourceX, m_sourceY, m_sourceZ, m_destinationX, m_destinationY, m_destinationZ);
-
+		LocationVector PathLocation = NavMeshInterface.BuildPath(m_Unit->GetMapId(), m_sourceX, m_sourceY, m_sourceZ, m_destinationX, m_destinationY, m_destinationZ);
 		m_nextPosX = PathLocation.x;
 		m_nextPosY = PathLocation.y;
 		m_nextPosZ = PathLocation.z;
Index: src/hearthstone-world/CharacterHandler.cpp
===================================================================
--- src/hearthstone-world/CharacterHandler.cpp	(revision 1490)
+++ src/hearthstone-world/CharacterHandler.cpp	(working copy)
@@ -918,21 +918,23 @@
 	// Login time, will be used for played time calc
 	plr->m_playedtime[2] = (uint32)UNIXTIME;
 
+	// Send revision
+//	plr->BroadcastMessage("%sServer:|r%s Sandshroud Hearthstone|r %s r%u-%s-%s", MSG_COLOR_GOLD,
+//		MSG_COLOR_ORANGEY, MSG_COLOR_TORQUISEBLUE, BUILD_REVISION, ARCH, CONFIG);
+//	plr->BroadcastMessage("%sPlease report all bugs to |r%shttp://mantis.sandshroud.org|r", MSG_COLOR_GOLD, MSG_COLOR_TORQUISEBLUE);
+//	plr->BroadcastMessage("%sOnline Players:|r%s %u |r%sPeak:|r%s %u |r%sAccepted Connections:|r%s %u |r", MSG_COLOR_GOLD,
+//		MSG_COLOR_TORQUISEBLUE, sWorld.GetSessionCount(), MSG_COLOR_GOLD, MSG_COLOR_TORQUISEBLUE,
+//		sWorld.PeakSessionCount, MSG_COLOR_GOLD, MSG_COLOR_TORQUISEBLUE, sWorld.mAcceptedConnections);
+
+//	plr->BroadcastMessage("%sServer Uptime:|r%s %s|r", MSG_COLOR_GOLD, MSG_COLOR_TORQUISEBLUE, sWorld.GetUptimeString().c_str());
+
 	//Issue a message telling all guild members that this player has signed on
 	if(plr->IsInGuild())
 	{
 		Guild *pGuild = plr->m_playerInfo->guild;
 		if(pGuild)
 		{
-			WorldPacket data(SMSG_GUILD_EVENT, 50);
-			data << uint8(GUILD_EVENT_MOTD);
-			data << uint8(0x01);
-			if(pGuild->GetMOTD())
-				data << pGuild->GetMOTD();
-			else
-				data << uint8(0);
-			SendPacket(&data);
-
+			pGuild->LogGuildEventToPlr(plr, GUILD_EVENT_MOTD, 1, pGuild->GetMOTD());
 			pGuild->LogGuildEvent(GUILD_EVENT_HASCOMEONLINE, 1, plr->GetName());
 		}
 	}
@@ -944,16 +946,6 @@
 	// send friend list (for ignores)
 	plr->Social_SendFriendList(7);
 
-	// Send revision
-	plr->BroadcastMessage("%sServer:|r%s Sandshroud Hearthstone|r %s r%u-%s-%s", MSG_COLOR_GOLD,
-		MSG_COLOR_ORANGEY, MSG_COLOR_TORQUISEBLUE, BUILD_REVISION, ARCH, CONFIG);
-	plr->BroadcastMessage("%sPlease report all bugs to |r%shttp://mantis.sandshroud.org|r", MSG_COLOR_GOLD, MSG_COLOR_TORQUISEBLUE);
-	plr->BroadcastMessage("%sOnline Players:|r%s %u |r%sPeak:|r%s %u |r%sAccepted Connections:|r%s %u |r", MSG_COLOR_GOLD,
-		MSG_COLOR_TORQUISEBLUE, sWorld.GetSessionCount(), MSG_COLOR_GOLD, MSG_COLOR_TORQUISEBLUE,
-		sWorld.PeakSessionCount, MSG_COLOR_GOLD, MSG_COLOR_TORQUISEBLUE, sWorld.mAcceptedConnections);
-
-	plr->BroadcastMessage("%sServer Uptime:|r%s %s|r", MSG_COLOR_GOLD, MSG_COLOR_TORQUISEBLUE, sWorld.GetUptimeString().c_str());
-
 	// send to gms
 	if(HasGMPermissions())
 		sWorld.SendMessageToGMs(this, "%s%s %s (%s) is now online.|r", MSG_COLOR_GOLD, CanUseCommand('z') ? "Admin" : "GameMaster", plr->GetName(), GetAccountNameS(), GetPermissions());
Index: src/hearthstone-world/CollideInterface.cpp
===================================================================
--- src/hearthstone-world/CollideInterface.cpp	(revision 1490)
+++ src/hearthstone-world/CollideInterface.cpp	(working copy)
@@ -74,24 +74,32 @@
 	m_mapCreateLock.Release();
 }
 
-void CCollideInterface::ActivateTile(uint32 mapId, uint32 tileX, uint32 tileY)
+bool CCollideInterface::ActivateTile(uint32 mapId, uint32 tileX, uint32 tileY)
 {
 	ASSERT(m_mapLocks[mapId] != NULL);
 	if( !CollisionMgr )
-		return;
+		return false;
+
 	// acquire write lock
 	m_mapLocks[mapId]->m_lock.AcquireWriteLock();
 	if( m_mapLocks[mapId]->m_tileLoadCount[tileX][tileY] == 0 )
+	{
 		if(CollisionMgr->loadMap(sWorld.vMapPath.c_str(), mapId, tileX, tileY))
 			OUT_DEBUG("Loading VMap [%u/%u] successful", tileX, tileY);
 		else
+		{
 			OUT_DEBUG("Loading VMap [%u/%u] unsuccessful", tileX, tileY);
+			m_mapLocks[mapId]->m_lock.ReleaseWriteLock();
+			return false;
+		}
+	}
 
 	// increment count
 	m_mapLocks[mapId]->m_tileLoadCount[tileX][tileY]++;
 
 	// release lock
 	m_mapLocks[mapId]->m_lock.ReleaseWriteLock();
+	return true;
 }
 
 void CCollideInterface::DeactivateTile(uint32 mapId, uint32 tileX, uint32 tileY)
Index: src/hearthstone-world/CollideInterface.h
===================================================================
--- src/hearthstone-world/CollideInterface.h	(revision 1490)
+++ src/hearthstone-world/CollideInterface.h	(working copy)
@@ -32,7 +32,7 @@
 	void Init();
 	void DeInit();
 
-	void ActivateTile(uint32 mapId, uint32 tileX, uint32 tileY);
+	bool ActivateTile(uint32 mapId, uint32 tileX, uint32 tileY);
 	void DeactivateTile(uint32 mapId, uint32 tileX, uint32 tileY);
 	bool IsActiveTile(uint32 mapId, uint32 tileX, uint32 tileY);
 	void ActivateMap(uint32 mapId);
Index: src/hearthstone-world/Guild.cpp
===================================================================
--- src/hearthstone-world/Guild.cpp	(revision 1490)
+++ src/hearthstone-world/Guild.cpp	(working copy)
@@ -150,20 +150,43 @@
 	ASSERT(iStringCount <= 4);
 
 	WorldPacket data(SMSG_GUILD_EVENT, 100);
-	uint32 i;
 	data << iEvent;
 	data << iStringCount;
 
-	for(i = 0; i < iStringCount; i++)
+	for(uint32 i = 0; i < iStringCount; i++)
 	{
 		strs[i] = va_arg(ap, char*);
 		data << strs[i];
 	}
 
 	va_end(ap);
-	SendPacket(&data);
 }
 
+void Guild::LogGuildEventToPlr(Player* plr, uint8 iEvent, uint8 iStringCount, ...)
+{
+	if(!m_commandLogging || plr == NULL)
+		return;
+
+	va_list ap;
+	char * strs[4] = {NULL,NULL,NULL,NULL};
+
+	va_start(ap, iStringCount);
+	ASSERT(iStringCount <= 4);
+
+	WorldPacket data(SMSG_GUILD_EVENT, 100);
+	data << iEvent;
+	data << iStringCount;
+
+	for(uint32 i = 0; i < iStringCount; i++)
+	{
+		strs[i] = va_arg(ap, char*);
+		data << strs[i];
+	}
+
+	va_end(ap);
+	plr->GetSession()->SendPacket(&data);
+}
+
 void Guild::AddGuildLogEntry(uint8 iEvent, uint8 iParamCount, ...)
 {
 	if(!m_commandLogging)
@@ -759,10 +782,10 @@
 	else
 		r = (ForcedRank<0) ? FindLowestRank() : m_ranks[ForcedRank];
 
-	if(r== NULL)
-		r=FindLowestRank();
+	if(r == NULL)
+		r = FindLowestRank();
 
-	if(r== NULL)
+	if(r == NULL)
 	{
 		// shouldn't happen
 		m_lock.Release();
@@ -776,14 +799,15 @@
 	pm->szOfficerNote = pm->szPublicNote = NULL;
 	m_members.insert(make_pair(pMember, pm));
 
-	pMember->guild=this;
-	pMember->guildRank=r;
-	pMember->guildMember=pm;
+	pMember->guild = this;
+	pMember->guildRank = r;
+	pMember->guildMember = pm;
 
 	if(pMember->m_loggedInPlayer)
 	{
 		pMember->m_loggedInPlayer->SetGuildId(m_guildId);
 		pMember->m_loggedInPlayer->SetGuildRank(r->iId);
+		LogGuildEventToPlr(pMember->m_loggedInPlayer, GUILD_EVENT_MOTD, 1, GetMOTD());
 	}
 
 	CharacterDatabase.Execute("REPLACE INTO guild_data VALUES(%u, %u, %u, '', '', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)", m_guildId, pMember->guid, r->iId);
Index: src/hearthstone-world/Guild.h
===================================================================
--- src/hearthstone-world/Guild.h	(revision 1490)
+++ src/hearthstone-world/Guild.h	(working copy)
@@ -360,6 +360,10 @@
 	 */
 	void LogGuildEvent(uint8 iEvent, uint8 iStringCount, ...);
 
+	/** Logs a guild event and sends it to all online players.
+	 */
+	void LogGuildEventToPlr(Player* plr, uint8 iEvent, uint8 iStringCount, ...);
+
 	/** Guild event logging.
 	 */
 	void AddGuildLogEntry(uint8 iEvent, uint8 iParamCount, ...);
Index: src/hearthstone-world/GuildHandler.cpp
===================================================================
--- src/hearthstone-world/GuildHandler.cpp	(revision 1490)
+++ src/hearthstone-world/GuildHandler.cpp	(working copy)
@@ -109,9 +109,7 @@
 	plyr->UnSetGuildInvitersGuid();
 
 	if(!inviter)
-	{
 		return;
-	}
 
 	Guild *pGuild = inviter->m_playerInfo->guild;
 	if(!pGuild)
Index: src/hearthstone-world/Level3.cpp
===================================================================
--- src/hearthstone-world/Level3.cpp	(revision 1490)
+++ src/hearthstone-world/Level3.cpp	(working copy)
@@ -1877,8 +1877,8 @@
  	BlueSystemMessage(m_session, "%s uses %s (build %u)", (plr->getGender()?"She":"He"),
 		client, sess->GetClientBuild());
 
-	BlueSystemMessage(m_session, "%s IP is '%s', and has a latency of %ums", (plr->getGender()?"Her":"His"),
-		sess->GetSocket()->GetIP(), sess->GetLatency());
+	BlueSystemMessage(m_session, "%s IP is '%s:%u', and has a latency of %ums", (plr->getGender()?"Her":"His"),
+		sess->GetSocket()->GetIP(), sess->GetSocket()->GetPort(), sess->GetLatency());
 
 	return true;
 }
@@ -2809,22 +2809,20 @@
 
 bool ChatHandler::HandleRenameGuildCommand(const char* args, WorldSession *m_session)
 {
-	Player* ptarget = getSelectedChar(m_session);
-
-	if(!*args || !ptarget)
+	Player* plr = getSelectedChar(m_session);
+	if(!plr || !plr->GetGuildId() || !plr->GetGuild() || !args || !strlen(args))
 		return false;
 
-	char* newname = (char*)args;
-
-	Guild* guild = ptarget->GetGuild();
-	if(guild == NULL)
+	Guild* pGuild = objmgr.GetGuildByGuildName(string(args));
+	if(pGuild)
 	{
-		RedSystemMessage(m_session, "Target is not in a guild.");
-		return true;
+		RedSystemMessage(m_session, "Guild name %s is already taken.", args);
+		return false;
 	}
 
-	guild->ChangeGuildName(newname);
-	BlueSystemMessage(ptarget->GetSession(), "The Name of your Guild has been changed to %s, please relog.", newname);
+	GreenSystemMessage(m_session, "Changed guild name of %s to %s. This will take effect next restart.", plr->GetGuild()->GetGuildName(), args);
+	CharacterDatabase.Execute("UPDATE guilds SET `guildName` = \'%s\' WHERE `guildId` = '%u'", CharacterDatabase.EscapeString(string(args)).c_str(), plr->GetGuild()->GetGuildId());
+	sWorld.LogGM(m_session, "Changed guild name of '%s' to '%s'", plr->GetGuild()->GetGuildName(), args);
 	return true;
 }
 
@@ -2832,7 +2830,7 @@
 bool ChatHandler::HandleGuildRemovePlayerCommand(const char* args, WorldSession *m_session)
 {
 	Player* plr = getSelectedChar(m_session);
-	if(!plr || (plr && plr->GetGuild() == NULL))
+	if(plr == NULL || plr->GetGuild() == NULL)
 		return false;
 
 	plr->GetGuild()->RemoveGuildMember(plr->m_playerInfo,m_session);
@@ -2844,7 +2842,7 @@
 bool ChatHandler::HandleGuildDisbandCommand(const char* args, WorldSession *m_session)
 {
 	Player* plr = getSelectedChar(m_session);
-	if(!plr || (plr && (plr->GetGuild() == NULL)))
+	if(plr == NULL || plr->GetGuild() == NULL)
 		return false;
 
 	plr->GetGuild()->Disband();
@@ -2856,7 +2854,7 @@
 bool ChatHandler::HandleGuildMembersCommand(const char* args, WorldSession *m_session)
 {
 	Player* plr = getSelectedChar(m_session);
-	if(!plr || (plr && (plr->GetGuild() == NULL)))
+	if(plr == NULL || plr->GetGuild() == NULL)
 		return false;
 
 	plr->GetGuild()->ListGuildMembers(m_session);
Index: src/hearthstone-world/Map.cpp
===================================================================
--- src/hearthstone-world/Map.cpp	(revision 1490)
+++ src/hearthstone-world/Map.cpp	(working copy)
@@ -51,9 +51,6 @@
 	// collision
 	if (sWorld.Collision && _mapInfo->collision)
 		CollideInterface.ActivateMap(_mapId);
-
-	if(sWorld.PathFinding /*&& _mapInfo->type != INSTANCE_PVP*/)
-		NavMeshInterface.LoadMap(_mapId);
 }
 
 Map::~Map()
Index: src/hearthstone-world/MapCell.cpp
===================================================================
--- src/hearthstone-world/MapCell.cpp	(revision 1490)
+++ src/hearthstone-world/MapCell.cpp	(working copy)
@@ -78,10 +78,9 @@
 
 		if (_mapmgr->IsCollisionEnabled())
 		{
-			CollideInterface.ActivateTile(_mapmgr->GetMapId(), x, y);
-
-			if(sWorld.PathFinding)
-				NavMeshInterface.LoadNavMesh(_mapmgr->GetMapId(), x, y);
+			if(CollideInterface.ActivateTile(_mapmgr->GetMapId(), x, y))
+				if(sWorld.PathFinding)
+					NavMeshInterface.LoadNavMesh(_mapmgr->GetMapId(), x, y);
 		}
 	}
 	else if(_active && !state)
Index: src/hearthstone-world/NavMeshInterface.cpp
===================================================================
--- src/hearthstone-world/NavMeshInterface.cpp	(revision 1490)
+++ src/hearthstone-world/NavMeshInterface.cpp	(working copy)
@@ -24,44 +24,80 @@
 void CNavMeshInterface::Init()
 {
 	Log.Notice("NavMeshInterface", "Init");
-	memset( internalX, 0, sizeof(uint32)*NUM_MAPS*64 );
-	memset( internalY, 0, sizeof(uint32)*NUM_MAPS*64 );
-	memset( m_navMesh, 0, sizeof(dtNavMesh*)*NUM_MAPS );
-	memset( m_navMeshLoadCount, 0, sizeof(int64)*NUM_MAPS*64*64 );
+	memset( MMaps, 0, sizeof(MMapManager*)*NUM_MAPS );
 }
 
 void CNavMeshInterface::DeInit()
 {
-	// bleh.
+	for(uint32 i = 0; i < NUM_MAPS; i++)
+		delete MMaps[i];
 }
 
-// CellHandler.h
-uint32 CNavMeshInterface::GetPosX(float x)
+MMapManager* CNavMeshInterface::GetOrCreateMMapManager(uint32 mapid)
 {
-	ASSERT((x >= _minX) && (x <= _maxX));
-	return (uint32)((_maxX-x)/_cellSize);
+	if(MMaps[mapid] != NULL)
+		return MMaps[mapid];
+
+	return (MMaps[mapid] = new MMapManager(mapid));
 }
 
-uint32 CNavMeshInterface::GetPosY(float y)
+bool CNavMeshInterface::IsNavmeshLoaded(uint32 mapid, uint32 x, uint32 y)
 {
-	ASSERT((y >= _minY) && (y <= _maxY));
-	return (uint32)((_maxY-y)/_cellSize);
+	MMapManager* mmap = GetOrCreateMMapManager(mapid);
+	return mmap->IsNavmeshLoaded(x, y);
 }
 
-void CNavMeshInterface::LoadMap(uint32 mapid)
+bool CNavMeshInterface::LoadNavMesh(uint32 mapid, uint32 x, uint32 y)
 {
-	if(m_navMesh[mapid] != NULL)
-		return;
+	MMapManager* mmap = GetOrCreateMMapManager(mapid);
+	return mmap->LoadNavMesh(x, y);
+}
 
+void CNavMeshInterface::UnloadNavMesh(uint32 mapid, uint32 x, uint32 y)
+{
+	MMapManager* mmap = GetOrCreateMMapManager(mapid);
+	mmap->UnloadNavMesh(x, y);
+}
+
+bool CNavMeshInterface::BuildPath(uint32 mapid, float startx, float starty, float startz, float endx, float endy, float endz, LocationVector& out)
+{
+	MMapManager* mmap = GetOrCreateMMapManager(mapid);
+	return mmap->getNextPositionOnPathToLocation(startx, starty, startz, endx, endy, endz, out);
+}
+
+LocationVector CNavMeshInterface::BuildPath(uint32 mapid, float startx, float starty, float startz, float endx, float endy, float endz, bool best)
+{
+	MMapManager* mmap = GetOrCreateMMapManager(mapid);
+	if(best)
+		return mmap->getBestPositionOnPathToLocation(startx, starty, startz, endx, endy, endz);
+	return mmap->getNextPositionOnPathToLocation(startx, starty, startz, endx, endy, endz);
+}
+
+float CNavMeshInterface::GetWalkingHeight(uint32 mapid, float x, float y, float z, float z2)
+{
+	LocationVector Step;
+	float height = MMAP_UNAVAILABLE;
+	MMapManager* mmap = GetOrCreateMMapManager(mapid);
+	if(mmap->GetWalkingHeightInternal(x, y, z, z2, Step))
+		height = Step.z;
+	return height;
+}
+
+MMapManager::MMapManager(uint32 mapid)
+{
+	lastTileRef = 0;
+	m_navMesh = NULL;
+	ManagerMapId = mapid;
+
 	// load and init dtNavMesh - read parameters from file
 	uint32 pathLen = uint32(sWorld.MMapPath.length() + strlen("/000.mmap")+1);
 	char *fileName = new char[pathLen];
-	snprintf(fileName, pathLen, (sWorld.MMapPath+"/%03i.mmap").c_str(), mapid);
+	snprintf(fileName, pathLen, (sWorld.MMapPath+"/%03i.mmap").c_str(), ManagerMapId);
 
 	FILE* file = fopen(fileName, "rb");
 	if (!file)
 	{
-		Log.Notice("NavMeshInterface", "Could not load mmap %03i", mapid);
+		Log.Notice("NavMeshInterface", "Could not load mmap %03i", ManagerMapId);
 		delete [] fileName;
 		return;
 	}
@@ -75,51 +111,79 @@
 	if(mesh->init(&params) != DT_SUCCESS)
 	{
 		freeNavMesh(mesh);
-		Log.Error("NavMeshInterface", "Failed to initialize dtNavMesh for mmap %03u from file %s", mapid, fileName);
+		Log.Error("NavMeshInterface", "Failed to initialize dtNavMesh for mmap %03u from file %s", ManagerMapId, fileName);
 		delete [] fileName;
 		return;
 	}
 
 	delete [] fileName;
 
-	Log.Debug("NavMeshInterface", "Loaded %03i.mmap", mapid);
+	Log.Debug("NavMeshInterface", "Loaded %03i.mmap", ManagerMapId);
 
 	// store inside our map list
-	m_navMesh[mapid] = mesh;
+	m_navMesh = mesh;
 }
 
-dtNavMesh* CNavMeshInterface::GetNavmesh(uint32 mapid)
+MMapManager::~MMapManager()
 {
-	return m_navMesh[mapid];
+	delete m_navMesh;
 }
 
-bool CNavMeshInterface::IsNavmeshLoadedAtPosition(uint32 mapid, float x, float y)
+float MMapManager::calcAngle( float Position1X, float Position1Y, float Position2X, float Position2Y )
 {
-	int tileX = GetPosX(x)/8;
-	int tileY = GetPosY(y)/8;
-	return IsNavmeshLoaded(mapid, tileX, tileY);
-}
+	float dx = Position2X-Position1X;
+	float dy = Position2Y-Position1Y;
+	double angle = 0.0f;
 
-bool CNavMeshInterface::IsNavmeshLoaded(uint32 mapid, uint32 x, uint32 y)
-{
-	if(!internalX[mapid][x] && !internalY[mapid][y])
-		return false;
-	return (m_navMeshLoadCount[mapid][internalX[mapid][x]][internalY[mapid][y]] > 0 ? true : false);
+	// Calculate angle
+	if (dx == 0.0)
+	{
+		if (dy == 0.0)
+			angle = 0.0;
+		else if (dy > 0.0)
+			angle = M_PI * 0.5 /* / 2 */;
+		else
+			angle = M_PI * 3.0 * 0.5/* / 2 */;
+	}
+	else if (dy == 0.0)
+	{
+		if (dx > 0.0)
+			angle = 0.0;
+		else
+			angle = M_PI;
+	}
+	else
+	{
+		if (dx < 0.0)
+			angle = atanf(dy/dx) + M_PI;
+		else if (dy < 0.0)
+			angle = atanf(dy/dx) + (2*M_PI);
+		else
+			angle = atanf(dy/dx);
+	}
+
+	// Convert to degrees
+	angle = angle * float(180 / M_PI);
+
+	// Return
+	return float(angle);
 }
 
-bool CNavMeshInterface::LoadNavMesh(uint32 mapid, uint32 x, uint32 y)
+bool MMapManager::LoadNavMesh(uint32 x, uint32 y)
 {
-	if(m_navMesh[mapid] == NULL)
+	if(m_navMesh == NULL)
 		return false;
 
-	if(!IsNavmeshLoaded(mapid, x, y))
+	uint32 PackedTileID = packTileID(x, y);
+	dtTileRef reference = 0;
+
+	ReferenceMap::iterator itr = TileReferences.find(PackedTileID);
+	if(itr == TileReferences.end())
 	{
-		ASSERT(m_navMesh[mapid]);
-
 		// load this tile :: mmaps/MMMXXYY.mmtile
 		uint32 pathLen = uint32(sWorld.MMapPath.length() + strlen("/0000000.mmtile")+1);
 		char *fileName = new char[pathLen];
-		snprintf(fileName, pathLen, (sWorld.MMapPath+"/%03i%02i%02i.mmtile").c_str(), mapid, x, y);
+		snprintf(fileName, pathLen, (sWorld.MMapPath+"/%03i%02i%02i.mmtile").c_str(), ManagerMapId, x, y);
 		FILE *file = fopen(fileName, "rb");
 		if (!file)
 		{
@@ -134,14 +198,14 @@
 		fread(&fileHeader, sizeof(MmapTileHeader), 1, file);
 		if (fileHeader.mmapMagic != MMAP_MAGIC)
 		{
-			Log.Error("NavMeshInterface", "Bad header in mmap %03u%02i%02i.mmtile", mapid, x, y);
+			Log.Error("NavMeshInterface", "Bad header in mmap %03u%02i%02i.mmtile", ManagerMapId, x, y);
 			fclose(file);
 			return false;
 		}
 
 		if (fileHeader.mmapVersion != MMAP_VERSION)
 		{
-			Log.Error("NavMeshInterface", "%03u%02i%02i.mmtile was built with generator v%i, expected v%i", mapid, x, y, fileHeader.mmapVersion, MMAP_VERSION);
+			Log.Error("NavMeshInterface", "%03u%02i%02i.mmtile was built with generator v%i, expected v%i", ManagerMapId, x, y, fileHeader.mmapVersion, MMAP_VERSION);
 			fclose(file);
 			return false;
 		}
@@ -152,7 +216,7 @@
 		size_t result = fread(data, fileHeader.size, 1, file);
 		if(!result)
 		{
-			Log.Error("NavMeshInterface", "Bad header or data in mmap %03u%02i%02i.mmtile", mapid, x, y);
+			Log.Error("NavMeshInterface", "Bad header or data in mmap %03u%02u%02u.mmtile", ManagerMapId, x, y);
 			fclose(file);
 			return false;
 		}
@@ -162,83 +226,74 @@
 		dtMeshHeader* header = (dtMeshHeader*)data;
 
 		// memory allocated for data is now managed by detour, and will be deallocated when the tile is removed
-		dtresult = m_navMesh[mapid]->addTile(data, fileHeader.size, DT_TILE_FREE_DATA, 0, 0);
-		if(dtresult == DT_IN_PROGRESS)
-		{	// We already have it loaded, oops.
-			internalX[mapid][x] = header->x;
-			internalY[mapid][y] = header->y;
+		dtresult = m_navMesh->addTile(data, fileHeader.size, DT_TILE_FREE_DATA, 0, &reference);
+		if(dtresult & DT_IN_PROGRESS) // We already have it loaded, oops.
 			free(data);
-		}
-		else if(dtresult != DT_SUCCESS)
+		else if(dtresult & DT_FAILURE)
 		{
 			free(data);
-			Log.Error("NavMeshInterface", "Could not load %03u%02i%02i.mmtile into navmesh", mapid, x, y);
+			Log.Error("NavMeshInterface", "Could not load %03u%02u%02u.mmtile into navmesh", ManagerMapId, x, y);
 			return false;
 		}
-		else
-		{
-			internalX[mapid][x] = header->x;
-			internalY[mapid][y] = header->y;
-			Log.Debug("NavMeshInterface", "Loaded mmtile %03i[%02i,%02i] into %03i[%02i,%02i]", mapid, x, y, mapid, internalX[mapid][x], internalY[mapid][y]);
-		}
+		else Log.Debug("NavMeshInterface", "Loaded mmtile %03u[%04u] into %03u[%02u,%02u]", ManagerMapId, reference, ManagerMapId, x, y);
+
+		TileReferences.insert(make_pair(PackedTileID, new TileReferenceC(reference)));
 	}
+	else reference = itr->second->ID;
 
-	m_navMeshLoadCount[mapid][internalX[mapid][x]][internalY[mapid][y]]++;
+	TileLoadCount[reference]++;
 	return true;
 }
 
-void CNavMeshInterface::UnloadNavMesh(uint32 mapid, uint32 x, uint32 y)
+void MMapManager::UnloadNavMesh(uint32 x, uint32 y)
 {
-	if(m_navMeshLoadCount[mapid][internalX[mapid][x]][internalY[mapid][y]] == 1)
+	if(m_navMesh == NULL)
+		return;
+
+	uint32 PackedTileID = packTileID(x, y);
+	ReferenceMap::iterator itr = TileReferences.find(PackedTileID);
+	if(itr == TileReferences.end())
+		return; // We aren't loaded, so why continue?
+
+	dtTileRef reference = itr->second->ID;
+	if(TileLoadCount[reference] == 1)
 	{
-		if(m_navMesh[mapid]->removeTile(m_navMesh[mapid]->getTileRefAt(internalX[mapid][x], internalY[mapid][y]), NULL, NULL) != DT_SUCCESS)
+		dtStatus status = m_navMesh->removeTile(reference, NULL, NULL);
+		if(status & DT_FAILURE)
 		{
-			Log.Error("NavMeshInterface", "Failed to unload mmtile %03i[%02i,%02i] from %03i[%02i,%02i]", mapid, internalX[mapid][x], internalY[mapid][y], mapid, x, y);
+			if(status & DT_INVALID_PARAM)
+				Log.Error("NavMeshInterface", "Invalid reference for mmtile %03u[%04u] from %03u[%02u,%02u]", ManagerMapId, reference, ManagerMapId, x, y);
+			else
+				Log.Error("NavMeshInterface", "Failed to unload mmtile %03u[%04u] from %03u[%02u,%02u]", ManagerMapId, reference, ManagerMapId, x, y);
 			return;
 		}
-		Log.Debug("NavMeshInterface", "Unloaded mmtile %03i[%02i,%02i] from %03i[%02i,%02i]", mapid, internalX[mapid][x], internalY[mapid][y], mapid, x, y);
+		delete itr->second;
+		TileReferences.erase(itr);
+		Log.Debug("NavMeshInterface", "Unloaded mmtile %03u[%04i] from %03u[%02u,%02u]", ManagerMapId, reference, ManagerMapId, x, y);
 	}
 
-	m_navMeshLoadCount[mapid][internalX[mapid][x]][internalY[mapid][y]]--;
+	TileLoadCount[reference]--;
 }
 
-LocationVector CNavMeshInterface::getBestPositionOnPathToLocation(uint32 mapid, float startx, float starty, float startz, float endx, float endy, float endz)
+bool MMapManager::IsNavmeshLoaded(uint32 x, uint32 y)
 {
-	LocationVector pos(startx, starty, startz);
-	LocationVector nextpos(startx, starty, startz);
-	LocationVector returnpos(endx, endy, endz);
-	pos = getNextPositionOnPathToLocation(mapid, startx, starty, startz, endx, endy, endz);
-	float line = calcAngle(startx, starty, pos.x, pos.y);
-	while(1)
-	{
-		nextpos = getNextPositionOnPathToLocation(mapid, pos.x, pos.y, pos.z, endx, endy, endz);
-		float angle = calcAngle( startx, starty, nextpos.x, nextpos.y );
-		if(angle != line)
-		{	// We have to turn, so stop our line here.
-			returnpos = pos;
-			break;
-		}
-		if(pos.x == nextpos.x || pos.y == nextpos.y)
-		{
-			returnpos = pos;
-			break;
-		}
-
-		pos = nextpos;
-	}
-	return returnpos;
+	uint32 PackedTileID = packTileID(x, y);
+	ReferenceMap::iterator itr = TileReferences.find(PackedTileID);
+	if(itr == TileReferences.end())
+		return false;
+	return true;
 }
 
-LocationVector CNavMeshInterface::getNextPositionOnPathToLocation(uint32 mapid, float startx, float starty, float startz, float endx, float endy, float endz)
+LocationVector MMapManager::getNextPositionOnPathToLocation(float startx, float starty, float startz, float endx, float endy, float endz)
 {
-	if(m_navMesh[mapid] == NULL)
+	if(m_navMesh == NULL)
 		return LocationVector(endx, endy, endz);
 
 	dtNavMeshQuery* query = mallocNavMeshQuery();
-	if(query->init(m_navMesh[mapid], 1024) != DT_SUCCESS)
+	if(query->init(m_navMesh, 1024) != DT_SUCCESS)
 	{
 		freeNavMeshQuery(query);
-		Log.Error("NavMeshInterface", "Failed to initialize dtNavMeshQuery for mapId %03u", mapid);
+		Log.Error("NavMeshInterface", "Failed to initialize dtNavMeshQuery for mapId %03u", ManagerMapId);
 		return LocationVector(endx, endy, endz);
 	}
 
@@ -314,16 +369,16 @@
 	return pos;
 }
 
-bool CNavMeshInterface::getNextPositionOnPathToLocation(uint32 mapid, float startx, float starty, float startz, float endx, float endy, float endz, LocationVector& out)
+bool MMapManager::getNextPositionOnPathToLocation(float startx, float starty, float startz, float endx, float endy, float endz, LocationVector& out)
 {
-	if(m_navMesh[mapid] == NULL)
+	if(m_navMesh == NULL)
 		return false;
 
 	dtNavMeshQuery* query = mallocNavMeshQuery();
-	if(query->init(m_navMesh[mapid], 1024) != DT_SUCCESS)
+	if(query->init(m_navMesh, 1024) != DT_SUCCESS)
 	{
 		freeNavMeshQuery(query);
-		Log.Error("NavMeshInterface", "Failed to initialize dtNavMeshQuery for mapId %03u", mapid);
+		Log.Error("NavMeshInterface", "Failed to initialize dtNavMeshQuery for mapId %03u", ManagerMapId);
 		return false;
 	}
 
@@ -395,24 +450,51 @@
 	return false;
 }
 
-bool CNavMeshInterface::GetWalkingHeightInternal(uint32 mapid, float positionx, float positiony, float positionz, float endz, LocationVector& out)
+LocationVector MMapManager::getBestPositionOnPathToLocation(float startx, float starty, float startz, float endx, float endy, float endz)
 {
-	if(m_navMesh[mapid] == NULL)
+	LocationVector pos(startx, starty, startz);
+	LocationVector nextpos(startx, starty, startz);
+	LocationVector returnpos(endx, endy, endz);
+	pos = getNextPositionOnPathToLocation(startx, starty, startz, endx, endy, endz);
+	float line = calcAngle(startx, starty, pos.x, pos.y);
+	while(1)
+	{
+		nextpos = getNextPositionOnPathToLocation(pos.x, pos.y, pos.z, endx, endy, endz);
+		float angle = calcAngle( startx, starty, nextpos.x, nextpos.y );
+		if(angle != line)
+		{	// We have to turn, so stop our line here.
+			returnpos = pos;
+			break;
+		}
+		if(pos.x == nextpos.x || pos.y == nextpos.y)
+		{
+			returnpos = pos;
+			break;
+		}
+
+		pos = nextpos;
+	}
+	return returnpos;
+}
+
+bool MMapManager::GetWalkingHeightInternal(float positionx, float positiony, float positionz, float endz, LocationVector& out)
+{
+	if(m_navMesh == NULL)
 		return false;
 
 	dtNavMeshQuery* query = mallocNavMeshQuery();
-	if(query->init(m_navMesh[mapid], 1024) != DT_SUCCESS)
+	if(query->init(m_navMesh, 1024) != DT_SUCCESS)
 	{
 		freeNavMeshQuery(query);
-		Log.Error("NavMeshInterface", "Failed to initialize dtNavMeshQuery for mapId %03u", mapid);
+		Log.Error("NavMeshInterface", "Failed to initialize dtNavMeshQuery for mapId %03u", ManagerMapId);
 		return false;
 	}
 
 	dtStatus result;
 	//convert to nav coords.
-	float startPos[3] = { positiony, positionz, positionx };
-	float endPos[3] = { positiony, endz, positionx };
-	float mPolyPickingExtents[3] = { 2.00f, 4.00f, 2.00f };
+	float startPos[3] = { positionx, positiony, positionz };
+	float endPos[3] = { positionx, positiony, endz };
+	float mPolyPickingExtents[3] = { 2.00f, 2.00f, 4.00f };
 	float closestPoint[3] = {0.0f, 0.0f, 0.0f};
 	int gx = GetPosX(positionx)/8;
 	int gy = GetPosY(positiony)/8;
@@ -421,8 +503,9 @@
 	{
 		dtPolyRef mStartRef;
 		result = query->findNearestPoly(startPos, mPolyPickingExtents, mPathFilter, &mStartRef, closestPoint);
-		if(result != DT_SUCCESS || !mStartRef)
+		if(dtStatusFailed(result) || !mStartRef)
 		{
+			printf("Pieflavor1(%u|%u)\n", (dtStatusFailed(result) ? 1 : 0), uint32(mStartRef));
 			freeNavMeshQuery(query);
 			delete mPathFilter;
 			mPathFilter = NULL;
@@ -431,8 +514,9 @@
 
 		dtPolyRef mEndRef;
 		result = query->findNearestPoly(endPos, mPolyPickingExtents, mPathFilter, &mEndRef, closestPoint);
-		if(result != DT_SUCCESS || !mEndRef)
+		if(dtStatusFailed(result) || !mEndRef)
 		{
+			printf("Pieflavor2\n");
 			freeNavMeshQuery(query);
 			delete mPathFilter;
 			mPathFilter = NULL;
@@ -444,8 +528,9 @@
 			int mNumPathResults;
 			dtPolyRef mPathResults[50];
 			result = query->findPath(mStartRef, mEndRef,startPos, endPos, mPathFilter, mPathResults, &mNumPathResults, 50);
-			if(result != DT_SUCCESS || mNumPathResults <= 0)
+			if(dtStatusFailed(result) || mNumPathResults <= 0)
 			{
+				printf("Pieflavor3\n");
 				freeNavMeshQuery(query);
 				delete mPathFilter;
 				mPathFilter = NULL;
@@ -458,13 +543,16 @@
 			result = query->findStraightPath(startPos, endPos, mPathResults, mNumPathResults, actualpath, NULL, &polyrefs, &mNumPathPoints, 2);
 			if (result != DT_SUCCESS)
 			{
+				printf("Pieflavor4\n");
 				freeNavMeshQuery(query);
 				delete mPathFilter;
 				mPathFilter = NULL;
 				return false;
 			}
+
 			if(mNumPathPoints < 3)
 			{
+				printf("Pieflavor5\n");
 				out.y = positiony;
 				out.z = positionz;
 				out.x = positionx;
@@ -474,6 +562,7 @@
 				return true;
 			}
 
+			printf("Pieflavor6\n");
 			out.y = actualpath[3];
 			out.z = actualpath[4];
 			out.x = actualpath[5];
@@ -485,52 +574,3 @@
 	}
 	return false;
 }
-
-float CNavMeshInterface::GetWalkingHeight(uint32 mapid, float x, float y, float z, float z2)
-{
-	float height = MMAP_UNAVAILABLE;
-	LocationVector Step;
-	if(GetWalkingHeightInternal(mapid, x, y, z, z2, Step))
-		height = Step.z;
-	return height;
-}
-
-float CNavMeshInterface::calcAngle( float Position1X, float Position1Y, float Position2X, float Position2Y )
-{
-	float dx = Position2X-Position1X;
-	float dy = Position2Y-Position1Y;
-	double angle=0.0f;
-
-	// Calculate angle
-	if (dx == 0.0)
-	{
-		if (dy == 0.0)
-			angle = 0.0;
-		else if (dy > 0.0)
-			angle = M_PI * 0.5 /* / 2 */;
-		else
-			angle = M_PI * 3.0 * 0.5/* / 2 */;
-	}
-	else if (dy == 0.0)
-	{
-		if (dx > 0.0)
-			angle = 0.0;
-		else
-			angle = M_PI;
-	}
-	else
-	{
-		if (dx < 0.0)
-			angle = atanf(dy/dx) + M_PI;
-		else if (dy < 0.0)
-			angle = atanf(dy/dx) + (2*M_PI);
-		else
-			angle = atanf(dy/dx);
-	}
-
-	// Convert to degrees
-	angle = angle * float(180 / M_PI);
-
-	// Return
-	return float(angle);
-}
Index: src/hearthstone-world/NavMeshInterface.h
===================================================================
--- src/hearthstone-world/NavMeshInterface.h	(revision 1490)
+++ src/hearthstone-world/NavMeshInterface.h	(working copy)
@@ -36,36 +36,94 @@
 		mmapVersion(MMAP_VERSION), size(0), usesLiquids(true) {}
 };
 
-// Crow: TODO: Integrate Cell Handler royalties.
+struct TileReferenceC
+{
+	TileReferenceC(dtTileRef refid) { ID = refid; };
+	~TileReferenceC() {};
+
+	dtTileRef ID;
+};
+
+typedef map<uint32, TileReferenceC*> ReferenceMap;
+typedef map<dtTileRef, uint32> ReverseReferenceMap;
+
+class MMapManager
+{
+	uint32 GetPosX(float x)
+	{
+		ASSERT((x >= _minX) && (x <= _maxX));
+		return (uint32)((_maxX-x)/_cellSize);
+	};
+
+	uint32 GetPosY(float y)
+	{
+		ASSERT((y >= _minY) && (y <= _maxY));
+		return (uint32)((_maxY-y)/_cellSize);
+	};
+public:
+	MMapManager(uint32 mapid);
+	~MMapManager();
+
+private:
+	uint32 ManagerMapId;
+	dtNavMesh* m_navMesh;
+	dtTileRef lastTileRef;
+	ReferenceMap TileReferences;
+	ReverseReferenceMap TileLoadCount;
+	uint32 packTileID(int32 x, int32 y) { return uint32(x << 16 | y); };
+	float calcAngle( float Position1X, float Position1Y, float Position2X, float Position2Y );
+
+public:
+	bool LoadNavMesh(uint32 x, uint32 y);
+	void UnloadNavMesh(uint32 x, uint32 y);
+	bool IsNavmeshLoaded(uint32 x, uint32 y);
+
+	LocationVector getNextPositionOnPathToLocation(float startx, float starty, float startz, float endx, float endy, float endz);
+	LocationVector getBestPositionOnPathToLocation(float startx, float starty, float startz, float endx, float endy, float endz);
+
+	bool GetWalkingHeightInternal(float startx, float starty, float startz, float endz, LocationVector& out);
+	bool getNextPositionOnPathToLocation(float startx, float starty, float startz, float endx, float endy, float endz, LocationVector& out);
+};
+
 class SERVER_DECL CNavMeshInterface
 {
 public:
 	void Init();
 	void DeInit();
-	void LoadMap(uint32 mapid);
+	MMapManager* GetOrCreateMMapManager(uint32 mapid);
 
 public: // Navmesh settings
-	uint32 GetPosX(float x);
-	uint32 GetPosY(float y);
-	dtNavMesh* GetNavmesh(uint32 mapid);
 	bool LoadNavMesh(uint32 mapid, uint32 x, uint32 y);
+	void UnloadNavMesh(uint32 mapid, uint32 x, uint32 y);
 	bool IsNavmeshLoaded(uint32 mapid, uint32 x, uint32 y);
-	bool IsNavmeshLoadedAtPosition(uint32 mapid, float x, float y);
-	void UnloadNavMesh(uint32 mapid, uint32 x, uint32 y);
+	bool IsNavmeshLoadedAtPosition(uint32 mapid, float x, float y) { return IsNavmeshLoaded(mapid, (GetPosX(x)/8), (GetPosY(y)/8)); };
 
-	LocationVector getBestPositionOnPathToLocation(uint32 mapid, float startx, float starty, float startz, float endx, float endy, float endz);
-	LocationVector getNextPositionOnPathToLocation(uint32 mapid, float startx, float starty, float startz, float endx, float endy, float endz);
-	bool getNextPositionOnPathToLocation(uint32 mapid, float startx, float starty, float startz, float endx, float endy, float endz, LocationVector& out);
-	bool GetWalkingHeightInternal(uint32 mapid, float startx, float starty, float startz, float endz, LocationVector& out);
 	float GetWalkingHeight(uint32 mapid, float positionx, float positiony, float positionz, float positionz2);
+	bool BuildPath(uint32 mapid, float startx, float starty, float startz, float endx, float endy, float endz, LocationVector& out);
+	LocationVector BuildPath(uint32 mapid, float startx, float starty, float startz, float endx, float endy, float endz, bool best = false);
 
 private:
-	float calcAngle( float Position1X, float Position1Y, float Position2X, float Position2Y );
+	uint32 GetPosX(float x)
+	{
+		ASSERT((x >= _minX) && (x <= _maxX));
+		return (uint32)((_maxX-x)/_cellSize);
+	};
 
-	dtNavMesh* m_navMesh[NUM_MAPS];
-	uint32 internalX[NUM_MAPS][64];
-	uint32 internalY[NUM_MAPS][64];
-	int64 m_navMeshLoadCount[NUM_MAPS][64][64];
+	uint32 GetPosY(float y)
+	{
+		ASSERT((y >= _minY) && (y <= _maxY));
+		return (uint32)((_maxY-y)/_cellSize);
+	};
+
+	MMapManager* GetMMap(uint32 mapid)
+	{
+		MMapManager* mmapreturn = NULL;
+		if(mapid < NUM_MAPS)
+			mmapreturn = MMaps[mapid];
+		return mmapreturn;
+	};
+
+	MMapManager* MMaps[NUM_MAPS];
 };
 
 extern SERVER_DECL CNavMeshInterface NavMeshInterface;
Index: win/VC100/hearthstone-shared.vcxproj
===================================================================
--- win/VC100/hearthstone-shared.vcxproj	(revision 1490)
+++ win/VC100/hearthstone-shared.vcxproj	(working copy)
@@ -276,11 +276,11 @@
     <ClCompile Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMeshBuilder.cpp" />
     <ClCompile Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMeshQuery.cpp" />
     <ClCompile Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNode.cpp" />
-    <ClCompile Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourObstacleAvoidance.cpp" />
     <ClCompile Include="..\..\src\hearthstone-shared\Pathfinding\Recast\Recast.cpp" />
     <ClCompile Include="..\..\src\hearthstone-shared\Pathfinding\Recast\RecastArea.cpp" />
     <ClCompile Include="..\..\src\hearthstone-shared\Pathfinding\Recast\RecastContour.cpp" />
     <ClCompile Include="..\..\src\hearthstone-shared\Pathfinding\Recast\RecastFilter.cpp" />
+    <ClCompile Include="..\..\src\hearthstone-shared\Pathfinding\Recast\RecastLayers.cpp" />
     <ClCompile Include="..\..\src\hearthstone-shared\Pathfinding\Recast\RecastMesh.cpp" />
     <ClCompile Include="..\..\src\hearthstone-shared\Pathfinding\Recast\RecastMeshDetail.cpp" />
     <ClCompile Include="..\..\src\hearthstone-shared\Pathfinding\Recast\RecastRasterization.cpp" />
@@ -375,7 +375,7 @@
     <ClInclude Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMeshBuilder.h" />
     <ClInclude Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMeshQuery.h" />
     <ClInclude Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNode.h" />
-    <ClInclude Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourObstacleAvoidance.h" />
+    <ClInclude Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourStatus.h" />
     <ClInclude Include="..\..\src\hearthstone-shared\Pathfinding\Recast\Recast.h" />
     <ClInclude Include="..\..\src\hearthstone-shared\PerfCounters.h" />
     <ClInclude Include="..\..\src\hearthstone-shared\Threading\Condition.h" />
Index: win/VC100/hearthstone-shared.vcxproj.filters
===================================================================
--- win/VC100/hearthstone-shared.vcxproj.filters	(revision 1490)
+++ win/VC100/hearthstone-shared.vcxproj.filters	(working copy)
@@ -264,6 +264,18 @@
     <ClCompile Include="..\..\src\hearthstone-shared\Network\SocketEngine_iocp.cpp">
       <Filter>Network\Engines\Win</Filter>
     </ClCompile>
+    <ClCompile Include="..\..\src\hearthstone-shared\DataStorage\DBC\DBC.cpp">
+      <Filter>Database\DataStores</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\hearthstone-shared\DataStorage\DBC\dbcfile.cpp">
+      <Filter>Database\DataStores</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\hearthstone-shared\DataStorage\DBC\DBCStores.cpp">
+      <Filter>Database\DataStores</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\hearthstone-shared\DataStorage\Database.cpp">
+      <Filter>Database</Filter>
+    </ClCompile>
     <ClCompile Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourCommon.cpp">
       <Filter>Util\Pathfinding\Detour</Filter>
     </ClCompile>
@@ -279,9 +291,6 @@
     <ClCompile Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNode.cpp">
       <Filter>Util\Pathfinding\Detour</Filter>
     </ClCompile>
-    <ClCompile Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourObstacleAvoidance.cpp">
-      <Filter>Util\Pathfinding\Detour</Filter>
-    </ClCompile>
     <ClCompile Include="..\..\src\hearthstone-shared\Pathfinding\Recast\Recast.cpp">
       <Filter>Util\Pathfinding\Recast</Filter>
     </ClCompile>
@@ -294,6 +303,9 @@
     <ClCompile Include="..\..\src\hearthstone-shared\Pathfinding\Recast\RecastFilter.cpp">
       <Filter>Util\Pathfinding\Recast</Filter>
     </ClCompile>
+    <ClCompile Include="..\..\src\hearthstone-shared\Pathfinding\Recast\RecastLayers.cpp">
+      <Filter>Util\Pathfinding\Recast</Filter>
+    </ClCompile>
     <ClCompile Include="..\..\src\hearthstone-shared\Pathfinding\Recast\RecastMesh.cpp">
       <Filter>Util\Pathfinding\Recast</Filter>
     </ClCompile>
@@ -306,18 +318,6 @@
     <ClCompile Include="..\..\src\hearthstone-shared\Pathfinding\Recast\RecastRegion.cpp">
       <Filter>Util\Pathfinding\Recast</Filter>
     </ClCompile>
-    <ClCompile Include="..\..\src\hearthstone-shared\DataStorage\DBC\DBC.cpp">
-      <Filter>Database\DataStores</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\src\hearthstone-shared\DataStorage\DBC\dbcfile.cpp">
-      <Filter>Database\DataStores</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\src\hearthstone-shared\DataStorage\DBC\DBCStores.cpp">
-      <Filter>Database\DataStores</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\src\hearthstone-shared\DataStorage\Database.cpp">
-      <Filter>Database</Filter>
-    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="..\..\src\hearthstone-shared\Config\Config.h">
@@ -666,27 +666,6 @@
     <ClInclude Include="..\..\src\hearthstone-shared\Network\SocketEngine_iocp.h">
       <Filter>Network\Engines\Win</Filter>
     </ClInclude>
-    <ClInclude Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourCommon.h">
-      <Filter>Util\Pathfinding\Detour</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMesh.h">
-      <Filter>Util\Pathfinding\Detour</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMeshBuilder.h">
-      <Filter>Util\Pathfinding\Detour</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMeshQuery.h">
-      <Filter>Util\Pathfinding\Detour</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNode.h">
-      <Filter>Util\Pathfinding\Detour</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourObstacleAvoidance.h">
-      <Filter>Util\Pathfinding\Detour</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\src\hearthstone-shared\Pathfinding\Recast\Recast.h">
-      <Filter>Util\Pathfinding\Recast</Filter>
-    </ClInclude>
     <ClInclude Include="..\..\src\hearthstone-shared\ByteConverter.h">
       <Filter>Util</Filter>
     </ClInclude>
@@ -711,5 +690,26 @@
     <ClInclude Include="..\..\src\hearthstone-shared\DataStorage\Field.h">
       <Filter>Database</Filter>
     </ClInclude>
+    <ClInclude Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourCommon.h">
+      <Filter>Util\Pathfinding\Detour</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMesh.h">
+      <Filter>Util\Pathfinding\Detour</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMeshBuilder.h">
+      <Filter>Util\Pathfinding\Detour</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMeshQuery.h">
+      <Filter>Util\Pathfinding\Detour</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNode.h">
+      <Filter>Util\Pathfinding\Detour</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourStatus.h">
+      <Filter>Util\Pathfinding\Detour</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\hearthstone-shared\Pathfinding\Recast\Recast.h">
+      <Filter>Util\Pathfinding\Recast</Filter>
+    </ClInclude>
   </ItemGroup>
 </Project>
\ No newline at end of file
